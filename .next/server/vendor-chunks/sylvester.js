/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sylvester";
exports.ids = ["vendor-chunks/sylvester"];
exports.modules = {

/***/ "(rsc)/./node_modules/sylvester/lib/node-sylvester/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Copyright (c) 2011, Chris Umbel\n\nexports.Vector = __webpack_require__(/*! ./vector */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\nglobal.$V = exports.Vector.create;\nexports.Matrix = __webpack_require__(/*! ./matrix */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/matrix.js\");\nglobal.$M = exports.Matrix.create;\nexports.Line = __webpack_require__(/*! ./line */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/line.js\");\nglobal.$L = exports.Line.create;\nexports.Plane = __webpack_require__(/*! ./plane */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/plane.js\");\nglobal.$P = exports.Plane.create;\nexports.Line.Segment = __webpack_require__(/*! ./line.segment */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/line.segment.js\");\nexports.Sylvester = __webpack_require__(/*! ./sylvester */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxtSEFBb0M7QUFDcEM7QUFDQSxtSEFBb0M7QUFDcEM7QUFDQSw2R0FBZ0M7QUFDaEM7QUFDQSxnSEFBa0M7QUFDbEM7QUFDQSxxSUFBZ0Q7QUFDaEQsNEhBQTBDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNpeWFtXFxEb2N1bWVudHNcXEFJLVBvd2VyZWQtQ2hhdGJvdFxcbm9kZV9tb2R1bGVzXFxzeWx2ZXN0ZXJcXGxpYlxcbm9kZS1zeWx2ZXN0ZXJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWxcblxuZXhwb3J0cy5WZWN0b3IgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuZ2xvYmFsLiRWID0gZXhwb3J0cy5WZWN0b3IuY3JlYXRlO1xuZXhwb3J0cy5NYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuZ2xvYmFsLiRNID0gZXhwb3J0cy5NYXRyaXguY3JlYXRlO1xuZXhwb3J0cy5MaW5lID0gcmVxdWlyZSgnLi9saW5lJyk7XG5nbG9iYWwuJEwgPSBleHBvcnRzLkxpbmUuY3JlYXRlO1xuZXhwb3J0cy5QbGFuZSA9IHJlcXVpcmUoJy4vcGxhbmUnKTtcbmdsb2JhbC4kUCA9IGV4cG9ydHMuUGxhbmUuY3JlYXRlO1xuZXhwb3J0cy5MaW5lLlNlZ21lbnQgPSByZXF1aXJlKCcuL2xpbmUuc2VnbWVudCcpO1xuZXhwb3J0cy5TeWx2ZXN0ZXIgPSByZXF1aXJlKCcuL3N5bHZlc3RlcicpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sylvester/lib/node-sylvester/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sylvester/lib/node-sylvester/line.js":
/*!***********************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/line.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright (c) 2011, Chris Umbel, James Coglan\nvar Vector = __webpack_require__(/*! ./vector */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\nvar Matrix = __webpack_require__(/*! ./matrix */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/matrix.js\");\nvar Plane = __webpack_require__(/*! ./plane */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/plane.js\");\nvar Sylvester = __webpack_require__(/*! ./sylvester */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\");\n\n// Line class - depends on Vector, and some methods require Matrix and Plane.\n\nfunction Line() {}\nLine.prototype = {\n\n  // Returns true if the argument occupies the same space as the line\n  eql: function(line) {\n    return (this.isParallelTo(line) && this.contains(line.anchor));\n  },\n\n  // Returns a copy of the line\n  dup: function() {\n    return Line.create(this.anchor, this.direction);\n  },\n\n  // Returns the result of translating the line by the given vector/array\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    return Line.create([\n      this.anchor.elements[0] + V[0],\n      this.anchor.elements[1] + V[1],\n      this.anchor.elements[2] + (V[2] || 0)\n    ], this.direction);\n  },\n\n  // Returns true if the line is parallel to the argument. Here, 'parallel to'\n  // means that the argument's direction is either parallel or antiparallel to\n  // the line's own direction. A line is parallel to a plane if the two do not\n  // have a unique intersection.\n  isParallelTo: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.isParallelTo(this); }\n    var theta = this.direction.angleFrom(obj.direction);\n    return (Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision);\n  },\n\n  // Returns the line's perpendicular distance from the argument,\n  // which can be a point, a line or a plane\n  distanceFrom: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.distanceFrom(this); }\n    if (obj.direction) {\n      // obj is a line\n      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }\n      var N = this.direction.cross(obj.direction).toUnitVector().elements;\n      var A = this.anchor.elements, B = obj.anchor.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, D = this.direction.elements;\n      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];\n      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);\n      if (modPA === 0) return 0;\n      // Assumes direction vector is normalized\n      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;\n      var sin2 = 1 - cosTheta*cosTheta;\n      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));\n    }\n  },\n\n  // Returns true iff the argument is a point on the line, or if the argument\n  // is a line segment lying within the receiver\n  contains: function(obj) {\n    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }\n    var dist = this.distanceFrom(obj);\n    return (dist !== null && dist <= Sylvester.precision);\n  },\n\n  // Returns the distance from the anchor of the given point. Negative values are\n  // returned for points that are in the opposite direction to the line's direction from\n  // the line's anchor point.\n  positionOf: function(point) {\n    if (!this.contains(point)) { return null; }\n    var P = point.elements || point;\n    var A = this.anchor.elements, D = this.direction.elements;\n    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];\n  },\n\n  // Returns true iff the line lies in the given plane\n  liesIn: function(plane) {\n    return plane.contains(this);\n  },\n\n  // Returns true iff the line has a unique point of intersection with the argument\n  intersects: function(obj) {\n    if (obj.normal) { return obj.intersects(this); }\n    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision);\n  },\n\n  // Returns the unique intersection point with the argument, if one exists\n  intersectionWith: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.intersectionWith(this); }\n    if (!this.intersects(obj)) { return null; }\n    var P = this.anchor.elements, X = this.direction.elements,\n        Q = obj.anchor.elements, Y = obj.direction.elements;\n    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];\n    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];\n    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;\n    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;\n    var XdotX = X1*X1 + X2*X2 + X3*X3;\n    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;\n    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;\n    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);\n    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);\n  },\n\n  // Returns the point on the line that is closest to the given point or line/line segment\n  pointClosestTo: function(obj) {\n    if (obj.start && obj.end) {\n      // obj is a line segment\n      var P = obj.pointClosestTo(this);\n      return (P === null) ? null : this.pointClosestTo(P);\n    } else if (obj.direction) {\n      // obj is a line\n      if (this.intersects(obj)) { return this.intersectionWith(obj); }\n      if (this.isParallelTo(obj)) { return null; }\n      var D = this.direction.elements, E = obj.direction.elements;\n      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];\n      // Create plane containing obj and the shared normal and intersect this with it\n      // Thank you: http://www.cgafaq.info/wiki/Line-line_distance\n      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);\n      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];\n      var P = Plane.create(obj.anchor, N);\n      return P.intersectionWith(this);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      if (this.contains(P)) { return Vector.create(P); }\n      var A = this.anchor.elements, D = this.direction.elements;\n      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];\n      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),\n          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);\n      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);\n      var k = this.distanceFrom(P) / V.modulus();\n      return Vector.create([\n        P[0] + V.elements[0] * k,\n        P[1] + V.elements[1] * k,\n        (P[2] || 0) + V.elements[2] * k\n      ]);\n    }\n  },\n\n  // Returns a copy of the line rotated by t radians about the given line. Works by\n  // finding the argument's closest point to this line's anchor point (call this C) and\n  // rotating the anchor about C. Also rotates the line's direction about the argument's.\n  // Be careful with this - the rotation axis' direction affects the outcome!\n  rotate: function(t, line) {\n    // If we're working in 2D\n    if (typeof(line.direction) == 'undefined') { line = Line.create(line.to3D(), Vector.k); }\n    var R = Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements, D = this.direction.elements;\n    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];\n    var x = A1 - C1, y = A2 - C2, z = A3 - C3;\n    return Line.create([\n      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z\n    ], [\n      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],\n      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],\n      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]\n    ]);\n  },\n\n  // Returns a copy of the line with its direction vector reversed.\n  // Useful when using lines for rotations.\n  reverse: function() {\n    return Line.create(this.anchor, this.direction.x(-1));\n  },\n\n  // Returns the line's reflection in the given point or line\n  reflectionIn: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements, D = this.direction.elements;\n      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];\n      var newA = this.anchor.reflectionIn(obj).elements;\n      // Add the line's direction vector to its anchor, then mirror that in the plane\n      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;\n      var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;\n      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];\n      return Line.create(newA, newD);\n    } else if (obj.direction) {\n      // obj is a line - reflection obtained by rotating PI radians about obj\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point - just reflect the line's anchor in it\n      var P = obj.elements || obj;\n      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);\n    }\n  },\n\n  // Set the line's anchor point and direction.\n  setVectors: function(anchor, direction) {\n    // Need to do this so that line's properties are not\n    // references to the arguments passed in\n    anchor = Vector.create(anchor);\n    direction = Vector.create(direction);\n    if (anchor.elements.length == 2) {anchor.elements.push(0); }\n    if (direction.elements.length == 2) { direction.elements.push(0); }\n    if (anchor.elements.length > 3 || direction.elements.length > 3) { return null; }\n    var mod = direction.modulus();\n    if (mod === 0) { return null; }\n    this.anchor = anchor;\n    this.direction = Vector.create([\n      direction.elements[0] / mod,\n      direction.elements[1] / mod,\n      direction.elements[2] / mod\n    ]);\n    return this;\n  }\n};\n\n// Constructor function\nLine.create = function(anchor, direction) {\n  var L = new Line();\n  return L.setVectors(anchor, direction);\n};\n\n// Axes\nLine.X = Line.create(Vector.Zero(3), Vector.i);\nLine.Y = Line.create(Vector.Zero(3), Vector.j);\nLine.Z = Line.create(Vector.Zero(3), Vector.k);\n\nmodule.exports = Line;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9saW5lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDZFQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyw2RUFBVTtBQUMvQixZQUFZLG1CQUFPLENBQUMsMkVBQVM7QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWE7O0FBRXJDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0NBQWtDO0FBQ2xDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMENBQTBDO0FBQzFDLHVFQUF1RTtBQUN2RTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzaXlhbVxcRG9jdW1lbnRzXFxBSS1Qb3dlcmVkLUNoYXRib3RcXG5vZGVfbW9kdWxlc1xcc3lsdmVzdGVyXFxsaWJcXG5vZGUtc3lsdmVzdGVyXFxsaW5lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWwsIEphbWVzIENvZ2xhblxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG52YXIgTWF0cml4ID0gcmVxdWlyZSgnLi9tYXRyaXgnKTtcbnZhciBQbGFuZSA9IHJlcXVpcmUoJy4vcGxhbmUnKTtcbnZhciBTeWx2ZXN0ZXIgPSByZXF1aXJlKCcuL3N5bHZlc3RlcicpO1xuXG4vLyBMaW5lIGNsYXNzIC0gZGVwZW5kcyBvbiBWZWN0b3IsIGFuZCBzb21lIG1ldGhvZHMgcmVxdWlyZSBNYXRyaXggYW5kIFBsYW5lLlxuXG5mdW5jdGlvbiBMaW5lKCkge31cbkxpbmUucHJvdG90eXBlID0ge1xuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJndW1lbnQgb2NjdXBpZXMgdGhlIHNhbWUgc3BhY2UgYXMgdGhlIGxpbmVcbiAgZXFsOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuICh0aGlzLmlzUGFyYWxsZWxUbyhsaW5lKSAmJiB0aGlzLmNvbnRhaW5zKGxpbmUuYW5jaG9yKSk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpbmVcbiAgZHVwOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTGluZS5jcmVhdGUodGhpcy5hbmNob3IsIHRoaXMuZGlyZWN0aW9uKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdHJhbnNsYXRpbmcgdGhlIGxpbmUgYnkgdGhlIGdpdmVuIHZlY3Rvci9hcnJheVxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgIHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcbiAgICByZXR1cm4gTGluZS5jcmVhdGUoW1xuICAgICAgdGhpcy5hbmNob3IuZWxlbWVudHNbMF0gKyBWWzBdLFxuICAgICAgdGhpcy5hbmNob3IuZWxlbWVudHNbMV0gKyBWWzFdLFxuICAgICAgdGhpcy5hbmNob3IuZWxlbWVudHNbMl0gKyAoVlsyXSB8fCAwKVxuICAgIF0sIHRoaXMuZGlyZWN0aW9uKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGxpbmUgaXMgcGFyYWxsZWwgdG8gdGhlIGFyZ3VtZW50LiBIZXJlLCAncGFyYWxsZWwgdG8nXG4gIC8vIG1lYW5zIHRoYXQgdGhlIGFyZ3VtZW50J3MgZGlyZWN0aW9uIGlzIGVpdGhlciBwYXJhbGxlbCBvciBhbnRpcGFyYWxsZWwgdG9cbiAgLy8gdGhlIGxpbmUncyBvd24gZGlyZWN0aW9uLiBBIGxpbmUgaXMgcGFyYWxsZWwgdG8gYSBwbGFuZSBpZiB0aGUgdHdvIGRvIG5vdFxuICAvLyBoYXZlIGEgdW5pcXVlIGludGVyc2VjdGlvbi5cbiAgaXNQYXJhbGxlbFRvOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLm5vcm1hbCB8fCAob2JqLnN0YXJ0ICYmIG9iai5lbmQpKSB7IHJldHVybiBvYmouaXNQYXJhbGxlbFRvKHRoaXMpOyB9XG4gICAgdmFyIHRoZXRhID0gdGhpcy5kaXJlY3Rpb24uYW5nbGVGcm9tKG9iai5kaXJlY3Rpb24pO1xuICAgIHJldHVybiAoTWF0aC5hYnModGhldGEpIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24gfHwgTWF0aC5hYnModGhldGEgLSBNYXRoLlBJKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBsaW5lJ3MgcGVycGVuZGljdWxhciBkaXN0YW5jZSBmcm9tIHRoZSBhcmd1bWVudCxcbiAgLy8gd2hpY2ggY2FuIGJlIGEgcG9pbnQsIGEgbGluZSBvciBhIHBsYW5lXG4gIGRpc3RhbmNlRnJvbTogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5ub3JtYWwgfHwgKG9iai5zdGFydCAmJiBvYmouZW5kKSkgeyByZXR1cm4gb2JqLmRpc3RhbmNlRnJvbSh0aGlzKTsgfVxuICAgIGlmIChvYmouZGlyZWN0aW9uKSB7XG4gICAgICAvLyBvYmogaXMgYSBsaW5lXG4gICAgICBpZiAodGhpcy5pc1BhcmFsbGVsVG8ob2JqKSkgeyByZXR1cm4gdGhpcy5kaXN0YW5jZUZyb20ob2JqLmFuY2hvcik7IH1cbiAgICAgIHZhciBOID0gdGhpcy5kaXJlY3Rpb24uY3Jvc3Mob2JqLmRpcmVjdGlvbikudG9Vbml0VmVjdG9yKCkuZWxlbWVudHM7XG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBCID0gb2JqLmFuY2hvci5lbGVtZW50cztcbiAgICAgIHJldHVybiBNYXRoLmFicygoQVswXSAtIEJbMF0pICogTlswXSArIChBWzFdIC0gQlsxXSkgKiBOWzFdICsgKEFbMl0gLSBCWzJdKSAqIE5bMl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvYmogaXMgYSBwb2ludFxuICAgICAgdmFyIFAgPSBvYmouZWxlbWVudHMgfHwgb2JqO1xuICAgICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgRCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgICAgdmFyIFBBMSA9IFBbMF0gLSBBWzBdLCBQQTIgPSBQWzFdIC0gQVsxXSwgUEEzID0gKFBbMl0gfHwgMCkgLSBBWzJdO1xuICAgICAgdmFyIG1vZFBBID0gTWF0aC5zcXJ0KFBBMSpQQTEgKyBQQTIqUEEyICsgUEEzKlBBMyk7XG4gICAgICBpZiAobW9kUEEgPT09IDApIHJldHVybiAwO1xuICAgICAgLy8gQXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9yIGlzIG5vcm1hbGl6ZWRcbiAgICAgIHZhciBjb3NUaGV0YSA9IChQQTEgKiBEWzBdICsgUEEyICogRFsxXSArIFBBMyAqIERbMl0pIC8gbW9kUEE7XG4gICAgICB2YXIgc2luMiA9IDEgLSBjb3NUaGV0YSpjb3NUaGV0YTtcbiAgICAgIHJldHVybiBNYXRoLmFicyhtb2RQQSAqIE1hdGguc3FydChzaW4yIDwgMCA/IDAgOiBzaW4yKSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGFyZ3VtZW50IGlzIGEgcG9pbnQgb24gdGhlIGxpbmUsIG9yIGlmIHRoZSBhcmd1bWVudFxuICAvLyBpcyBhIGxpbmUgc2VnbWVudCBseWluZyB3aXRoaW4gdGhlIHJlY2VpdmVyXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLnN0YXJ0ICYmIG9iai5lbmQpIHsgcmV0dXJuIHRoaXMuY29udGFpbnMob2JqLnN0YXJ0KSAmJiB0aGlzLmNvbnRhaW5zKG9iai5lbmQpOyB9XG4gICAgdmFyIGRpc3QgPSB0aGlzLmRpc3RhbmNlRnJvbShvYmopO1xuICAgIHJldHVybiAoZGlzdCAhPT0gbnVsbCAmJiBkaXN0IDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGFuY2hvciBvZiB0aGUgZ2l2ZW4gcG9pbnQuIE5lZ2F0aXZlIHZhbHVlcyBhcmVcbiAgLy8gcmV0dXJuZWQgZm9yIHBvaW50cyB0aGF0IGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIHRvIHRoZSBsaW5lJ3MgZGlyZWN0aW9uIGZyb21cbiAgLy8gdGhlIGxpbmUncyBhbmNob3IgcG9pbnQuXG4gIHBvc2l0aW9uT2Y6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5zKHBvaW50KSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHZhciBQID0gcG9pbnQuZWxlbWVudHMgfHwgcG9pbnQ7XG4gICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgRCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgIHJldHVybiAoUFswXSAtIEFbMF0pICogRFswXSArIChQWzFdIC0gQVsxXSkgKiBEWzFdICsgKChQWzJdIHx8IDApIC0gQVsyXSkgKiBEWzJdO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGxpbmUgbGllcyBpbiB0aGUgZ2l2ZW4gcGxhbmVcbiAgbGllc0luOiBmdW5jdGlvbihwbGFuZSkge1xuICAgIHJldHVybiBwbGFuZS5jb250YWlucyh0aGlzKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBsaW5lIGhhcyBhIHVuaXF1ZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgYXJndW1lbnRcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5ub3JtYWwpIHsgcmV0dXJuIG9iai5pbnRlcnNlY3RzKHRoaXMpOyB9XG4gICAgcmV0dXJuICghdGhpcy5pc1BhcmFsbGVsVG8ob2JqKSAmJiB0aGlzLmRpc3RhbmNlRnJvbShvYmopIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHVuaXF1ZSBpbnRlcnNlY3Rpb24gcG9pbnQgd2l0aCB0aGUgYXJndW1lbnQsIGlmIG9uZSBleGlzdHNcbiAgaW50ZXJzZWN0aW9uV2l0aDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5ub3JtYWwgfHwgKG9iai5zdGFydCAmJiBvYmouZW5kKSkgeyByZXR1cm4gb2JqLmludGVyc2VjdGlvbldpdGgodGhpcyk7IH1cbiAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhvYmopKSB7IHJldHVybiBudWxsOyB9XG4gICAgdmFyIFAgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgWCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzLFxuICAgICAgICBRID0gb2JqLmFuY2hvci5lbGVtZW50cywgWSA9IG9iai5kaXJlY3Rpb24uZWxlbWVudHM7XG4gICAgdmFyIFgxID0gWFswXSwgWDIgPSBYWzFdLCBYMyA9IFhbMl0sIFkxID0gWVswXSwgWTIgPSBZWzFdLCBZMyA9IFlbMl07XG4gICAgdmFyIFBzdWJRMSA9IFBbMF0gLSBRWzBdLCBQc3ViUTIgPSBQWzFdIC0gUVsxXSwgUHN1YlEzID0gUFsyXSAtIFFbMl07XG4gICAgdmFyIFhkb3RRc3ViUCA9IC0gWDEqUHN1YlExIC0gWDIqUHN1YlEyIC0gWDMqUHN1YlEzO1xuICAgIHZhciBZZG90UHN1YlEgPSBZMSpQc3ViUTEgKyBZMipQc3ViUTIgKyBZMypQc3ViUTM7XG4gICAgdmFyIFhkb3RYID0gWDEqWDEgKyBYMipYMiArIFgzKlgzO1xuICAgIHZhciBZZG90WSA9IFkxKlkxICsgWTIqWTIgKyBZMypZMztcbiAgICB2YXIgWGRvdFkgPSBYMSpZMSArIFgyKlkyICsgWDMqWTM7XG4gICAgdmFyIGsgPSAoWGRvdFFzdWJQICogWWRvdFkgLyBYZG90WCArIFhkb3RZICogWWRvdFBzdWJRKSAvIChZZG90WSAtIFhkb3RZICogWGRvdFkpO1xuICAgIHJldHVybiBWZWN0b3IuY3JlYXRlKFtQWzBdICsgaypYMSwgUFsxXSArIGsqWDIsIFBbMl0gKyBrKlgzXSk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgcG9pbnQgb24gdGhlIGxpbmUgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBnaXZlbiBwb2ludCBvciBsaW5lL2xpbmUgc2VnbWVudFxuICBwb2ludENsb3Nlc3RUbzogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5zdGFydCAmJiBvYmouZW5kKSB7XG4gICAgICAvLyBvYmogaXMgYSBsaW5lIHNlZ21lbnRcbiAgICAgIHZhciBQID0gb2JqLnBvaW50Q2xvc2VzdFRvKHRoaXMpO1xuICAgICAgcmV0dXJuIChQID09PSBudWxsKSA/IG51bGwgOiB0aGlzLnBvaW50Q2xvc2VzdFRvKFApO1xuICAgIH0gZWxzZSBpZiAob2JqLmRpcmVjdGlvbikge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZVxuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0cyhvYmopKSB7IHJldHVybiB0aGlzLmludGVyc2VjdGlvbldpdGgob2JqKTsgfVxuICAgICAgaWYgKHRoaXMuaXNQYXJhbGxlbFRvKG9iaikpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgIHZhciBEID0gdGhpcy5kaXJlY3Rpb24uZWxlbWVudHMsIEUgPSBvYmouZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgICAgdmFyIEQxID0gRFswXSwgRDIgPSBEWzFdLCBEMyA9IERbMl0sIEUxID0gRVswXSwgRTIgPSBFWzFdLCBFMyA9IEVbMl07XG4gICAgICAvLyBDcmVhdGUgcGxhbmUgY29udGFpbmluZyBvYmogYW5kIHRoZSBzaGFyZWQgbm9ybWFsIGFuZCBpbnRlcnNlY3QgdGhpcyB3aXRoIGl0XG4gICAgICAvLyBUaGFuayB5b3U6IGh0dHA6Ly93d3cuY2dhZmFxLmluZm8vd2lraS9MaW5lLWxpbmVfZGlzdGFuY2VcbiAgICAgIHZhciB4ID0gKEQzICogRTEgLSBEMSAqIEUzKSwgeSA9IChEMSAqIEUyIC0gRDIgKiBFMSksIHogPSAoRDIgKiBFMyAtIEQzICogRTIpO1xuICAgICAgdmFyIE4gPSBbeCAqIEUzIC0geSAqIEUyLCB5ICogRTEgLSB6ICogRTMsIHogKiBFMiAtIHggKiBFMV07XG4gICAgICB2YXIgUCA9IFBsYW5lLmNyZWF0ZShvYmouYW5jaG9yLCBOKTtcbiAgICAgIHJldHVybiBQLmludGVyc2VjdGlvbldpdGgodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9iaiBpcyBhIHBvaW50XG4gICAgICB2YXIgUCA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICBpZiAodGhpcy5jb250YWlucyhQKSkgeyByZXR1cm4gVmVjdG9yLmNyZWF0ZShQKTsgfVxuICAgICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgRCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgICAgdmFyIEQxID0gRFswXSwgRDIgPSBEWzFdLCBEMyA9IERbMl0sIEExID0gQVswXSwgQTIgPSBBWzFdLCBBMyA9IEFbMl07XG4gICAgICB2YXIgeCA9IEQxICogKFBbMV0tQTIpIC0gRDIgKiAoUFswXS1BMSksIHkgPSBEMiAqICgoUFsyXSB8fCAwKSAtIEEzKSAtIEQzICogKFBbMV0tQTIpLFxuICAgICAgICAgIHogPSBEMyAqIChQWzBdLUExKSAtIEQxICogKChQWzJdIHx8IDApIC0gQTMpO1xuICAgICAgdmFyIFYgPSBWZWN0b3IuY3JlYXRlKFtEMiAqIHggLSBEMyAqIHosIEQzICogeSAtIEQxICogeCwgRDEgKiB6IC0gRDIgKiB5XSk7XG4gICAgICB2YXIgayA9IHRoaXMuZGlzdGFuY2VGcm9tKFApIC8gVi5tb2R1bHVzKCk7XG4gICAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbXG4gICAgICAgIFBbMF0gKyBWLmVsZW1lbnRzWzBdICogayxcbiAgICAgICAgUFsxXSArIFYuZWxlbWVudHNbMV0gKiBrLFxuICAgICAgICAoUFsyXSB8fCAwKSArIFYuZWxlbWVudHNbMl0gKiBrXG4gICAgICBdKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpbmUgcm90YXRlZCBieSB0IHJhZGlhbnMgYWJvdXQgdGhlIGdpdmVuIGxpbmUuIFdvcmtzIGJ5XG4gIC8vIGZpbmRpbmcgdGhlIGFyZ3VtZW50J3MgY2xvc2VzdCBwb2ludCB0byB0aGlzIGxpbmUncyBhbmNob3IgcG9pbnQgKGNhbGwgdGhpcyBDKSBhbmRcbiAgLy8gcm90YXRpbmcgdGhlIGFuY2hvciBhYm91dCBDLiBBbHNvIHJvdGF0ZXMgdGhlIGxpbmUncyBkaXJlY3Rpb24gYWJvdXQgdGhlIGFyZ3VtZW50J3MuXG4gIC8vIEJlIGNhcmVmdWwgd2l0aCB0aGlzIC0gdGhlIHJvdGF0aW9uIGF4aXMnIGRpcmVjdGlvbiBhZmZlY3RzIHRoZSBvdXRjb21lIVxuICByb3RhdGU6IGZ1bmN0aW9uKHQsIGxpbmUpIHtcbiAgICAvLyBJZiB3ZSdyZSB3b3JraW5nIGluIDJEXG4gICAgaWYgKHR5cGVvZihsaW5lLmRpcmVjdGlvbikgPT0gJ3VuZGVmaW5lZCcpIHsgbGluZSA9IExpbmUuY3JlYXRlKGxpbmUudG8zRCgpLCBWZWN0b3Iuayk7IH1cbiAgICB2YXIgUiA9IE1hdHJpeC5Sb3RhdGlvbih0LCBsaW5lLmRpcmVjdGlvbikuZWxlbWVudHM7XG4gICAgdmFyIEMgPSBsaW5lLnBvaW50Q2xvc2VzdFRvKHRoaXMuYW5jaG9yKS5lbGVtZW50cztcbiAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBEID0gdGhpcy5kaXJlY3Rpb24uZWxlbWVudHM7XG4gICAgdmFyIEMxID0gQ1swXSwgQzIgPSBDWzFdLCBDMyA9IENbMl0sIEExID0gQVswXSwgQTIgPSBBWzFdLCBBMyA9IEFbMl07XG4gICAgdmFyIHggPSBBMSAtIEMxLCB5ID0gQTIgLSBDMiwgeiA9IEEzIC0gQzM7XG4gICAgcmV0dXJuIExpbmUuY3JlYXRlKFtcbiAgICAgIEMxICsgUlswXVswXSAqIHggKyBSWzBdWzFdICogeSArIFJbMF1bMl0gKiB6LFxuICAgICAgQzIgKyBSWzFdWzBdICogeCArIFJbMV1bMV0gKiB5ICsgUlsxXVsyXSAqIHosXG4gICAgICBDMyArIFJbMl1bMF0gKiB4ICsgUlsyXVsxXSAqIHkgKyBSWzJdWzJdICogelxuICAgIF0sIFtcbiAgICAgIFJbMF1bMF0gKiBEWzBdICsgUlswXVsxXSAqIERbMV0gKyBSWzBdWzJdICogRFsyXSxcbiAgICAgIFJbMV1bMF0gKiBEWzBdICsgUlsxXVsxXSAqIERbMV0gKyBSWzFdWzJdICogRFsyXSxcbiAgICAgIFJbMl1bMF0gKiBEWzBdICsgUlsyXVsxXSAqIERbMV0gKyBSWzJdWzJdICogRFsyXVxuICAgIF0pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBsaW5lIHdpdGggaXRzIGRpcmVjdGlvbiB2ZWN0b3IgcmV2ZXJzZWQuXG4gIC8vIFVzZWZ1bCB3aGVuIHVzaW5nIGxpbmVzIGZvciByb3RhdGlvbnMuXG4gIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBMaW5lLmNyZWF0ZSh0aGlzLmFuY2hvciwgdGhpcy5kaXJlY3Rpb24ueCgtMSkpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIGxpbmUncyByZWZsZWN0aW9uIGluIHRoZSBnaXZlbiBwb2ludCBvciBsaW5lXG4gIHJlZmxlY3Rpb25JbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5ub3JtYWwpIHtcbiAgICAgIC8vIG9iaiBpcyBhIHBsYW5lXG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBEID0gdGhpcy5kaXJlY3Rpb24uZWxlbWVudHM7XG4gICAgICB2YXIgQTEgPSBBWzBdLCBBMiA9IEFbMV0sIEEzID0gQVsyXSwgRDEgPSBEWzBdLCBEMiA9IERbMV0sIEQzID0gRFsyXTtcbiAgICAgIHZhciBuZXdBID0gdGhpcy5hbmNob3IucmVmbGVjdGlvbkluKG9iaikuZWxlbWVudHM7XG4gICAgICAvLyBBZGQgdGhlIGxpbmUncyBkaXJlY3Rpb24gdmVjdG9yIHRvIGl0cyBhbmNob3IsIHRoZW4gbWlycm9yIHRoYXQgaW4gdGhlIHBsYW5lXG4gICAgICB2YXIgQUQxID0gQTEgKyBEMSwgQUQyID0gQTIgKyBEMiwgQUQzID0gQTMgKyBEMztcbiAgICAgIHZhciBRID0gb2JqLnBvaW50Q2xvc2VzdFRvKFtBRDEsIEFEMiwgQUQzXSkuZWxlbWVudHM7XG4gICAgICB2YXIgbmV3RCA9IFtRWzBdICsgKFFbMF0gLSBBRDEpIC0gbmV3QVswXSwgUVsxXSArIChRWzFdIC0gQUQyKSAtIG5ld0FbMV0sIFFbMl0gKyAoUVsyXSAtIEFEMykgLSBuZXdBWzJdXTtcbiAgICAgIHJldHVybiBMaW5lLmNyZWF0ZShuZXdBLCBuZXdEKTtcbiAgICB9IGVsc2UgaWYgKG9iai5kaXJlY3Rpb24pIHtcbiAgICAgIC8vIG9iaiBpcyBhIGxpbmUgLSByZWZsZWN0aW9uIG9idGFpbmVkIGJ5IHJvdGF0aW5nIFBJIHJhZGlhbnMgYWJvdXQgb2JqXG4gICAgICByZXR1cm4gdGhpcy5yb3RhdGUoTWF0aC5QSSwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2JqIGlzIGEgcG9pbnQgLSBqdXN0IHJlZmxlY3QgdGhlIGxpbmUncyBhbmNob3IgaW4gaXRcbiAgICAgIHZhciBQID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcbiAgICAgIHJldHVybiBMaW5lLmNyZWF0ZSh0aGlzLmFuY2hvci5yZWZsZWN0aW9uSW4oW1BbMF0sIFBbMV0sIChQWzJdIHx8IDApXSksIHRoaXMuZGlyZWN0aW9uKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gU2V0IHRoZSBsaW5lJ3MgYW5jaG9yIHBvaW50IGFuZCBkaXJlY3Rpb24uXG4gIHNldFZlY3RvcnM6IGZ1bmN0aW9uKGFuY2hvciwgZGlyZWN0aW9uKSB7XG4gICAgLy8gTmVlZCB0byBkbyB0aGlzIHNvIHRoYXQgbGluZSdzIHByb3BlcnRpZXMgYXJlIG5vdFxuICAgIC8vIHJlZmVyZW5jZXMgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW5cbiAgICBhbmNob3IgPSBWZWN0b3IuY3JlYXRlKGFuY2hvcik7XG4gICAgZGlyZWN0aW9uID0gVmVjdG9yLmNyZWF0ZShkaXJlY3Rpb24pO1xuICAgIGlmIChhbmNob3IuZWxlbWVudHMubGVuZ3RoID09IDIpIHthbmNob3IuZWxlbWVudHMucHVzaCgwKTsgfVxuICAgIGlmIChkaXJlY3Rpb24uZWxlbWVudHMubGVuZ3RoID09IDIpIHsgZGlyZWN0aW9uLmVsZW1lbnRzLnB1c2goMCk7IH1cbiAgICBpZiAoYW5jaG9yLmVsZW1lbnRzLmxlbmd0aCA+IDMgfHwgZGlyZWN0aW9uLmVsZW1lbnRzLmxlbmd0aCA+IDMpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2YXIgbW9kID0gZGlyZWN0aW9uLm1vZHVsdXMoKTtcbiAgICBpZiAobW9kID09PSAwKSB7IHJldHVybiBudWxsOyB9XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBWZWN0b3IuY3JlYXRlKFtcbiAgICAgIGRpcmVjdGlvbi5lbGVtZW50c1swXSAvIG1vZCxcbiAgICAgIGRpcmVjdGlvbi5lbGVtZW50c1sxXSAvIG1vZCxcbiAgICAgIGRpcmVjdGlvbi5lbGVtZW50c1syXSAvIG1vZFxuICAgIF0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBDb25zdHJ1Y3RvciBmdW5jdGlvblxuTGluZS5jcmVhdGUgPSBmdW5jdGlvbihhbmNob3IsIGRpcmVjdGlvbikge1xuICB2YXIgTCA9IG5ldyBMaW5lKCk7XG4gIHJldHVybiBMLnNldFZlY3RvcnMoYW5jaG9yLCBkaXJlY3Rpb24pO1xufTtcblxuLy8gQXhlc1xuTGluZS5YID0gTGluZS5jcmVhdGUoVmVjdG9yLlplcm8oMyksIFZlY3Rvci5pKTtcbkxpbmUuWSA9IExpbmUuY3JlYXRlKFZlY3Rvci5aZXJvKDMpLCBWZWN0b3Iuaik7XG5MaW5lLlogPSBMaW5lLmNyZWF0ZShWZWN0b3IuWmVybygzKSwgVmVjdG9yLmspO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sylvester/lib/node-sylvester/line.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sylvester/lib/node-sylvester/line.segment.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/line.segment.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// Line.Segment class - depends on Line and its dependencies.\n\nvar Line = __webpack_require__(/*! ./line */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/line.js\");\nvar Vector = __webpack_require__(/*! ./vector */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\n\nLine.Segment = function() {};\nLine.Segment.prototype = {\n\n  // Returns true iff the line segment is equal to the argument\n  eql: function(segment) {\n    return (this.start.eql(segment.start) && this.end.eql(segment.end)) ||\n        (this.start.eql(segment.end) && this.end.eql(segment.start));\n  },\n\n  // Returns a copy of the line segment\n  dup: function() {\n    return Line.Segment.create(this.start, this.end);\n  },\n\n  // Returns the length of the line segment\n  length: function() {\n    var A = this.start.elements, B = this.end.elements;\n    var C1 = B[0] - A[0], C2 = B[1] - A[1], C3 = B[2] - A[2];\n    return Math.sqrt(C1*C1 + C2*C2 + C3*C3);\n  },\n\n  // Returns the line segment as a vector equal to its\n  // end point relative to its endpoint\n  toVector: function() {\n    var A = this.start.elements, B = this.end.elements;\n    return Vector.create([B[0] - A[0], B[1] - A[1], B[2] - A[2]]);\n  },\n\n  // Returns the segment's midpoint as a vector\n  midpoint: function() {\n    var A = this.start.elements, B = this.end.elements;\n    return Vector.create([(B[0] + A[0])/2, (B[1] + A[1])/2, (B[2] + A[2])/2]);\n  },\n\n  // Returns the plane that bisects the segment\n  bisectingPlane: function() {\n    return Plane.create(this.midpoint(), this.toVector());\n  },\n\n  // Returns the result of translating the line by the given vector/array\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    var S = this.start.elements, E = this.end.elements;\n    return Line.Segment.create(\n      [S[0] + V[0], S[1] + V[1], S[2] + (V[2] || 0)],\n      [E[0] + V[0], E[1] + V[1], E[2] + (V[2] || 0)]\n    );\n  },\n\n  // Returns true iff the line segment is parallel to the argument. It simply forwards\n  // the method call onto its line property.\n  isParallelTo: function(obj) {\n    return this.line.isParallelTo(obj);\n  },\n\n  // Returns the distance between the argument and the line segment's closest point to the argument\n  distanceFrom: function(obj) {\n    var P = this.pointClosestTo(obj);\n    return (P === null) ? null : P.distanceFrom(obj);\n  },\n\n  // Returns true iff the given point lies on the segment\n  contains: function(obj) {\n    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }\n    var P = (obj.elements || obj).slice();\n    if (P.length == 2) { P.push(0); }\n    if (this.start.eql(P)) { return true; }\n    var S = this.start.elements;\n    var V = Vector.create([S[0] - P[0], S[1] - P[1], S[2] - (P[2] || 0)]);\n    var vect = this.toVector();\n    return V.isAntiparallelTo(vect) && V.modulus() <= vect.modulus();\n  },\n\n  // Returns true iff the line segment intersects the argument\n  intersects: function(obj) {\n    return (this.intersectionWith(obj) !== null);\n  },\n\n  // Returns the unique point of intersection with the argument\n  intersectionWith: function(obj) {\n    if (!this.line.intersects(obj)) { return null; }\n    var P = this.line.intersectionWith(obj);\n    return (this.contains(P) ? P : null);\n  },\n\n  // Returns the point on the line segment closest to the given object\n  pointClosestTo: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var V = this.line.intersectionWith(obj);\n      if (V === null) { return null; }\n      return this.pointClosestTo(V);\n    } else {\n      // obj is a line (segment) or point\n      var P = this.line.pointClosestTo(obj);\n      if (P === null) { return null; }\n      if (this.contains(P)) { return P; }\n      return (this.line.positionOf(P) < 0 ? this.start : this.end).dup();\n    }\n  },\n\n  // Set the start and end-points of the segment\n  setPoints: function(startPoint, endPoint) {\n    startPoint = Vector.create(startPoint).to3D();\n    endPoint = Vector.create(endPoint).to3D();\n    if (startPoint === null || endPoint === null) { return null; }\n    this.line = Line.create(startPoint, endPoint.subtract(startPoint));\n    this.start = startPoint;\n    this.end = endPoint;\n    return this;\n  }\n};\n\n// Constructor function\nLine.Segment.create = function(v1, v2) {\n  var S = new Line.Segment();\n  return S.setPoints(v1, v2);\n};\n\nmodule.exports = Line.Segment;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9saW5lLnNlZ21lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMseUVBQVE7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLDZFQUFVOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNpeWFtXFxEb2N1bWVudHNcXEFJLVBvd2VyZWQtQ2hhdGJvdFxcbm9kZV9tb2R1bGVzXFxzeWx2ZXN0ZXJcXGxpYlxcbm9kZS1zeWx2ZXN0ZXJcXGxpbmUuc2VnbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTEsIENocmlzIFVtYmVsLCBKYW1lcyBDb2dsYW5cbi8vIExpbmUuU2VnbWVudCBjbGFzcyAtIGRlcGVuZHMgb24gTGluZSBhbmQgaXRzIGRlcGVuZGVuY2llcy5cblxudmFyIExpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuXG5MaW5lLlNlZ21lbnQgPSBmdW5jdGlvbigpIHt9O1xuTGluZS5TZWdtZW50LnByb3RvdHlwZSA9IHtcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBsaW5lIHNlZ21lbnQgaXMgZXF1YWwgdG8gdGhlIGFyZ3VtZW50XG4gIGVxbDogZnVuY3Rpb24oc2VnbWVudCkge1xuICAgIHJldHVybiAodGhpcy5zdGFydC5lcWwoc2VnbWVudC5zdGFydCkgJiYgdGhpcy5lbmQuZXFsKHNlZ21lbnQuZW5kKSkgfHxcbiAgICAgICAgKHRoaXMuc3RhcnQuZXFsKHNlZ21lbnQuZW5kKSAmJiB0aGlzLmVuZC5lcWwoc2VnbWVudC5zdGFydCkpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBsaW5lIHNlZ21lbnRcbiAgZHVwOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTGluZS5TZWdtZW50LmNyZWF0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnRcbiAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgQSA9IHRoaXMuc3RhcnQuZWxlbWVudHMsIEIgPSB0aGlzLmVuZC5lbGVtZW50cztcbiAgICB2YXIgQzEgPSBCWzBdIC0gQVswXSwgQzIgPSBCWzFdIC0gQVsxXSwgQzMgPSBCWzJdIC0gQVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KEMxKkMxICsgQzIqQzIgKyBDMypDMyk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgbGluZSBzZWdtZW50IGFzIGEgdmVjdG9yIGVxdWFsIHRvIGl0c1xuICAvLyBlbmQgcG9pbnQgcmVsYXRpdmUgdG8gaXRzIGVuZHBvaW50XG4gIHRvVmVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgQSA9IHRoaXMuc3RhcnQuZWxlbWVudHMsIEIgPSB0aGlzLmVuZC5lbGVtZW50cztcbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbQlswXSAtIEFbMF0sIEJbMV0gLSBBWzFdLCBCWzJdIC0gQVsyXV0pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHNlZ21lbnQncyBtaWRwb2ludCBhcyBhIHZlY3RvclxuICBtaWRwb2ludDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIEEgPSB0aGlzLnN0YXJ0LmVsZW1lbnRzLCBCID0gdGhpcy5lbmQuZWxlbWVudHM7XG4gICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUoWyhCWzBdICsgQVswXSkvMiwgKEJbMV0gKyBBWzFdKS8yLCAoQlsyXSArIEFbMl0pLzJdKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBwbGFuZSB0aGF0IGJpc2VjdHMgdGhlIHNlZ21lbnRcbiAgYmlzZWN0aW5nUGxhbmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBQbGFuZS5jcmVhdGUodGhpcy5taWRwb2ludCgpLCB0aGlzLnRvVmVjdG9yKCkpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0cmFuc2xhdGluZyB0aGUgbGluZSBieSB0aGUgZ2l2ZW4gdmVjdG9yL2FycmF5XG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgdmFyIFYgPSB2ZWN0b3IuZWxlbWVudHMgfHwgdmVjdG9yO1xuICAgIHZhciBTID0gdGhpcy5zdGFydC5lbGVtZW50cywgRSA9IHRoaXMuZW5kLmVsZW1lbnRzO1xuICAgIHJldHVybiBMaW5lLlNlZ21lbnQuY3JlYXRlKFxuICAgICAgW1NbMF0gKyBWWzBdLCBTWzFdICsgVlsxXSwgU1syXSArIChWWzJdIHx8IDApXSxcbiAgICAgIFtFWzBdICsgVlswXSwgRVsxXSArIFZbMV0sIEVbMl0gKyAoVlsyXSB8fCAwKV1cbiAgICApO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGxpbmUgc2VnbWVudCBpcyBwYXJhbGxlbCB0byB0aGUgYXJndW1lbnQuIEl0IHNpbXBseSBmb3J3YXJkc1xuICAvLyB0aGUgbWV0aG9kIGNhbGwgb250byBpdHMgbGluZSBwcm9wZXJ0eS5cbiAgaXNQYXJhbGxlbFRvOiBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5saW5lLmlzUGFyYWxsZWxUbyhvYmopO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGFyZ3VtZW50IGFuZCB0aGUgbGluZSBzZWdtZW50J3MgY2xvc2VzdCBwb2ludCB0byB0aGUgYXJndW1lbnRcbiAgZGlzdGFuY2VGcm9tOiBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgUCA9IHRoaXMucG9pbnRDbG9zZXN0VG8ob2JqKTtcbiAgICByZXR1cm4gKFAgPT09IG51bGwpID8gbnVsbCA6IFAuZGlzdGFuY2VGcm9tKG9iaik7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgZ2l2ZW4gcG9pbnQgbGllcyBvbiB0aGUgc2VnbWVudFxuICBjb250YWluczogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5zdGFydCAmJiBvYmouZW5kKSB7IHJldHVybiB0aGlzLmNvbnRhaW5zKG9iai5zdGFydCkgJiYgdGhpcy5jb250YWlucyhvYmouZW5kKTsgfVxuICAgIHZhciBQID0gKG9iai5lbGVtZW50cyB8fCBvYmopLnNsaWNlKCk7XG4gICAgaWYgKFAubGVuZ3RoID09IDIpIHsgUC5wdXNoKDApOyB9XG4gICAgaWYgKHRoaXMuc3RhcnQuZXFsKFApKSB7IHJldHVybiB0cnVlOyB9XG4gICAgdmFyIFMgPSB0aGlzLnN0YXJ0LmVsZW1lbnRzO1xuICAgIHZhciBWID0gVmVjdG9yLmNyZWF0ZShbU1swXSAtIFBbMF0sIFNbMV0gLSBQWzFdLCBTWzJdIC0gKFBbMl0gfHwgMCldKTtcbiAgICB2YXIgdmVjdCA9IHRoaXMudG9WZWN0b3IoKTtcbiAgICByZXR1cm4gVi5pc0FudGlwYXJhbGxlbFRvKHZlY3QpICYmIFYubW9kdWx1cygpIDw9IHZlY3QubW9kdWx1cygpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIHRoZSBhcmd1bWVudFxuICBpbnRlcnNlY3RzOiBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKHRoaXMuaW50ZXJzZWN0aW9uV2l0aChvYmopICE9PSBudWxsKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSB1bmlxdWUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIHdpdGggdGhlIGFyZ3VtZW50XG4gIGludGVyc2VjdGlvbldpdGg6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghdGhpcy5saW5lLmludGVyc2VjdHMob2JqKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHZhciBQID0gdGhpcy5saW5lLmludGVyc2VjdGlvbldpdGgob2JqKTtcbiAgICByZXR1cm4gKHRoaXMuY29udGFpbnMoUCkgPyBQIDogbnVsbCk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgcG9pbnQgb24gdGhlIGxpbmUgc2VnbWVudCBjbG9zZXN0IHRvIHRoZSBnaXZlbiBvYmplY3RcbiAgcG9pbnRDbG9zZXN0VG86IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsKSB7XG4gICAgICAvLyBvYmogaXMgYSBwbGFuZVxuICAgICAgdmFyIFYgPSB0aGlzLmxpbmUuaW50ZXJzZWN0aW9uV2l0aChvYmopO1xuICAgICAgaWYgKFYgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgIHJldHVybiB0aGlzLnBvaW50Q2xvc2VzdFRvKFYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvYmogaXMgYSBsaW5lIChzZWdtZW50KSBvciBwb2ludFxuICAgICAgdmFyIFAgPSB0aGlzLmxpbmUucG9pbnRDbG9zZXN0VG8ob2JqKTtcbiAgICAgIGlmIChQID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICBpZiAodGhpcy5jb250YWlucyhQKSkgeyByZXR1cm4gUDsgfVxuICAgICAgcmV0dXJuICh0aGlzLmxpbmUucG9zaXRpb25PZihQKSA8IDAgPyB0aGlzLnN0YXJ0IDogdGhpcy5lbmQpLmR1cCgpO1xuICAgIH1cbiAgfSxcblxuICAvLyBTZXQgdGhlIHN0YXJ0IGFuZCBlbmQtcG9pbnRzIG9mIHRoZSBzZWdtZW50XG4gIHNldFBvaW50czogZnVuY3Rpb24oc3RhcnRQb2ludCwgZW5kUG9pbnQpIHtcbiAgICBzdGFydFBvaW50ID0gVmVjdG9yLmNyZWF0ZShzdGFydFBvaW50KS50bzNEKCk7XG4gICAgZW5kUG9pbnQgPSBWZWN0b3IuY3JlYXRlKGVuZFBvaW50KS50bzNEKCk7XG4gICAgaWYgKHN0YXJ0UG9pbnQgPT09IG51bGwgfHwgZW5kUG9pbnQgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0aGlzLmxpbmUgPSBMaW5lLmNyZWF0ZShzdGFydFBvaW50LCBlbmRQb2ludC5zdWJ0cmFjdChzdGFydFBvaW50KSk7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0UG9pbnQ7XG4gICAgdGhpcy5lbmQgPSBlbmRQb2ludDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cbkxpbmUuU2VnbWVudC5jcmVhdGUgPSBmdW5jdGlvbih2MSwgdjIpIHtcbiAgdmFyIFMgPSBuZXcgTGluZS5TZWdtZW50KCk7XG4gIHJldHVybiBTLnNldFBvaW50cyh2MSwgdjIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lLlNlZ21lbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sylvester/lib/node-sylvester/line.segment.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sylvester/lib/node-sylvester/matrix.js":
/*!*************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/matrix.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// Matrix class - depends on Vector.\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar Sylvester = __webpack_require__(/*! ./sylvester */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\");\nvar Vector = __webpack_require__(/*! ./vector */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\n\n// augment a matrix M with identity rows/cols\nfunction identSize(M, m, n, k) {\n    var e = M.elements;\n    var i = k - 1;\n\n    while(i--) {\n\tvar row = [];\n\t\n\tfor(var j = 0; j < n; j++)\n\t    row.push(j == i ? 1 : 0);\n\t\n        e.unshift(row);\n    }\n    \n    for(var i = k - 1; i < m; i++) {\n        while(e[i].length < n)\n            e[i].unshift(0);\n    }\n\n    return $M(e);\n}\n\nfunction pca(X) {\n    var Sigma = X.transpose().x(X).x(1 / X.rows());\n    var svd = Sigma.svd();\n    return {U: svd.U, S: svd.S};\n}\n\nfunction Matrix() {}\nMatrix.prototype = {\n    pcaProject: function(k, U) {\n\tvar U = U || pca(this).U;\n\tvar Ureduce= U.slice(1, U.rows(), 1, k);\n\treturn {Z: this.x(Ureduce), U: U};\n    },\n\n    pcaRecover: function(U) {\n\tvar k = this.cols();\n\tvar Ureduce = U.slice(1, U.rows(), 1, k);\n\treturn this.x(Ureduce.transpose());\n    },    \n\n    triu: function(k) {\n\tif(!k)\n\t    k = 0;\n\t\n\treturn this.map(function(x, i, j) {\n\t    return j - i >= k ? x : 0;\n\t});\n    },\n\n    svd: function() {\n\tvar A = this;\n\tvar U = Matrix.I(A.rows());\n\tvar S = A.transpose();\n\tvar V = Matrix.I(A.cols());\n\tvar err = Number.MAX_VALUE;\n\tvar i = 0;\n\tvar maxLoop = 100;\n\n\twhile(err > 2.2737e-13 && i < maxLoop) {\n\t    var qr = S.transpose().qr();\n\t    S = qr.R;\n\t    U = U.x(qr.Q);\n\t    qr = S.transpose().qr();\n\t    V = V.x(qr.Q);\n\t    S = qr.R;\n\n\t    var e = S.triu(1).unroll().norm();\n\t    var f = S.diagonal().norm();\n\n\t    if(f == 0)\n\t\tf = 1;\n\n\t    err = e / f;\n\n\t    i++;\n\t}\n\n\tvar ss = S.diagonal();\n\tvar s = [];\n\n\tfor(var i = 1; i <= ss.cols(); i++) {\n\t    var ssn = ss.e(i);\n\t    s.push(Math.abs(ssn));\n\n\t    if(ssn < 0) {\n\t\tfor(var j = 0; j < U.rows(); j++) {\n\t\t    U.elements[j][i - 1] = -(U.elements[j][i - 1]);\n\t\t}\n\t    }\n\t}\n\n\treturn {U: U, S: $V(s).toDiagonalMatrix(), V: V};\n    },\n\n    unroll: function() {\n\tvar v = [];\n\t\n\tfor(var i = 1; i <= this.cols(); i++) {\n\t    for(var j = 1; j <= this.rows(); j++) {\n\t\tv.push(this.e(j, i));\n\t    }\n\t}\n\n\treturn $V(v);\n    },\n\n    qr: function() {\n\tvar m = this.rows();\n\tvar n = this.cols();\n\tvar Q = Matrix.I(m);\n\tvar A = this;\n\t\n\tfor(var k = 1; k < Math.min(m, n); k++) {\n\t    var ak = A.slice(k, 0, k, k).col(1);\n\t    var oneZero = [1];\n\t    \n\t    while(oneZero.length <=  m - k)\n\t\toneZero.push(0);\n\t    \n\t    oneZero = $V(oneZero);\n\t    var vk = ak.add(oneZero.x(ak.norm() * Math.sign(ak.e(1))));\n\t    var Vk = $M(vk);\n\t    var Hk = Matrix.I(m - k + 1).subtract(Vk.x(2).x(Vk.transpose()).div(Vk.transpose().x(Vk).e(1, 1)));\n\t    var Qk = identSize(Hk, m, n, k);\n\t    A = Qk.x(A);\n\t    Q = Q.x(Qk);\n\t}\n\n\treturn {Q: Q, R: A};\n    },\n\n\n    slice: function(startRow, endRow, startCol, endCol) {\n\tvar x = [];\n\t\n\tif(endRow == 0)\n\t    endRow = this.rows();\n\t\n\tif(endCol == 0)\n\t    endCol = this.cols();\n\n\tfor(i = startRow; i <= endRow; i++) {\n\t    var row = [];\n\n\t    for(j = startCol; j <= endCol; j++) {\n\t\trow.push(this.e(i, j));\n\t    }\n\n\t    x.push(row);\n\t}\n\n\treturn $M(x);\n    },\n\n    // Returns element (i,j) of the matrix\n    e: function(i,j) {\n\tif (i < 1 || i > this.elements.length || j < 1 || j > this.elements[0].length) { return null; }\n\treturn this.elements[i - 1][j - 1];\n    },\n\n    // Returns row k of the matrix as a vector\n    row: function(i) {\n\tif (i > this.elements.length) { return null; }\n\treturn $V(this.elements[i - 1]);\n    },\n\n    // Returns column k of the matrix as a vector\n    col: function(j) {\n\tif (j > this.elements[0].length) { return null; }\n\tvar col = [], n = this.elements.length;\n\tfor (var i = 0; i < n; i++) { col.push(this.elements[i][j - 1]); }\n\treturn $V(col);\n    },\n\n    // Returns the number of rows/columns the matrix has\n    dimensions: function() {\n\treturn {rows: this.elements.length, cols: this.elements[0].length};\n    },\n\n    // Returns the number of rows in the matrix\n    rows: function() {\n\treturn this.elements.length;\n    },\n\n    // Returns the number of columns in the matrix\n    cols: function() {\n\treturn this.elements[0].length;\n    },\n\n    // Returns true iff the matrix is equal to the argument. You can supply\n    // a vector as the argument, in which case the receiver must be a\n    // one-column matrix equal to the vector.\n    eql: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\tif (this.elements.length != M.length ||\n            this.elements[0].length != M[0].length) { return false; }\n\tvar i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) { j = nj;\n\t\t      while (j--) {\n\t\t\t  if (Math.abs(this.elements[i][j] - M[i][j]) > Sylvester.precision) { return false; }\n\t\t      }\n\t\t    }\n\treturn true;\n    },\n\n    // Returns a copy of the matrix\n    dup: function() {\n\treturn Matrix.create(this.elements);\n    },\n\n    // Maps the matrix to another matrix (of the same dimensions) according to the given function\n    map: function(fn) {\n    var els = [], i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) { j = nj;\n\t\t      els[i] = [];\n\t\t      while (j--) {\n\t\t\t  els[i][j] = fn(this.elements[i][j], i + 1, j + 1);\n\t\t      }\n\t\t    }\n\treturn Matrix.create(els);\n    },\n\n    // Returns true iff the argument has the same dimensions as the matrix\n    isSameSizeAs: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\treturn (this.elements.length == M.length &&\n\t\tthis.elements[0].length == M[0].length);\n    },\n\n    // Returns the result of adding the argument to the matrix\n    add: function(matrix) {\n\tif(typeof(matrix) == 'number') {\n\t    return this.map(function(x, i, j) { return x + matrix});\n\t} else {\n\t    var M = matrix.elements || matrix;\n\t    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\t    if (!this.isSameSizeAs(M)) { return null; }\n\t    return this.map(function(x, i, j) { return x + M[i - 1][j - 1]; });\n\t}\n    },\n\n    // Returns the result of subtracting the argument from the matrix\n    subtract: function(matrix) {\n\tif(typeof(matrix) == 'number') {\n\t    return this.map(function(x, i, j) { return x - matrix});\n\t} else {\n\t    var M = matrix.elements || matrix;\n\t    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\t    if (!this.isSameSizeAs(M)) { return null; }\n\t    return this.map(function(x, i, j) { return x - M[i - 1][j - 1]; });\n\t}\n    },\n\n    // Returns true iff the matrix can multiply the argument from the left\n    canMultiplyFromLeft: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\t// this.columns should equal matrix.rows\n\treturn (this.elements[0].length == M.length);\n    },\n\n    // Returns the result of a multiplication-style operation the matrix from the right by the argument.\n    // If the argument is a scalar then just operate on all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    mulOp: function(matrix, op) {\n\tif (!matrix.elements) {\n\t    return this.map(function(x) { return op(x, matrix); });\n\t}\n\n\tvar returnVector = matrix.modulus ? true : false;\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') \n\t    M = Matrix.create(M).elements;\n\tif (!this.canMultiplyFromLeft(M)) \n\t    return null; \n\tvar e = this.elements, rowThis, rowElem, elements = [],\n        sum, m = e.length, n = M[0].length, o = e[0].length, i = m, j, k;\n\n\twhile (i--) {\n            rowElem = [];\n            rowThis = e[i];\n            j = n;\n\n            while (j--) {\n\t\tsum = 0;\n\t\tk = o;\n\n\t\twhile (k--) {\n                    sum += op(rowThis[k], M[k][j]);\n\t\t}\n\n\t\trowElem[j] = sum;\n            }\n\n            elements[i] = rowElem;\n\t}\n\n\tvar M = Matrix.create(elements);\n\treturn returnVector ? M.col(1) : M;\n    },\n\n    // Returns the result of dividing the matrix from the right by the argument.\n    // If the argument is a scalar then just divide all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    div: function(matrix) {\n\treturn this.mulOp(matrix, function(x, y) { return x / y});\n    },\n\n    // Returns the result of multiplying the matrix from the right by the argument.\n    // If the argument is a scalar then just multiply all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    multiply: function(matrix) {\n\treturn this.mulOp(matrix, function(x, y) { return x * y});\n    },\n\n    x: function(matrix) { return this.multiply(matrix); },\n\n    elementMultiply: function(v) {\n        return this.map(function(k, i, j) {\n            return v.e(i, j) * k;\n        });\n    },\n\n    sum: function() {\n        var sum = 0;\n\n        this.map(function(x) { sum += x;});\n\n        return sum;\n    },\n\n    // Returns a Vector of each colum averaged.\n    mean: function() {\n      var dim = this.dimensions();\n      var r = [];\n      for (var i = 1; i <= dim.cols; i++) {\n        r.push(this.col(i).sum() / dim.rows);\n      }\n      return $V(r);\n    },\n\n    column: function(n) {\n\treturn this.col(n);\n    },\n\n    log: function() {\n\treturn this.map(function(x) { return Math.log(x); });\n    },\n\n    // Returns a submatrix taken from the matrix\n    // Argument order is: start row, start col, nrows, ncols\n    // Element selection wraps if the required index is outside the matrix's bounds, so you could\n    // use this to perform row/column cycling or copy-augmenting.\n    minor: function(a, b, c, d) {\n\tvar elements = [], ni = c, i, nj, j;\n\tvar rows = this.elements.length, cols = this.elements[0].length;\n\twhile (ni--) {\n\t    i = c - ni - 1;\n\t    elements[i] = [];\n\t    nj = d;\n\t    while (nj--) {\n\t\tj = d - nj - 1;\n\t\telements[i][j] = this.elements[(a + i - 1) % rows][(b + j - 1) % cols];\n\t    }\n\t}\n\treturn Matrix.create(elements);\n    },\n\n    // Returns the transpose of the matrix\n    transpose: function() {\n    var rows = this.elements.length, i, cols = this.elements[0].length, j;\n\tvar elements = [], i = cols;\n\twhile (i--) {\n\t    j = rows;\n\t    elements[i] = [];\n\t    while (j--) {\n\t\telements[i][j] = this.elements[j][i];\n\t    }\n\t}\n\treturn Matrix.create(elements);\n    },\n\n    // Returns true iff the matrix is square\n    isSquare: function() {\n\treturn (this.elements.length == this.elements[0].length);\n    },\n\n    // Returns the (absolute) largest element of the matrix\n    max: function() {\n\tvar m = 0, i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) {\n\t    j = nj;\n\t    while (j--) {\n\t\tif (Math.abs(this.elements[i][j]) > Math.abs(m)) { m = this.elements[i][j]; }\n\t    }\n\t}\n\treturn m;\n    },\n\n    // Returns the indeces of the first match found by reading row-by-row from left to right\n    indexOf: function(x) {\n\tvar index = null, ni = this.elements.length, i, nj = this.elements[0].length, j;\n\tfor (i = 0; i < ni; i++) {\n\t    for (j = 0; j < nj; j++) {\n\t\tif (this.elements[i][j] == x) { return {i: i + 1, j: j + 1}; }\n\t    }\n\t}\n\treturn null;\n    },\n\n    // If the matrix is square, returns the diagonal elements as a vector.\n    // Otherwise, returns null.\n    diagonal: function() {\n\tif (!this.isSquare) { return null; }\n\tvar els = [], n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    els.push(this.elements[i][i]);\n\t}\n\treturn $V(els);\n    },\n\n    // Make the matrix upper (right) triangular by Gaussian elimination.\n    // This method only adds multiples of rows to other rows. No rows are\n    // scaled up or switched, and the determinant is preserved.\n    toRightTriangular: function() {\n\tvar M = this.dup(), els;\n\tvar n = this.elements.length, i, j, np = this.elements[0].length, p;\n\tfor (i = 0; i < n; i++) {\n\t    if (M.elements[i][i] == 0) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t    if (M.elements[j][i] != 0) {\n\t\t\tels = [];\n\t\t\tfor (p = 0; p < np; p++) { els.push(M.elements[i][p] + M.elements[j][p]); }\n\t\t\tM.elements[i] = els;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (M.elements[i][i] != 0) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t    var multiplier = M.elements[j][i] / M.elements[i][i];\n\t\t    els = [];\n\t\t    for (p = 0; p < np; p++) {\n\t\t\t// Elements with column numbers up to an including the number\n\t\t\t// of the row that we're subtracting can safely be set straight to\n\t\t\t// zero, since that's the point of this routine and it avoids having\n\t\t\t// to loop over and correct rounding errors later\n\t\t\tels.push(p <= i ? 0 : M.elements[j][p] - M.elements[i][p] * multiplier);\n\t\t    }\n\t\t    M.elements[j] = els;\n\t\t}\n\t    }\n\t}\n\treturn M;\n    },\n\n    toUpperTriangular: function() { return this.toRightTriangular(); },\n\n    // Returns the determinant for square matrices\n    determinant: function() {\n\tif (!this.isSquare()) { return null; }\n\tif (this.cols == 1 && this.rows == 1) { return this.row(1); }\n\tif (this.cols == 0 && this.rows == 0) { return 1; }\n\tvar M = this.toRightTriangular();\n\tvar det = M.elements[0][0], n = M.elements.length;\n\tfor (var i = 1; i < n; i++) {\n\t    det = det * M.elements[i][i];\n\t}\n\treturn det;\n    },\n    det: function() { return this.determinant(); },\n\n    // Returns true iff the matrix is singular\n    isSingular: function() {\n\treturn (this.isSquare() && this.determinant() === 0);\n    },\n\n    // Returns the trace for square matrices\n    trace: function() {\n\tif (!this.isSquare()) { return null; }\n\tvar tr = this.elements[0][0], n = this.elements.length;\n\tfor (var i = 1; i < n; i++) {\n\t    tr += this.elements[i][i];\n\t}\n\treturn tr;\n    },\n\n    tr: function() { return this.trace(); },\n\n    // Returns the rank of the matrix\n    rank: function() {\n\tvar M = this.toRightTriangular(), rank = 0;\n\tvar i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) {\n\t    j = nj;\n\t    while (j--) {\n\t\tif (Math.abs(M.elements[i][j]) > Sylvester.precision) { rank++; break; }\n\t    }\n\t}\n\treturn rank;\n    },\n\n    rk: function() { return this.rank(); },\n\n    // Returns the result of attaching the given argument to the right-hand side of the matrix\n    augment: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\tvar T = this.dup(), cols = T.elements[0].length;\n\tvar i = T.elements.length, nj = M[0].length, j;\n\tif (i != M.length) { return null; }\n\twhile (i--) {\n\t    j = nj;\n\t    while (j--) {\n\t\tT.elements[i][cols + j] = M[i][j];\n\t    }\n\t}\n\treturn T;\n    },\n\n    // Returns the inverse (if one exists) using Gauss-Jordan\n    inverse: function() {\n\tif (!this.isSquare() || this.isSingular()) { return null; }\n\tvar n = this.elements.length, i = n, j;\n\tvar M = this.augment(Matrix.I(n)).toRightTriangular();\n\tvar np = M.elements[0].length, p, els, divisor;\n\tvar inverse_elements = [], new_element;\n\t// Matrix is non-singular so there will be no zeros on the diagonal\n\t// Cycle through rows from last to first\n\twhile (i--) {\n\t    // First, normalise diagonal elements to 1\n\t    els = [];\n\t    inverse_elements[i] = [];\n\t    divisor = M.elements[i][i];\n\t    for (p = 0; p < np; p++) {\n        new_element = M.elements[i][p] / divisor;\n\t\tels.push(new_element);\n\t\t// Shuffle off the current row of the right hand side into the results\n\t\t// array as it will not be modified by later runs through this loop\n\t\tif (p >= n) { inverse_elements[i].push(new_element); }\n\t    }\n\t    M.elements[i] = els;\n\t    // Then, subtract this row from those above it to\n\t    // give the identity matrix on the left hand side\n\t    j = i;\n\t    while (j--) {\n\t\tels = [];\n\t\tfor (p = 0; p < np; p++) {\n\t\t    els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);\n\t\t}\n\t\tM.elements[j] = els;\n\t    }\n\t}\n\treturn Matrix.create(inverse_elements);\n    },\n\n    inv: function() { return this.inverse(); },\n\n    // Returns the result of rounding all the elements\n    round: function() {\n\treturn this.map(function(x) { return Math.round(x); });\n    },\n\n    // Returns a copy of the matrix with elements set to the given value if they\n    // differ from it by less than Sylvester.precision\n    snapTo: function(x) {\n\treturn this.map(function(p) {\n\t    return (Math.abs(p - x) <= Sylvester.precision) ? x : p;\n\t});\n    },\n\n    // Returns a string representation of the matrix\n    inspect: function() {\n\tvar matrix_rows = [];\n\tvar n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    matrix_rows.push($V(this.elements[i]).inspect());\n\t}\n\treturn matrix_rows.join('\\n');\n    },\n\n    // Returns a array representation of the matrix\n    toArray: function() {\n    \tvar matrix_rows = [];\n    \tvar n = this.elements.length;\n    \tfor (var i = 0; i < n; i++) {\n        matrix_rows.push(this.elements[i]);\n    \t}\n      return matrix_rows;\n    },\n\n\n    // Set the matrix's elements from an array. If the argument passed\n    // is a vector, the resulting matrix will be a single column.\n    setElements: function(els) {\n\tvar i, j, elements = els.elements || els;\n\tif (typeof(elements[0][0]) != 'undefined') {\n\t    i = elements.length;\n\t    this.elements = [];\n\t    while (i--) {\n\t\tj = elements[i].length;\n\t\tthis.elements[i] = [];\n\t\twhile (j--) {\n\t\t    this.elements[i][j] = elements[i][j];\n\t\t}\n\t    }\n\t    return this;\n\t}\n\tvar n = elements.length;\n\tthis.elements = [];\n\tfor (i = 0; i < n; i++) {\n\t    this.elements.push([elements[i]]);\n\t}\n\treturn this;\n    },\n\n    maxColumnIndexes: function() {\n\tvar maxes = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var max = null;\n\t    var maxIndex = -1;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(max === null || this.e(i, j) > max) {\n\t\t    max = this.e(i, j);\n\t\t    maxIndex = j;\n\t\t}\n\t    }\n\n\t    maxes.push(maxIndex);\n\t}\n\n\treturn $V(maxes);\n    },\n\n    maxColumns: function() {\n\tvar maxes = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var max = null;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(max === null || this.e(i, j) > max) {\n\t\t    max = this.e(i, j);\n\t\t}\n\t    }\n\n\t    maxes.push(max);\n\t}\n\n\treturn $V(maxes);\n    },\n\n    minColumnIndexes: function() {\n\tvar mins = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var min = null;\n\t    var minIndex = -1;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(min === null || this.e(i, j) < min) {\n\t\t    min = this.e(i, j);\n\t\t    minIndex = j;\n\t\t}\n\t    }\n\n\t    mins.push(minIndex);\n\t}\n\n\treturn $V(mins);\n    },\n\n    minColumns: function() {\n\tvar mins = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var min = null;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(min === null || this.e(i, j) < min) {\n\t\t    min = this.e(i, j);\n\t\t}\n\t    }\n\n\t    mins.push(min);\n\t}\n\n\treturn $V(mins);\n    }\n};\n\n// Constructor function\nMatrix.create = function(elements) {\n    var M = new Matrix();\n    return M.setElements(elements);\n};\n\n// Identity matrix of size n\nMatrix.I = function(n) {\n    var els = [], i = n, j;\n    while (i--) {\n\tj = n;\n\tels[i] = [];\n\twhile (j--) {\n\t    els[i][j] = (i == j) ? 1 : 0;\n\t}\n    }\n    return Matrix.create(els);\n};\n\nMatrix.loadFile = function(file) {\n    var contents = fs.readFileSync(file, 'utf-8');\n    var matrix = [];\n\n    var rowArray = contents.split('\\n');\n    for (var i = 0; i < rowArray.length; i++) {\n\tvar d = rowArray[i].split(',');\n\tif (d.length > 1) {\n\t    matrix.push(d);\n\t}\n    }\n\n    var M = new Matrix();\n    return M.setElements(matrix);\n};\n\n// Diagonal matrix - all off-diagonal elements are zero\nMatrix.Diagonal = function(elements) {\n    var i = elements.length;\n    var M = Matrix.I(i);\n    while (i--) {\n\tM.elements[i][i] = elements[i];\n    }\n    return M;\n};\n\n// Rotation matrix about some axis. If no axis is\n// supplied, assume we're after a 2D transform\nMatrix.Rotation = function(theta, a) {\n    if (!a) {\n\treturn Matrix.create([\n\t    [Math.cos(theta), -Math.sin(theta)],\n\t    [Math.sin(theta), Math.cos(theta)]\n\t]);\n  }\n    var axis = a.dup();\n    if (axis.elements.length != 3) { return null; }\n    var mod = axis.modulus();\n    var x = axis.elements[0] / mod, y = axis.elements[1] / mod, z = axis.elements[2] / mod;\n    var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;\n    // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp\n    // That proof rotates the co-ordinate system so theta\n    // becomes -theta and sin becomes -sin here.\n    return Matrix.create([\n\t[t * x * x + c, t * x * y - s * z, t * x * z + s * y],\n\t[t * x * y + s * z, t * y * y + c, t * y * z - s * x],\n\t[t * x * z - s * y, t * y * z + s * x, t * z * z + c]\n    ]);\n};\n\n// Special case rotations\nMatrix.RotationX = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n\t[1, 0, 0],\n\t[0, c, -s],\n\t[0, s, c]\n    ]);\n};\n\nMatrix.RotationY = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n\t[c, 0, s],\n\t[0, 1, 0],\n\t[-s, 0, c]\n    ]);\n};\n\nMatrix.RotationZ = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n\t[c, -s, 0],\n\t[s, c, 0],\n\t[0, 0, 1]\n    ]);\n};\n\n// Random matrix of n rows, m columns\nMatrix.Random = function(n, m) {\n    if (arguments.length === 1) m = n;\n    return Matrix.Zero(n, m).map(\n\tfunction() { return Math.random(); }\n  );\n};\n\nMatrix.Fill = function(n, m, v) {\n    if (arguments.length === 2) {\n\tv = m;\n\tm = n;\n    }\n\n    var els = [], i = n, j;\n\n    while (i--) {\n\tj = m;\n\tels[i] = [];\n\n\twhile (j--) {\n\t    els[i][j] = v;\n\t}\n    }\n\n    return Matrix.create(els);\n};\n\n// Matrix filled with zeros\nMatrix.Zero = function(n, m) {\n    return Matrix.Fill(n, m, 0);\n};\n\n// Matrix filled with zeros\nMatrix.Zeros = function(n, m) {\n    return Matrix.Zero(n, m);\n};\n\n// Matrix filled with ones\nMatrix.One = function(n, m) {\n    return Matrix.Fill(n, m, 1);\n};\n\n// Matrix filled with ones\nMatrix.Ones = function(n, m) {\n    return Matrix.One(n, m);\n};\n\nmodule.exports = Matrix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9tYXRyaXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBYTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsNkVBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2l5YW1cXERvY3VtZW50c1xcQUktUG93ZXJlZC1DaGF0Ym90XFxub2RlX21vZHVsZXNcXHN5bHZlc3RlclxcbGliXFxub2RlLXN5bHZlc3RlclxcbWF0cml4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWwsIEphbWVzIENvZ2xhblxuLy8gTWF0cml4IGNsYXNzIC0gZGVwZW5kcyBvbiBWZWN0b3IuXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgU3lsdmVzdGVyID0gcmVxdWlyZSgnLi9zeWx2ZXN0ZXInKTtcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuXG4vLyBhdWdtZW50IGEgbWF0cml4IE0gd2l0aCBpZGVudGl0eSByb3dzL2NvbHNcbmZ1bmN0aW9uIGlkZW50U2l6ZShNLCBtLCBuLCBrKSB7XG4gICAgdmFyIGUgPSBNLmVsZW1lbnRzO1xuICAgIHZhciBpID0gayAtIDE7XG5cbiAgICB3aGlsZShpLS0pIHtcblx0dmFyIHJvdyA9IFtdO1xuXHRcblx0Zm9yKHZhciBqID0gMDsgaiA8IG47IGorKylcblx0ICAgIHJvdy5wdXNoKGogPT0gaSA/IDEgOiAwKTtcblx0XG4gICAgICAgIGUudW5zaGlmdChyb3cpO1xuICAgIH1cbiAgICBcbiAgICBmb3IodmFyIGkgPSBrIC0gMTsgaSA8IG07IGkrKykge1xuICAgICAgICB3aGlsZShlW2ldLmxlbmd0aCA8IG4pXG4gICAgICAgICAgICBlW2ldLnVuc2hpZnQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICRNKGUpO1xufVxuXG5mdW5jdGlvbiBwY2EoWCkge1xuICAgIHZhciBTaWdtYSA9IFgudHJhbnNwb3NlKCkueChYKS54KDEgLyBYLnJvd3MoKSk7XG4gICAgdmFyIHN2ZCA9IFNpZ21hLnN2ZCgpO1xuICAgIHJldHVybiB7VTogc3ZkLlUsIFM6IHN2ZC5TfTtcbn1cblxuZnVuY3Rpb24gTWF0cml4KCkge31cbk1hdHJpeC5wcm90b3R5cGUgPSB7XG4gICAgcGNhUHJvamVjdDogZnVuY3Rpb24oaywgVSkge1xuXHR2YXIgVSA9IFUgfHwgcGNhKHRoaXMpLlU7XG5cdHZhciBVcmVkdWNlPSBVLnNsaWNlKDEsIFUucm93cygpLCAxLCBrKTtcblx0cmV0dXJuIHtaOiB0aGlzLngoVXJlZHVjZSksIFU6IFV9O1xuICAgIH0sXG5cbiAgICBwY2FSZWNvdmVyOiBmdW5jdGlvbihVKSB7XG5cdHZhciBrID0gdGhpcy5jb2xzKCk7XG5cdHZhciBVcmVkdWNlID0gVS5zbGljZSgxLCBVLnJvd3MoKSwgMSwgayk7XG5cdHJldHVybiB0aGlzLngoVXJlZHVjZS50cmFuc3Bvc2UoKSk7XG4gICAgfSwgICAgXG5cbiAgICB0cml1OiBmdW5jdGlvbihrKSB7XG5cdGlmKCFrKVxuXHQgICAgayA9IDA7XG5cdFxuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCwgaSwgaikge1xuXHQgICAgcmV0dXJuIGogLSBpID49IGsgPyB4IDogMDtcblx0fSk7XG4gICAgfSxcblxuICAgIHN2ZDogZnVuY3Rpb24oKSB7XG5cdHZhciBBID0gdGhpcztcblx0dmFyIFUgPSBNYXRyaXguSShBLnJvd3MoKSk7XG5cdHZhciBTID0gQS50cmFuc3Bvc2UoKTtcblx0dmFyIFYgPSBNYXRyaXguSShBLmNvbHMoKSk7XG5cdHZhciBlcnIgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXHR2YXIgaSA9IDA7XG5cdHZhciBtYXhMb29wID0gMTAwO1xuXG5cdHdoaWxlKGVyciA+IDIuMjczN2UtMTMgJiYgaSA8IG1heExvb3ApIHtcblx0ICAgIHZhciBxciA9IFMudHJhbnNwb3NlKCkucXIoKTtcblx0ICAgIFMgPSBxci5SO1xuXHQgICAgVSA9IFUueChxci5RKTtcblx0ICAgIHFyID0gUy50cmFuc3Bvc2UoKS5xcigpO1xuXHQgICAgViA9IFYueChxci5RKTtcblx0ICAgIFMgPSBxci5SO1xuXG5cdCAgICB2YXIgZSA9IFMudHJpdSgxKS51bnJvbGwoKS5ub3JtKCk7XG5cdCAgICB2YXIgZiA9IFMuZGlhZ29uYWwoKS5ub3JtKCk7XG5cblx0ICAgIGlmKGYgPT0gMClcblx0XHRmID0gMTtcblxuXHQgICAgZXJyID0gZSAvIGY7XG5cblx0ICAgIGkrKztcblx0fVxuXG5cdHZhciBzcyA9IFMuZGlhZ29uYWwoKTtcblx0dmFyIHMgPSBbXTtcblxuXHRmb3IodmFyIGkgPSAxOyBpIDw9IHNzLmNvbHMoKTsgaSsrKSB7XG5cdCAgICB2YXIgc3NuID0gc3MuZShpKTtcblx0ICAgIHMucHVzaChNYXRoLmFicyhzc24pKTtcblxuXHQgICAgaWYoc3NuIDwgMCkge1xuXHRcdGZvcih2YXIgaiA9IDA7IGogPCBVLnJvd3MoKTsgaisrKSB7XG5cdFx0ICAgIFUuZWxlbWVudHNbal1baSAtIDFdID0gLShVLmVsZW1lbnRzW2pdW2kgLSAxXSk7XG5cdFx0fVxuXHQgICAgfVxuXHR9XG5cblx0cmV0dXJuIHtVOiBVLCBTOiAkVihzKS50b0RpYWdvbmFsTWF0cml4KCksIFY6IFZ9O1xuICAgIH0sXG5cbiAgICB1bnJvbGw6IGZ1bmN0aW9uKCkge1xuXHR2YXIgdiA9IFtdO1xuXHRcblx0Zm9yKHZhciBpID0gMTsgaSA8PSB0aGlzLmNvbHMoKTsgaSsrKSB7XG5cdCAgICBmb3IodmFyIGogPSAxOyBqIDw9IHRoaXMucm93cygpOyBqKyspIHtcblx0XHR2LnB1c2godGhpcy5lKGosIGkpKTtcblx0ICAgIH1cblx0fVxuXG5cdHJldHVybiAkVih2KTtcbiAgICB9LFxuXG4gICAgcXI6IGZ1bmN0aW9uKCkge1xuXHR2YXIgbSA9IHRoaXMucm93cygpO1xuXHR2YXIgbiA9IHRoaXMuY29scygpO1xuXHR2YXIgUSA9IE1hdHJpeC5JKG0pO1xuXHR2YXIgQSA9IHRoaXM7XG5cdFxuXHRmb3IodmFyIGsgPSAxOyBrIDwgTWF0aC5taW4obSwgbik7IGsrKykge1xuXHQgICAgdmFyIGFrID0gQS5zbGljZShrLCAwLCBrLCBrKS5jb2woMSk7XG5cdCAgICB2YXIgb25lWmVybyA9IFsxXTtcblx0ICAgIFxuXHQgICAgd2hpbGUob25lWmVyby5sZW5ndGggPD0gIG0gLSBrKVxuXHRcdG9uZVplcm8ucHVzaCgwKTtcblx0ICAgIFxuXHQgICAgb25lWmVybyA9ICRWKG9uZVplcm8pO1xuXHQgICAgdmFyIHZrID0gYWsuYWRkKG9uZVplcm8ueChhay5ub3JtKCkgKiBNYXRoLnNpZ24oYWsuZSgxKSkpKTtcblx0ICAgIHZhciBWayA9ICRNKHZrKTtcblx0ICAgIHZhciBIayA9IE1hdHJpeC5JKG0gLSBrICsgMSkuc3VidHJhY3QoVmsueCgyKS54KFZrLnRyYW5zcG9zZSgpKS5kaXYoVmsudHJhbnNwb3NlKCkueChWaykuZSgxLCAxKSkpO1xuXHQgICAgdmFyIFFrID0gaWRlbnRTaXplKEhrLCBtLCBuLCBrKTtcblx0ICAgIEEgPSBRay54KEEpO1xuXHQgICAgUSA9IFEueChRayk7XG5cdH1cblxuXHRyZXR1cm4ge1E6IFEsIFI6IEF9O1xuICAgIH0sXG5cblxuICAgIHNsaWNlOiBmdW5jdGlvbihzdGFydFJvdywgZW5kUm93LCBzdGFydENvbCwgZW5kQ29sKSB7XG5cdHZhciB4ID0gW107XG5cdFxuXHRpZihlbmRSb3cgPT0gMClcblx0ICAgIGVuZFJvdyA9IHRoaXMucm93cygpO1xuXHRcblx0aWYoZW5kQ29sID09IDApXG5cdCAgICBlbmRDb2wgPSB0aGlzLmNvbHMoKTtcblxuXHRmb3IoaSA9IHN0YXJ0Um93OyBpIDw9IGVuZFJvdzsgaSsrKSB7XG5cdCAgICB2YXIgcm93ID0gW107XG5cblx0ICAgIGZvcihqID0gc3RhcnRDb2w7IGogPD0gZW5kQ29sOyBqKyspIHtcblx0XHRyb3cucHVzaCh0aGlzLmUoaSwgaikpO1xuXHQgICAgfVxuXG5cdCAgICB4LnB1c2gocm93KTtcblx0fVxuXG5cdHJldHVybiAkTSh4KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBlbGVtZW50IChpLGopIG9mIHRoZSBtYXRyaXhcbiAgICBlOiBmdW5jdGlvbihpLGopIHtcblx0aWYgKGkgPCAxIHx8IGkgPiB0aGlzLmVsZW1lbnRzLmxlbmd0aCB8fCBqIDwgMSB8fCBqID4gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0cmV0dXJuIHRoaXMuZWxlbWVudHNbaSAtIDFdW2ogLSAxXTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyByb3cgayBvZiB0aGUgbWF0cml4IGFzIGEgdmVjdG9yXG4gICAgcm93OiBmdW5jdGlvbihpKSB7XG5cdGlmIChpID4gdGhpcy5lbGVtZW50cy5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0cmV0dXJuICRWKHRoaXMuZWxlbWVudHNbaSAtIDFdKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBjb2x1bW4gayBvZiB0aGUgbWF0cml4IGFzIGEgdmVjdG9yXG4gICAgY29sOiBmdW5jdGlvbihqKSB7XG5cdGlmIChqID4gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIGNvbCA9IFtdLCBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IGNvbC5wdXNoKHRoaXMuZWxlbWVudHNbaV1baiAtIDFdKTsgfVxuXHRyZXR1cm4gJFYoY29sKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MvY29sdW1ucyB0aGUgbWF0cml4IGhhc1xuICAgIGRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4ge3Jvd3M6IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBjb2xzOiB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aH07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBtYXRyaXhcbiAgICByb3dzOiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XG4gICAgY29sczogZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgbWF0cml4IGlzIGVxdWFsIHRvIHRoZSBhcmd1bWVudC4gWW91IGNhbiBzdXBwbHlcbiAgICAvLyBhIHZlY3RvciBhcyB0aGUgYXJndW1lbnQsIGluIHdoaWNoIGNhc2UgdGhlIHJlY2VpdmVyIG11c3QgYmUgYVxuICAgIC8vIG9uZS1jb2x1bW4gbWF0cml4IGVxdWFsIHRvIHRoZSB2ZWN0b3IuXG4gICAgZXFsOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0dmFyIE0gPSBtYXRyaXguZWxlbWVudHMgfHwgbWF0cml4O1xuXHRpZiAodHlwZW9mKE1bMF1bMF0pID09ICd1bmRlZmluZWQnKSB7IE0gPSBNYXRyaXguY3JlYXRlKE0pLmVsZW1lbnRzOyB9XG5cdGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPSBNLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1swXS5sZW5ndGggIT0gTVswXS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIG5qID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgsIGo7XG5cdHdoaWxlIChpLS0pIHsgaiA9IG5qO1xuXHRcdCAgICAgIHdoaWxlIChqLS0pIHtcblx0XHRcdCAgaWYgKE1hdGguYWJzKHRoaXMuZWxlbWVudHNbaV1bal0gLSBNW2ldW2pdKSA+IFN5bHZlc3Rlci5wcmVjaXNpb24pIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWF0cml4XG4gICAgZHVwOiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIE1hdHJpeC5jcmVhdGUodGhpcy5lbGVtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIE1hcHMgdGhlIG1hdHJpeCB0byBhbm90aGVyIG1hdHJpeCAob2YgdGhlIHNhbWUgZGltZW5zaW9ucykgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBmdW5jdGlvblxuICAgIG1hcDogZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgZWxzID0gW10sIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgbmogPSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCwgajtcblx0d2hpbGUgKGktLSkgeyBqID0gbmo7XG5cdFx0ICAgICAgZWxzW2ldID0gW107XG5cdFx0ICAgICAgd2hpbGUgKGotLSkge1xuXHRcdFx0ICBlbHNbaV1bal0gPSBmbih0aGlzLmVsZW1lbnRzW2ldW2pdLCBpICsgMSwgaiArIDEpO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRyZXR1cm4gTWF0cml4LmNyZWF0ZShlbHMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBhcmd1bWVudCBoYXMgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyB0aGUgbWF0cml4XG4gICAgaXNTYW1lU2l6ZUFzOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0dmFyIE0gPSBtYXRyaXguZWxlbWVudHMgfHwgbWF0cml4O1xuXHRpZiAodHlwZW9mKE1bMF1bMF0pID09ICd1bmRlZmluZWQnKSB7IE0gPSBNYXRyaXguY3JlYXRlKE0pLmVsZW1lbnRzOyB9XG5cdHJldHVybiAodGhpcy5lbGVtZW50cy5sZW5ndGggPT0gTS5sZW5ndGggJiZcblx0XHR0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCA9PSBNWzBdLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpbmcgdGhlIGFyZ3VtZW50IHRvIHRoZSBtYXRyaXhcbiAgICBhZGQ6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRpZih0eXBlb2YobWF0cml4KSA9PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgsIGksIGopIHsgcmV0dXJuIHggKyBtYXRyaXh9KTtcblx0fSBlbHNlIHtcblx0ICAgIHZhciBNID0gbWF0cml4LmVsZW1lbnRzIHx8IG1hdHJpeDtcblx0ICAgIGlmICh0eXBlb2YoTVswXVswXSkgPT0gJ3VuZGVmaW5lZCcpIHsgTSA9IE1hdHJpeC5jcmVhdGUoTSkuZWxlbWVudHM7IH1cblx0ICAgIGlmICghdGhpcy5pc1NhbWVTaXplQXMoTSkpIHsgcmV0dXJuIG51bGw7IH1cblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4LCBpLCBqKSB7IHJldHVybiB4ICsgTVtpIC0gMV1baiAtIDFdOyB9KTtcblx0fVxuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3RpbmcgdGhlIGFyZ3VtZW50IGZyb20gdGhlIG1hdHJpeFxuICAgIHN1YnRyYWN0OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0aWYodHlwZW9mKG1hdHJpeCkgPT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4LCBpLCBqKSB7IHJldHVybiB4IC0gbWF0cml4fSk7XG5cdH0gZWxzZSB7XG5cdCAgICB2YXIgTSA9IG1hdHJpeC5lbGVtZW50cyB8fCBtYXRyaXg7XG5cdCAgICBpZiAodHlwZW9mKE1bMF1bMF0pID09ICd1bmRlZmluZWQnKSB7IE0gPSBNYXRyaXguY3JlYXRlKE0pLmVsZW1lbnRzOyB9XG5cdCAgICBpZiAoIXRoaXMuaXNTYW1lU2l6ZUFzKE0pKSB7IHJldHVybiBudWxsOyB9XG5cdCAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCwgaSwgaikgeyByZXR1cm4geCAtIE1baSAtIDFdW2ogLSAxXTsgfSk7XG5cdH1cbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgbWF0cml4IGNhbiBtdWx0aXBseSB0aGUgYXJndW1lbnQgZnJvbSB0aGUgbGVmdFxuICAgIGNhbk11bHRpcGx5RnJvbUxlZnQ6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHR2YXIgTSA9IG1hdHJpeC5lbGVtZW50cyB8fCBtYXRyaXg7XG5cdGlmICh0eXBlb2YoTVswXVswXSkgPT0gJ3VuZGVmaW5lZCcpIHsgTSA9IE1hdHJpeC5jcmVhdGUoTSkuZWxlbWVudHM7IH1cblx0Ly8gdGhpcy5jb2x1bW5zIHNob3VsZCBlcXVhbCBtYXRyaXgucm93c1xuXHRyZXR1cm4gKHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoID09IE0ubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgbXVsdGlwbGljYXRpb24tc3R5bGUgb3BlcmF0aW9uIHRoZSBtYXRyaXggZnJvbSB0aGUgcmlnaHQgYnkgdGhlIGFyZ3VtZW50LlxuICAgIC8vIElmIHRoZSBhcmd1bWVudCBpcyBhIHNjYWxhciB0aGVuIGp1c3Qgb3BlcmF0ZSBvbiBhbGwgdGhlIGVsZW1lbnRzLiBJZiB0aGUgYXJndW1lbnQgaXNcbiAgICAvLyBhIHZlY3RvciwgYSB2ZWN0b3IgaXMgcmV0dXJuZWQsIHdoaWNoIHNhdmVzIHlvdSBoYXZpbmcgdG8gcmVtZW1iZXIgY2FsbGluZ1xuICAgIC8vIGNvbCgxKSBvbiB0aGUgcmVzdWx0LlxuICAgIG11bE9wOiBmdW5jdGlvbihtYXRyaXgsIG9wKSB7XG5cdGlmICghbWF0cml4LmVsZW1lbnRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gb3AoeCwgbWF0cml4KTsgfSk7XG5cdH1cblxuXHR2YXIgcmV0dXJuVmVjdG9yID0gbWF0cml4Lm1vZHVsdXMgPyB0cnVlIDogZmFsc2U7XG5cdHZhciBNID0gbWF0cml4LmVsZW1lbnRzIHx8IG1hdHJpeDtcblx0aWYgKHR5cGVvZihNWzBdWzBdKSA9PSAndW5kZWZpbmVkJykgXG5cdCAgICBNID0gTWF0cml4LmNyZWF0ZShNKS5lbGVtZW50cztcblx0aWYgKCF0aGlzLmNhbk11bHRpcGx5RnJvbUxlZnQoTSkpIFxuXHQgICAgcmV0dXJuIG51bGw7IFxuXHR2YXIgZSA9IHRoaXMuZWxlbWVudHMsIHJvd1RoaXMsIHJvd0VsZW0sIGVsZW1lbnRzID0gW10sXG4gICAgICAgIHN1bSwgbSA9IGUubGVuZ3RoLCBuID0gTVswXS5sZW5ndGgsIG8gPSBlWzBdLmxlbmd0aCwgaSA9IG0sIGosIGs7XG5cblx0d2hpbGUgKGktLSkge1xuICAgICAgICAgICAgcm93RWxlbSA9IFtdO1xuICAgICAgICAgICAgcm93VGhpcyA9IGVbaV07XG4gICAgICAgICAgICBqID0gbjtcblxuICAgICAgICAgICAgd2hpbGUgKGotLSkge1xuXHRcdHN1bSA9IDA7XG5cdFx0ayA9IG87XG5cblx0XHR3aGlsZSAoay0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBvcChyb3dUaGlzW2tdLCBNW2tdW2pdKTtcblx0XHR9XG5cblx0XHRyb3dFbGVtW2pdID0gc3VtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50c1tpXSA9IHJvd0VsZW07XG5cdH1cblxuXHR2YXIgTSA9IE1hdHJpeC5jcmVhdGUoZWxlbWVudHMpO1xuXHRyZXR1cm4gcmV0dXJuVmVjdG9yID8gTS5jb2woMSkgOiBNO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aWRpbmcgdGhlIG1hdHJpeCBmcm9tIHRoZSByaWdodCBieSB0aGUgYXJndW1lbnQuXG4gICAgLy8gSWYgdGhlIGFyZ3VtZW50IGlzIGEgc2NhbGFyIHRoZW4ganVzdCBkaXZpZGUgYWxsIHRoZSBlbGVtZW50cy4gSWYgdGhlIGFyZ3VtZW50IGlzXG4gICAgLy8gYSB2ZWN0b3IsIGEgdmVjdG9yIGlzIHJldHVybmVkLCB3aGljaCBzYXZlcyB5b3UgaGF2aW5nIHRvIHJlbWVtYmVyIGNhbGxpbmdcbiAgICAvLyBjb2woMSkgb24gdGhlIHJlc3VsdC5cbiAgICBkaXY6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRyZXR1cm4gdGhpcy5tdWxPcChtYXRyaXgsIGZ1bmN0aW9uKHgsIHkpIHsgcmV0dXJuIHggLyB5fSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBseWluZyB0aGUgbWF0cml4IGZyb20gdGhlIHJpZ2h0IGJ5IHRoZSBhcmd1bWVudC5cbiAgICAvLyBJZiB0aGUgYXJndW1lbnQgaXMgYSBzY2FsYXIgdGhlbiBqdXN0IG11bHRpcGx5IGFsbCB0aGUgZWxlbWVudHMuIElmIHRoZSBhcmd1bWVudCBpc1xuICAgIC8vIGEgdmVjdG9yLCBhIHZlY3RvciBpcyByZXR1cm5lZCwgd2hpY2ggc2F2ZXMgeW91IGhhdmluZyB0byByZW1lbWJlciBjYWxsaW5nXG4gICAgLy8gY29sKDEpIG9uIHRoZSByZXN1bHQuXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRyZXR1cm4gdGhpcy5tdWxPcChtYXRyaXgsIGZ1bmN0aW9uKHgsIHkpIHsgcmV0dXJuIHggKiB5fSk7XG4gICAgfSxcblxuICAgIHg6IGZ1bmN0aW9uKG1hdHJpeCkgeyByZXR1cm4gdGhpcy5tdWx0aXBseShtYXRyaXgpOyB9LFxuXG4gICAgZWxlbWVudE11bHRpcGx5OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihrLCBpLCBqKSB7XG4gICAgICAgICAgICByZXR1cm4gdi5lKGksIGopICogaztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHN1bTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgc3VtICs9IHg7fSk7XG5cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIFZlY3RvciBvZiBlYWNoIGNvbHVtIGF2ZXJhZ2VkLlxuICAgIG1lYW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpbSA9IHRoaXMuZGltZW5zaW9ucygpO1xuICAgICAgdmFyIHIgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGRpbS5jb2xzOyBpKyspIHtcbiAgICAgICAgci5wdXNoKHRoaXMuY29sKGkpLnN1bSgpIC8gZGltLnJvd3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICRWKHIpO1xuICAgIH0sXG5cbiAgICBjb2x1bW46IGZ1bmN0aW9uKG4pIHtcblx0cmV0dXJuIHRoaXMuY29sKG4pO1xuICAgIH0sXG5cbiAgICBsb2c6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCk7IH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgc3VibWF0cml4IHRha2VuIGZyb20gdGhlIG1hdHJpeFxuICAgIC8vIEFyZ3VtZW50IG9yZGVyIGlzOiBzdGFydCByb3csIHN0YXJ0IGNvbCwgbnJvd3MsIG5jb2xzXG4gICAgLy8gRWxlbWVudCBzZWxlY3Rpb24gd3JhcHMgaWYgdGhlIHJlcXVpcmVkIGluZGV4IGlzIG91dHNpZGUgdGhlIG1hdHJpeCdzIGJvdW5kcywgc28geW91IGNvdWxkXG4gICAgLy8gdXNlIHRoaXMgdG8gcGVyZm9ybSByb3cvY29sdW1uIGN5Y2xpbmcgb3IgY29weS1hdWdtZW50aW5nLlxuICAgIG1pbm9yOiBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG5cdHZhciBlbGVtZW50cyA9IFtdLCBuaSA9IGMsIGksIG5qLCBqO1xuXHR2YXIgcm93cyA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBjb2xzID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGg7XG5cdHdoaWxlIChuaS0tKSB7XG5cdCAgICBpID0gYyAtIG5pIC0gMTtcblx0ICAgIGVsZW1lbnRzW2ldID0gW107XG5cdCAgICBuaiA9IGQ7XG5cdCAgICB3aGlsZSAobmotLSkge1xuXHRcdGogPSBkIC0gbmogLSAxO1xuXHRcdGVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1soYSArIGkgLSAxKSAlIHJvd3NdWyhiICsgaiAtIDEpICUgY29sc107XG5cdCAgICB9XG5cdH1cblx0cmV0dXJuIE1hdHJpeC5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSB0cmFuc3Bvc2Ugb2YgdGhlIG1hdHJpeFxuICAgIHRyYW5zcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJvd3MgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgaSwgY29scyA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoLCBqO1xuXHR2YXIgZWxlbWVudHMgPSBbXSwgaSA9IGNvbHM7XG5cdHdoaWxlIChpLS0pIHtcblx0ICAgIGogPSByb3dzO1xuXHQgICAgZWxlbWVudHNbaV0gPSBbXTtcblx0ICAgIHdoaWxlIChqLS0pIHtcblx0XHRlbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbal1baV07XG5cdCAgICB9XG5cdH1cblx0cmV0dXJuIE1hdHJpeC5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBtYXRyaXggaXMgc3F1YXJlXG4gICAgaXNTcXVhcmU6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gKHRoaXMuZWxlbWVudHMubGVuZ3RoID09IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgKGFic29sdXRlKSBsYXJnZXN0IGVsZW1lbnQgb2YgdGhlIG1hdHJpeFxuICAgIG1heDogZnVuY3Rpb24oKSB7XG5cdHZhciBtID0gMCwgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBuaiA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoLCBqO1xuXHR3aGlsZSAoaS0tKSB7XG5cdCAgICBqID0gbmo7XG5cdCAgICB3aGlsZSAoai0tKSB7XG5cdFx0aWYgKE1hdGguYWJzKHRoaXMuZWxlbWVudHNbaV1bal0pID4gTWF0aC5hYnMobSkpIHsgbSA9IHRoaXMuZWxlbWVudHNbaV1bal07IH1cblx0ICAgIH1cblx0fVxuXHRyZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgaW5kZWNlcyBvZiB0aGUgZmlyc3QgbWF0Y2ggZm91bmQgYnkgcmVhZGluZyByb3ctYnktcm93IGZyb20gbGVmdCB0byByaWdodFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKHgpIHtcblx0dmFyIGluZGV4ID0gbnVsbCwgbmkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgaSwgbmogPSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCwgajtcblx0Zm9yIChpID0gMDsgaSA8IG5pOyBpKyspIHtcblx0ICAgIGZvciAoaiA9IDA7IGogPCBuajsgaisrKSB7XG5cdFx0aWYgKHRoaXMuZWxlbWVudHNbaV1bal0gPT0geCkgeyByZXR1cm4ge2k6IGkgKyAxLCBqOiBqICsgMX07IH1cblx0ICAgIH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gSWYgdGhlIG1hdHJpeCBpcyBzcXVhcmUsIHJldHVybnMgdGhlIGRpYWdvbmFsIGVsZW1lbnRzIGFzIGEgdmVjdG9yLlxuICAgIC8vIE90aGVyd2lzZSwgcmV0dXJucyBudWxsLlxuICAgIGRpYWdvbmFsOiBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLmlzU3F1YXJlKSB7IHJldHVybiBudWxsOyB9XG5cdHZhciBlbHMgPSBbXSwgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgZWxzLnB1c2godGhpcy5lbGVtZW50c1tpXVtpXSk7XG5cdH1cblx0cmV0dXJuICRWKGVscyk7XG4gICAgfSxcblxuICAgIC8vIE1ha2UgdGhlIG1hdHJpeCB1cHBlciAocmlnaHQpIHRyaWFuZ3VsYXIgYnkgR2F1c3NpYW4gZWxpbWluYXRpb24uXG4gICAgLy8gVGhpcyBtZXRob2Qgb25seSBhZGRzIG11bHRpcGxlcyBvZiByb3dzIHRvIG90aGVyIHJvd3MuIE5vIHJvd3MgYXJlXG4gICAgLy8gc2NhbGVkIHVwIG9yIHN3aXRjaGVkLCBhbmQgdGhlIGRldGVybWluYW50IGlzIHByZXNlcnZlZC5cbiAgICB0b1JpZ2h0VHJpYW5ndWxhcjogZnVuY3Rpb24oKSB7XG5cdHZhciBNID0gdGhpcy5kdXAoKSwgZWxzO1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBpLCBqLCBucCA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoLCBwO1xuXHRmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBpZiAoTS5lbGVtZW50c1tpXVtpXSA9PSAwKSB7XG5cdFx0Zm9yIChqID0gaSArIDE7IGogPCBuOyBqKyspIHtcblx0XHQgICAgaWYgKE0uZWxlbWVudHNbal1baV0gIT0gMCkge1xuXHRcdFx0ZWxzID0gW107XG5cdFx0XHRmb3IgKHAgPSAwOyBwIDwgbnA7IHArKykgeyBlbHMucHVzaChNLmVsZW1lbnRzW2ldW3BdICsgTS5lbGVtZW50c1tqXVtwXSk7IH1cblx0XHRcdE0uZWxlbWVudHNbaV0gPSBlbHM7XG5cdFx0XHRicmVhaztcblx0XHQgICAgfVxuXHRcdH1cblx0ICAgIH1cblx0ICAgIGlmIChNLmVsZW1lbnRzW2ldW2ldICE9IDApIHtcblx0XHRmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuXHRcdCAgICB2YXIgbXVsdGlwbGllciA9IE0uZWxlbWVudHNbal1baV0gLyBNLmVsZW1lbnRzW2ldW2ldO1xuXHRcdCAgICBlbHMgPSBbXTtcblx0XHQgICAgZm9yIChwID0gMDsgcCA8IG5wOyBwKyspIHtcblx0XHRcdC8vIEVsZW1lbnRzIHdpdGggY29sdW1uIG51bWJlcnMgdXAgdG8gYW4gaW5jbHVkaW5nIHRoZSBudW1iZXJcblx0XHRcdC8vIG9mIHRoZSByb3cgdGhhdCB3ZSdyZSBzdWJ0cmFjdGluZyBjYW4gc2FmZWx5IGJlIHNldCBzdHJhaWdodCB0b1xuXHRcdFx0Ly8gemVybywgc2luY2UgdGhhdCdzIHRoZSBwb2ludCBvZiB0aGlzIHJvdXRpbmUgYW5kIGl0IGF2b2lkcyBoYXZpbmdcblx0XHRcdC8vIHRvIGxvb3Agb3ZlciBhbmQgY29ycmVjdCByb3VuZGluZyBlcnJvcnMgbGF0ZXJcblx0XHRcdGVscy5wdXNoKHAgPD0gaSA/IDAgOiBNLmVsZW1lbnRzW2pdW3BdIC0gTS5lbGVtZW50c1tpXVtwXSAqIG11bHRpcGxpZXIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIE0uZWxlbWVudHNbal0gPSBlbHM7XG5cdFx0fVxuXHQgICAgfVxuXHR9XG5cdHJldHVybiBNO1xuICAgIH0sXG5cbiAgICB0b1VwcGVyVHJpYW5ndWxhcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRvUmlnaHRUcmlhbmd1bGFyKCk7IH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBkZXRlcm1pbmFudCBmb3Igc3F1YXJlIG1hdHJpY2VzXG4gICAgZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuaXNTcXVhcmUoKSkgeyByZXR1cm4gbnVsbDsgfVxuXHRpZiAodGhpcy5jb2xzID09IDEgJiYgdGhpcy5yb3dzID09IDEpIHsgcmV0dXJuIHRoaXMucm93KDEpOyB9XG5cdGlmICh0aGlzLmNvbHMgPT0gMCAmJiB0aGlzLnJvd3MgPT0gMCkgeyByZXR1cm4gMTsgfVxuXHR2YXIgTSA9IHRoaXMudG9SaWdodFRyaWFuZ3VsYXIoKTtcblx0dmFyIGRldCA9IE0uZWxlbWVudHNbMF1bMF0sIG4gPSBNLmVsZW1lbnRzLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0ICAgIGRldCA9IGRldCAqIE0uZWxlbWVudHNbaV1baV07XG5cdH1cblx0cmV0dXJuIGRldDtcbiAgICB9LFxuICAgIGRldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRldGVybWluYW50KCk7IH0sXG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBtYXRyaXggaXMgc2luZ3VsYXJcbiAgICBpc1Npbmd1bGFyOiBmdW5jdGlvbigpIHtcblx0cmV0dXJuICh0aGlzLmlzU3F1YXJlKCkgJiYgdGhpcy5kZXRlcm1pbmFudCgpID09PSAwKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgdHJhY2UgZm9yIHNxdWFyZSBtYXRyaWNlc1xuICAgIHRyYWNlOiBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLmlzU3F1YXJlKCkpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIHRyID0gdGhpcy5lbGVtZW50c1swXVswXSwgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHQgICAgdHIgKz0gdGhpcy5lbGVtZW50c1tpXVtpXTtcblx0fVxuXHRyZXR1cm4gdHI7XG4gICAgfSxcblxuICAgIHRyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhY2UoKTsgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJhbmsgb2YgdGhlIG1hdHJpeFxuICAgIHJhbms6IGZ1bmN0aW9uKCkge1xuXHR2YXIgTSA9IHRoaXMudG9SaWdodFRyaWFuZ3VsYXIoKSwgcmFuayA9IDA7XG5cdHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIG5qID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgsIGo7XG5cdHdoaWxlIChpLS0pIHtcblx0ICAgIGogPSBuajtcblx0ICAgIHdoaWxlIChqLS0pIHtcblx0XHRpZiAoTWF0aC5hYnMoTS5lbGVtZW50c1tpXVtqXSkgPiBTeWx2ZXN0ZXIucHJlY2lzaW9uKSB7IHJhbmsrKzsgYnJlYWs7IH1cblx0ICAgIH1cblx0fVxuXHRyZXR1cm4gcmFuaztcbiAgICB9LFxuXG4gICAgcms6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5yYW5rKCk7IH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYXR0YWNoaW5nIHRoZSBnaXZlbiBhcmd1bWVudCB0byB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIHRoZSBtYXRyaXhcbiAgICBhdWdtZW50OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0dmFyIE0gPSBtYXRyaXguZWxlbWVudHMgfHwgbWF0cml4O1xuXHRpZiAodHlwZW9mKE1bMF1bMF0pID09ICd1bmRlZmluZWQnKSB7IE0gPSBNYXRyaXguY3JlYXRlKE0pLmVsZW1lbnRzOyB9XG5cdHZhciBUID0gdGhpcy5kdXAoKSwgY29scyA9IFQuZWxlbWVudHNbMF0ubGVuZ3RoO1xuXHR2YXIgaSA9IFQuZWxlbWVudHMubGVuZ3RoLCBuaiA9IE1bMF0ubGVuZ3RoLCBqO1xuXHRpZiAoaSAhPSBNLmxlbmd0aCkgeyByZXR1cm4gbnVsbDsgfVxuXHR3aGlsZSAoaS0tKSB7XG5cdCAgICBqID0gbmo7XG5cdCAgICB3aGlsZSAoai0tKSB7XG5cdFx0VC5lbGVtZW50c1tpXVtjb2xzICsgal0gPSBNW2ldW2pdO1xuXHQgICAgfVxuXHR9XG5cdHJldHVybiBUO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBpbnZlcnNlIChpZiBvbmUgZXhpc3RzKSB1c2luZyBHYXVzcy1Kb3JkYW5cbiAgICBpbnZlcnNlOiBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLmlzU3F1YXJlKCkgfHwgdGhpcy5pc1Npbmd1bGFyKCkpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgaSA9IG4sIGo7XG5cdHZhciBNID0gdGhpcy5hdWdtZW50KE1hdHJpeC5JKG4pKS50b1JpZ2h0VHJpYW5ndWxhcigpO1xuXHR2YXIgbnAgPSBNLmVsZW1lbnRzWzBdLmxlbmd0aCwgcCwgZWxzLCBkaXZpc29yO1xuXHR2YXIgaW52ZXJzZV9lbGVtZW50cyA9IFtdLCBuZXdfZWxlbWVudDtcblx0Ly8gTWF0cml4IGlzIG5vbi1zaW5ndWxhciBzbyB0aGVyZSB3aWxsIGJlIG5vIHplcm9zIG9uIHRoZSBkaWFnb25hbFxuXHQvLyBDeWNsZSB0aHJvdWdoIHJvd3MgZnJvbSBsYXN0IHRvIGZpcnN0XG5cdHdoaWxlIChpLS0pIHtcblx0ICAgIC8vIEZpcnN0LCBub3JtYWxpc2UgZGlhZ29uYWwgZWxlbWVudHMgdG8gMVxuXHQgICAgZWxzID0gW107XG5cdCAgICBpbnZlcnNlX2VsZW1lbnRzW2ldID0gW107XG5cdCAgICBkaXZpc29yID0gTS5lbGVtZW50c1tpXVtpXTtcblx0ICAgIGZvciAocCA9IDA7IHAgPCBucDsgcCsrKSB7XG4gICAgICAgIG5ld19lbGVtZW50ID0gTS5lbGVtZW50c1tpXVtwXSAvIGRpdmlzb3I7XG5cdFx0ZWxzLnB1c2gobmV3X2VsZW1lbnQpO1xuXHRcdC8vIFNodWZmbGUgb2ZmIHRoZSBjdXJyZW50IHJvdyBvZiB0aGUgcmlnaHQgaGFuZCBzaWRlIGludG8gdGhlIHJlc3VsdHNcblx0XHQvLyBhcnJheSBhcyBpdCB3aWxsIG5vdCBiZSBtb2RpZmllZCBieSBsYXRlciBydW5zIHRocm91Z2ggdGhpcyBsb29wXG5cdFx0aWYgKHAgPj0gbikgeyBpbnZlcnNlX2VsZW1lbnRzW2ldLnB1c2gobmV3X2VsZW1lbnQpOyB9XG5cdCAgICB9XG5cdCAgICBNLmVsZW1lbnRzW2ldID0gZWxzO1xuXHQgICAgLy8gVGhlbiwgc3VidHJhY3QgdGhpcyByb3cgZnJvbSB0aG9zZSBhYm92ZSBpdCB0b1xuXHQgICAgLy8gZ2l2ZSB0aGUgaWRlbnRpdHkgbWF0cml4IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZVxuXHQgICAgaiA9IGk7XG5cdCAgICB3aGlsZSAoai0tKSB7XG5cdFx0ZWxzID0gW107XG5cdFx0Zm9yIChwID0gMDsgcCA8IG5wOyBwKyspIHtcblx0XHQgICAgZWxzLnB1c2goTS5lbGVtZW50c1tqXVtwXSAtIE0uZWxlbWVudHNbaV1bcF0gKiBNLmVsZW1lbnRzW2pdW2ldKTtcblx0XHR9XG5cdFx0TS5lbGVtZW50c1tqXSA9IGVscztcblx0ICAgIH1cblx0fVxuXHRyZXR1cm4gTWF0cml4LmNyZWF0ZShpbnZlcnNlX2VsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgaW52OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaW52ZXJzZSgpOyB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHJvdW5kaW5nIGFsbCB0aGUgZWxlbWVudHNcbiAgICByb3VuZDogZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hdHJpeCB3aXRoIGVsZW1lbnRzIHNldCB0byB0aGUgZ2l2ZW4gdmFsdWUgaWYgdGhleVxuICAgIC8vIGRpZmZlciBmcm9tIGl0IGJ5IGxlc3MgdGhhbiBTeWx2ZXN0ZXIucHJlY2lzaW9uXG4gICAgc25hcFRvOiBmdW5jdGlvbih4KSB7XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwKSB7XG5cdCAgICByZXR1cm4gKE1hdGguYWJzKHAgLSB4KSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKSA/IHggOiBwO1xuXHR9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gICAgaW5zcGVjdDogZnVuY3Rpb24oKSB7XG5cdHZhciBtYXRyaXhfcm93cyA9IFtdO1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgbWF0cml4X3Jvd3MucHVzaCgkVih0aGlzLmVsZW1lbnRzW2ldKS5pbnNwZWN0KCkpO1xuXHR9XG5cdHJldHVybiBtYXRyaXhfcm93cy5qb2luKCdcXG4nKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICBcdHZhciBtYXRyaXhfcm93cyA9IFtdO1xuICAgIFx0dmFyIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICBcdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIG1hdHJpeF9yb3dzLnB1c2godGhpcy5lbGVtZW50c1tpXSk7XG4gICAgXHR9XG4gICAgICByZXR1cm4gbWF0cml4X3Jvd3M7XG4gICAgfSxcblxuXG4gICAgLy8gU2V0IHRoZSBtYXRyaXgncyBlbGVtZW50cyBmcm9tIGFuIGFycmF5LiBJZiB0aGUgYXJndW1lbnQgcGFzc2VkXG4gICAgLy8gaXMgYSB2ZWN0b3IsIHRoZSByZXN1bHRpbmcgbWF0cml4IHdpbGwgYmUgYSBzaW5nbGUgY29sdW1uLlxuICAgIHNldEVsZW1lbnRzOiBmdW5jdGlvbihlbHMpIHtcblx0dmFyIGksIGosIGVsZW1lbnRzID0gZWxzLmVsZW1lbnRzIHx8IGVscztcblx0aWYgKHR5cGVvZihlbGVtZW50c1swXVswXSkgIT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIGkgPSBlbGVtZW50cy5sZW5ndGg7XG5cdCAgICB0aGlzLmVsZW1lbnRzID0gW107XG5cdCAgICB3aGlsZSAoaS0tKSB7XG5cdFx0aiA9IGVsZW1lbnRzW2ldLmxlbmd0aDtcblx0XHR0aGlzLmVsZW1lbnRzW2ldID0gW107XG5cdFx0d2hpbGUgKGotLSkge1xuXHRcdCAgICB0aGlzLmVsZW1lbnRzW2ldW2pdID0gZWxlbWVudHNbaV1bal07XG5cdFx0fVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH1cblx0dmFyIG4gPSBlbGVtZW50cy5sZW5ndGg7XG5cdHRoaXMuZWxlbWVudHMgPSBbXTtcblx0Zm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgdGhpcy5lbGVtZW50cy5wdXNoKFtlbGVtZW50c1tpXV0pO1xuXHR9XG5cdHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtYXhDb2x1bW5JbmRleGVzOiBmdW5jdGlvbigpIHtcblx0dmFyIG1heGVzID0gW107XG5cblx0Zm9yKHZhciBpID0gMTsgaSA8PSB0aGlzLnJvd3MoKTsgaSsrKSB7XG5cdCAgICB2YXIgbWF4ID0gbnVsbDtcblx0ICAgIHZhciBtYXhJbmRleCA9IC0xO1xuXG5cdCAgICBmb3IodmFyIGogPSAxOyBqIDw9IHRoaXMuY29scygpOyBqKyspIHtcblx0XHRpZihtYXggPT09IG51bGwgfHwgdGhpcy5lKGksIGopID4gbWF4KSB7XG5cdFx0ICAgIG1heCA9IHRoaXMuZShpLCBqKTtcblx0XHQgICAgbWF4SW5kZXggPSBqO1xuXHRcdH1cblx0ICAgIH1cblxuXHQgICAgbWF4ZXMucHVzaChtYXhJbmRleCk7XG5cdH1cblxuXHRyZXR1cm4gJFYobWF4ZXMpO1xuICAgIH0sXG5cbiAgICBtYXhDb2x1bW5zOiBmdW5jdGlvbigpIHtcblx0dmFyIG1heGVzID0gW107XG5cblx0Zm9yKHZhciBpID0gMTsgaSA8PSB0aGlzLnJvd3MoKTsgaSsrKSB7XG5cdCAgICB2YXIgbWF4ID0gbnVsbDtcblxuXHQgICAgZm9yKHZhciBqID0gMTsgaiA8PSB0aGlzLmNvbHMoKTsgaisrKSB7XG5cdFx0aWYobWF4ID09PSBudWxsIHx8IHRoaXMuZShpLCBqKSA+IG1heCkge1xuXHRcdCAgICBtYXggPSB0aGlzLmUoaSwgaik7XG5cdFx0fVxuXHQgICAgfVxuXG5cdCAgICBtYXhlcy5wdXNoKG1heCk7XG5cdH1cblxuXHRyZXR1cm4gJFYobWF4ZXMpO1xuICAgIH0sXG5cbiAgICBtaW5Db2x1bW5JbmRleGVzOiBmdW5jdGlvbigpIHtcblx0dmFyIG1pbnMgPSBbXTtcblxuXHRmb3IodmFyIGkgPSAxOyBpIDw9IHRoaXMucm93cygpOyBpKyspIHtcblx0ICAgIHZhciBtaW4gPSBudWxsO1xuXHQgICAgdmFyIG1pbkluZGV4ID0gLTE7XG5cblx0ICAgIGZvcih2YXIgaiA9IDE7IGogPD0gdGhpcy5jb2xzKCk7IGorKykge1xuXHRcdGlmKG1pbiA9PT0gbnVsbCB8fCB0aGlzLmUoaSwgaikgPCBtaW4pIHtcblx0XHQgICAgbWluID0gdGhpcy5lKGksIGopO1xuXHRcdCAgICBtaW5JbmRleCA9IGo7XG5cdFx0fVxuXHQgICAgfVxuXG5cdCAgICBtaW5zLnB1c2gobWluSW5kZXgpO1xuXHR9XG5cblx0cmV0dXJuICRWKG1pbnMpO1xuICAgIH0sXG5cbiAgICBtaW5Db2x1bW5zOiBmdW5jdGlvbigpIHtcblx0dmFyIG1pbnMgPSBbXTtcblxuXHRmb3IodmFyIGkgPSAxOyBpIDw9IHRoaXMucm93cygpOyBpKyspIHtcblx0ICAgIHZhciBtaW4gPSBudWxsO1xuXG5cdCAgICBmb3IodmFyIGogPSAxOyBqIDw9IHRoaXMuY29scygpOyBqKyspIHtcblx0XHRpZihtaW4gPT09IG51bGwgfHwgdGhpcy5lKGksIGopIDwgbWluKSB7XG5cdFx0ICAgIG1pbiA9IHRoaXMuZShpLCBqKTtcblx0XHR9XG5cdCAgICB9XG5cblx0ICAgIG1pbnMucHVzaChtaW4pO1xuXHR9XG5cblx0cmV0dXJuICRWKG1pbnMpO1xuICAgIH1cbn07XG5cbi8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG5NYXRyaXguY3JlYXRlID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcbiAgICByZXR1cm4gTS5zZXRFbGVtZW50cyhlbGVtZW50cyk7XG59O1xuXG4vLyBJZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXG5NYXRyaXguSSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgZWxzID0gW10sIGkgPSBuLCBqO1xuICAgIHdoaWxlIChpLS0pIHtcblx0aiA9IG47XG5cdGVsc1tpXSA9IFtdO1xuXHR3aGlsZSAoai0tKSB7XG5cdCAgICBlbHNbaV1bal0gPSAoaSA9PSBqKSA/IDEgOiAwO1xuXHR9XG4gICAgfVxuICAgIHJldHVybiBNYXRyaXguY3JlYXRlKGVscyk7XG59O1xuXG5NYXRyaXgubG9hZEZpbGUgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgdmFyIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKGZpbGUsICd1dGYtOCcpO1xuICAgIHZhciBtYXRyaXggPSBbXTtcblxuICAgIHZhciByb3dBcnJheSA9IGNvbnRlbnRzLnNwbGl0KCdcXG4nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0FycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdHZhciBkID0gcm93QXJyYXlbaV0uc3BsaXQoJywnKTtcblx0aWYgKGQubGVuZ3RoID4gMSkge1xuXHQgICAgbWF0cml4LnB1c2goZCk7XG5cdH1cbiAgICB9XG5cbiAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcbiAgICByZXR1cm4gTS5zZXRFbGVtZW50cyhtYXRyaXgpO1xufTtcblxuLy8gRGlhZ29uYWwgbWF0cml4IC0gYWxsIG9mZi1kaWFnb25hbCBlbGVtZW50cyBhcmUgemVyb1xuTWF0cml4LkRpYWdvbmFsID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICB2YXIgaSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgTSA9IE1hdHJpeC5JKGkpO1xuICAgIHdoaWxlIChpLS0pIHtcblx0TS5lbGVtZW50c1tpXVtpXSA9IGVsZW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gTTtcbn07XG5cbi8vIFJvdGF0aW9uIG1hdHJpeCBhYm91dCBzb21lIGF4aXMuIElmIG5vIGF4aXMgaXNcbi8vIHN1cHBsaWVkLCBhc3N1bWUgd2UncmUgYWZ0ZXIgYSAyRCB0cmFuc2Zvcm1cbk1hdHJpeC5Sb3RhdGlvbiA9IGZ1bmN0aW9uKHRoZXRhLCBhKSB7XG4gICAgaWYgKCFhKSB7XG5cdHJldHVybiBNYXRyaXguY3JlYXRlKFtcblx0ICAgIFtNYXRoLmNvcyh0aGV0YSksIC1NYXRoLnNpbih0aGV0YSldLFxuXHQgICAgW01hdGguc2luKHRoZXRhKSwgTWF0aC5jb3ModGhldGEpXVxuXHRdKTtcbiAgfVxuICAgIHZhciBheGlzID0gYS5kdXAoKTtcbiAgICBpZiAoYXhpcy5lbGVtZW50cy5sZW5ndGggIT0gMykgeyByZXR1cm4gbnVsbDsgfVxuICAgIHZhciBtb2QgPSBheGlzLm1vZHVsdXMoKTtcbiAgICB2YXIgeCA9IGF4aXMuZWxlbWVudHNbMF0gLyBtb2QsIHkgPSBheGlzLmVsZW1lbnRzWzFdIC8gbW9kLCB6ID0gYXhpcy5lbGVtZW50c1syXSAvIG1vZDtcbiAgICB2YXIgcyA9IE1hdGguc2luKHRoZXRhKSwgYyA9IE1hdGguY29zKHRoZXRhKSwgdCA9IDEgLSBjO1xuICAgIC8vIEZvcm11bGEgZGVyaXZlZCBoZXJlOiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcbiAgICAvLyBUaGF0IHByb29mIHJvdGF0ZXMgdGhlIGNvLW9yZGluYXRlIHN5c3RlbSBzbyB0aGV0YVxuICAgIC8vIGJlY29tZXMgLXRoZXRhIGFuZCBzaW4gYmVjb21lcyAtc2luIGhlcmUuXG4gICAgcmV0dXJuIE1hdHJpeC5jcmVhdGUoW1xuXHRbdCAqIHggKiB4ICsgYywgdCAqIHggKiB5IC0gcyAqIHosIHQgKiB4ICogeiArIHMgKiB5XSxcblx0W3QgKiB4ICogeSArIHMgKiB6LCB0ICogeSAqIHkgKyBjLCB0ICogeSAqIHogLSBzICogeF0sXG5cdFt0ICogeCAqIHogLSBzICogeSwgdCAqIHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGNdXG4gICAgXSk7XG59O1xuXG4vLyBTcGVjaWFsIGNhc2Ugcm90YXRpb25zXG5NYXRyaXguUm90YXRpb25YID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBjID0gTWF0aC5jb3ModCksIHMgPSBNYXRoLnNpbih0KTtcbiAgICByZXR1cm4gTWF0cml4LmNyZWF0ZShbXG5cdFsxLCAwLCAwXSxcblx0WzAsIGMsIC1zXSxcblx0WzAsIHMsIGNdXG4gICAgXSk7XG59O1xuXG5NYXRyaXguUm90YXRpb25ZID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBjID0gTWF0aC5jb3ModCksIHMgPSBNYXRoLnNpbih0KTtcbiAgICByZXR1cm4gTWF0cml4LmNyZWF0ZShbXG5cdFtjLCAwLCBzXSxcblx0WzAsIDEsIDBdLFxuXHRbLXMsIDAsIGNdXG4gICAgXSk7XG59O1xuXG5NYXRyaXguUm90YXRpb25aID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBjID0gTWF0aC5jb3ModCksIHMgPSBNYXRoLnNpbih0KTtcbiAgICByZXR1cm4gTWF0cml4LmNyZWF0ZShbXG5cdFtjLCAtcywgMF0sXG5cdFtzLCBjLCAwXSxcblx0WzAsIDAsIDFdXG4gICAgXSk7XG59O1xuXG4vLyBSYW5kb20gbWF0cml4IG9mIG4gcm93cywgbSBjb2x1bW5zXG5NYXRyaXguUmFuZG9tID0gZnVuY3Rpb24obiwgbSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSBtID0gbjtcbiAgICByZXR1cm4gTWF0cml4Llplcm8obiwgbSkubWFwKFxuXHRmdW5jdGlvbigpIHsgcmV0dXJuIE1hdGgucmFuZG9tKCk7IH1cbiAgKTtcbn07XG5cbk1hdHJpeC5GaWxsID0gZnVuY3Rpb24obiwgbSwgdikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG5cdHYgPSBtO1xuXHRtID0gbjtcbiAgICB9XG5cbiAgICB2YXIgZWxzID0gW10sIGkgPSBuLCBqO1xuXG4gICAgd2hpbGUgKGktLSkge1xuXHRqID0gbTtcblx0ZWxzW2ldID0gW107XG5cblx0d2hpbGUgKGotLSkge1xuXHQgICAgZWxzW2ldW2pdID0gdjtcblx0fVxuICAgIH1cblxuICAgIHJldHVybiBNYXRyaXguY3JlYXRlKGVscyk7XG59O1xuXG4vLyBNYXRyaXggZmlsbGVkIHdpdGggemVyb3Ncbk1hdHJpeC5aZXJvID0gZnVuY3Rpb24obiwgbSkge1xuICAgIHJldHVybiBNYXRyaXguRmlsbChuLCBtLCAwKTtcbn07XG5cbi8vIE1hdHJpeCBmaWxsZWQgd2l0aCB6ZXJvc1xuTWF0cml4Llplcm9zID0gZnVuY3Rpb24obiwgbSkge1xuICAgIHJldHVybiBNYXRyaXguWmVybyhuLCBtKTtcbn07XG5cbi8vIE1hdHJpeCBmaWxsZWQgd2l0aCBvbmVzXG5NYXRyaXguT25lID0gZnVuY3Rpb24obiwgbSkge1xuICAgIHJldHVybiBNYXRyaXguRmlsbChuLCBtLCAxKTtcbn07XG5cbi8vIE1hdHJpeCBmaWxsZWQgd2l0aCBvbmVzXG5NYXRyaXguT25lcyA9IGZ1bmN0aW9uKG4sIG0pIHtcbiAgICByZXR1cm4gTWF0cml4Lk9uZShuLCBtKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sylvester/lib/node-sylvester/matrix.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sylvester/lib/node-sylvester/plane.js":
/*!************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/plane.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// Plane class - depends on Vector. Some methods require Matrix and Line.\nvar Vector = __webpack_require__(/*! ./vector */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\nvar Matrix = __webpack_require__(/*! ./matrix */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/matrix.js\");\nvar Line = __webpack_require__(/*! ./line */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/line.js\");\n\nvar Sylvester = __webpack_require__(/*! ./sylvester */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\");\n\nfunction Plane() {}\nPlane.prototype = {\n\n  // Returns true iff the plane occupies the same space as the argument\n  eql: function(plane) {\n    return (this.contains(plane.anchor) && this.isParallelTo(plane));\n  },\n\n  // Returns a copy of the plane\n  dup: function() {\n    return Plane.create(this.anchor, this.normal);\n  },\n\n  // Returns the result of translating the plane by the given vector\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    return Plane.create([\n      this.anchor.elements[0] + V[0],\n      this.anchor.elements[1] + V[1],\n      this.anchor.elements[2] + (V[2] || 0)\n    ], this.normal);\n  },\n\n  // Returns true iff the plane is parallel to the argument. Will return true\n  // if the planes are equal, or if you give a line and it lies in the plane.\n  isParallelTo: function(obj) {\n    var theta;\n    if (obj.normal) {\n      // obj is a plane\n      theta = this.normal.angleFrom(obj.normal);\n      return (Math.abs(theta) <= Sylvester.precision || Math.abs(Math.PI - theta) <= Sylvester.precision);\n    } else if (obj.direction) {\n      // obj is a line\n      return this.normal.isPerpendicularTo(obj.direction);\n    }\n    return null;\n  },\n\n  // Returns true iff the receiver is perpendicular to the argument\n  isPerpendicularTo: function(plane) {\n    var theta = this.normal.angleFrom(plane.normal);\n    return (Math.abs(Math.PI/2 - theta) <= Sylvester.precision);\n  },\n\n  // Returns the plane's distance from the given object (point, line or plane)\n  distanceFrom: function(obj) {\n    if (this.intersects(obj) || this.contains(obj)) { return 0; }\n    if (obj.anchor) {\n      // obj is a plane or line\n      var A = this.anchor.elements, B = obj.anchor.elements, N = this.normal.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, N = this.normal.elements;\n      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);\n    }\n  },\n\n  // Returns true iff the plane contains the given point or line\n  contains: function(obj) {\n    if (obj.normal) { return null; }\n    if (obj.direction) {\n      return (this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction)));\n    } else {\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, N = this.normal.elements;\n      var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));\n      return (diff <= Sylvester.precision);\n    }\n  },\n\n  // Returns true iff the plane has a unique point/line of intersection with the argument\n  intersects: function(obj) {\n    if (typeof(obj.direction) == 'undefined' && typeof(obj.normal) == 'undefined') { return null; }\n    return !this.isParallelTo(obj);\n  },\n\n  // Returns the unique intersection with the argument, if one exists. The result\n  // will be a vector if a line is supplied, and a line if a plane is supplied.\n  intersectionWith: function(obj) {\n    if (!this.intersects(obj)) { return null; }\n    if (obj.direction) {\n      // obj is a line\n      var A = obj.anchor.elements, D = obj.direction.elements,\n          P = this.anchor.elements, N = this.normal.elements;\n      var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);\n      return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);\n    } else if (obj.normal) {\n      // obj is a plane\n      var direction = this.normal.cross(obj.normal).toUnitVector();\n      // To find an anchor point, we find one co-ordinate that has a value\n      // of zero somewhere on the intersection, and remember which one we picked\n      var N = this.normal.elements, A = this.anchor.elements,\n          O = obj.normal.elements, B = obj.anchor.elements;\n      var solver = Matrix.Zero(2,2), i = 0;\n      while (solver.isSingular()) {\n        i++;\n        solver = Matrix.create([\n          [ N[i%3], N[(i+1)%3] ],\n          [ O[i%3], O[(i+1)%3]  ]\n        ]);\n      }\n      // Then we solve the simultaneous equations in the remaining dimensions\n      var inverse = solver.inverse().elements;\n      var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];\n      var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];\n      var intersection = [\n        inverse[0][0] * x + inverse[0][1] * y,\n        inverse[1][0] * x + inverse[1][1] * y\n      ];\n      var anchor = [];\n      for (var j = 1; j <= 3; j++) {\n        // This formula picks the right element from intersection by\n        // cycling depending on which element we set to zero above\n        anchor.push((i == j) ? 0 : intersection[(j + (5 - i)%3)%3]);\n      }\n      return Line.create(anchor, direction);\n    }\n  },\n\n  // Returns the point in the plane closest to the given point\n  pointClosestTo: function(point) {\n    var P = point.elements || point;\n    var A = this.anchor.elements, N = this.normal.elements;\n    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];\n    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);\n  },\n\n  // Returns a copy of the plane, rotated by t radians about the given line\n  // See notes on Line#rotate.\n  rotate: function(t, line) {\n    var R = t.determinant ? t.elements : Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements, N = this.normal.elements;\n    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];\n    var x = A1 - C1, y = A2 - C2, z = A3 - C3;\n    return Plane.create([\n      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z\n    ], [\n      R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],\n      R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],\n      R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]\n    ]);\n  },\n\n  // Returns the reflection of the plane in the given point, line or plane.\n  reflectionIn: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements, N = this.normal.elements;\n      var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];\n      var newA = this.anchor.reflectionIn(obj).elements;\n      // Add the plane's normal to its anchor, then mirror that in the other plane\n      var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;\n      var Q = obj.pointClosestTo([AN1, AN2, AN3]).elements;\n      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];\n      return Plane.create(newA, newN);\n    } else if (obj.direction) {\n      // obj is a line\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);\n    }\n  },\n\n  // Sets the anchor point and normal to the plane. If three arguments are specified,\n  // the normal is calculated by assuming the three points should lie in the same plane.\n  // If only two are sepcified, the second is taken to be the normal. Normal vector is\n  // normalised before storage.\n  setVectors: function(anchor, v1, v2) {\n    anchor = Vector.create(anchor);\n    anchor = anchor.to3D(); if (anchor === null) { return null; }\n    v1 = Vector.create(v1);\n    v1 = v1.to3D(); if (v1 === null) { return null; }\n    if (typeof(v2) == 'undefined') {\n      v2 = null;\n    } else {\n      v2 = Vector.create(v2);\n      v2 = v2.to3D(); if (v2 === null) { return null; }\n    }\n    var A1 = anchor.elements[0], A2 = anchor.elements[1], A3 = anchor.elements[2];\n    var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];\n    var normal, mod;\n    if (v2 !== null) {\n      var v21 = v2.elements[0], v22 = v2.elements[1], v23 = v2.elements[2];\n      normal = Vector.create([\n        (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),\n        (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),\n        (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)\n      ]);\n      mod = normal.modulus();\n      if (mod === 0) { return null; }\n      normal = Vector.create([normal.elements[0] / mod, normal.elements[1] / mod, normal.elements[2] / mod]);\n    } else {\n      mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);\n      if (mod === 0) { return null; }\n      normal = Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);\n    }\n    this.anchor = anchor;\n    this.normal = normal;\n    return this;\n  }\n};\n\n// Constructor function\nPlane.create = function(anchor, v1, v2) {\n  var P = new Plane();\n  return P.setVectors(anchor, v1, v2);\n};\n\n// X-Y-Z planes\nPlane.XY = Plane.create(Vector.Zero(3), Vector.k);\nPlane.YZ = Plane.create(Vector.Zero(3), Vector.i);\nPlane.ZX = Plane.create(Vector.Zero(3), Vector.j);\nPlane.YX = Plane.XY; Plane.ZY = Plane.YZ; Plane.XZ = Plane.ZX;\n\n// Returns the plane containing the given points (can be arrays as\n// well as vectors). If the points are not coplanar, returns null.\nPlane.fromPoints = function(points) {\n  var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);\n  for (i = 0; i < np; i++) {\n    P = Vector.create(points[i]).to3D();\n    if (P === null) { return null; }\n    list.push(P);\n    n = list.length;\n    if (n > 2) {\n      // Compute plane normal for the latest three points\n      A = list[n-1].elements; B = list[n-2].elements; C = list[n-3].elements;\n      N = Vector.create([\n        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),\n        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),\n        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])\n      ]).toUnitVector();\n      if (n > 3) {\n        // If the latest normal is not (anti)parallel to the previous one, we've strayed off the plane.\n        // This might be a slightly long-winded way of doing things, but we need the sum of all the normals\n        // to find which way the plane normal should point so that the points form an anticlockwise list.\n        theta = N.angleFrom(prevN);\n        if (theta !== null) {\n          if (!(Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision)) { return null; }\n        }\n      }\n      totalN = totalN.add(N);\n      prevN = N;\n    }\n  }\n  // We need to add in the normals at the start and end points, which the above misses out\n  A = list[1].elements; B = list[0].elements; C = list[n-1].elements; D = list[n-2].elements;\n  totalN = totalN.add(Vector.create([\n    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),\n    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),\n    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])\n  ]).toUnitVector()).add(Vector.create([\n    (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),\n    (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),\n    (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])\n  ]).toUnitVector());\n  return Plane.create(list[0], totalN);\n};\n\nmodule.exports = Plane;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9wbGFuZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDZFQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyw2RUFBVTtBQUMvQixXQUFXLG1CQUFPLENBQUMseUVBQVE7O0FBRTNCLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFhOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxNQUFNO0FBQ047QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQix3QkFBd0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzaXlhbVxcRG9jdW1lbnRzXFxBSS1Qb3dlcmVkLUNoYXRib3RcXG5vZGVfbW9kdWxlc1xcc3lsdmVzdGVyXFxsaWJcXG5vZGUtc3lsdmVzdGVyXFxwbGFuZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTEsIENocmlzIFVtYmVsLCBKYW1lcyBDb2dsYW5cbi8vIFBsYW5lIGNsYXNzIC0gZGVwZW5kcyBvbiBWZWN0b3IuIFNvbWUgbWV0aG9kcyByZXF1aXJlIE1hdHJpeCBhbmQgTGluZS5cbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xudmFyIE1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG52YXIgTGluZSA9IHJlcXVpcmUoJy4vbGluZScpO1xuXG52YXIgU3lsdmVzdGVyID0gcmVxdWlyZSgnLi9zeWx2ZXN0ZXInKTtcblxuZnVuY3Rpb24gUGxhbmUoKSB7fVxuUGxhbmUucHJvdG90eXBlID0ge1xuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHBsYW5lIG9jY3VwaWVzIHRoZSBzYW1lIHNwYWNlIGFzIHRoZSBhcmd1bWVudFxuICBlcWw6IGZ1bmN0aW9uKHBsYW5lKSB7XG4gICAgcmV0dXJuICh0aGlzLmNvbnRhaW5zKHBsYW5lLmFuY2hvcikgJiYgdGhpcy5pc1BhcmFsbGVsVG8ocGxhbmUpKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgcGxhbmVcbiAgZHVwOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUGxhbmUuY3JlYXRlKHRoaXMuYW5jaG9yLCB0aGlzLm5vcm1hbCk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRyYW5zbGF0aW5nIHRoZSBwbGFuZSBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgdmFyIFYgPSB2ZWN0b3IuZWxlbWVudHMgfHwgdmVjdG9yO1xuICAgIHJldHVybiBQbGFuZS5jcmVhdGUoW1xuICAgICAgdGhpcy5hbmNob3IuZWxlbWVudHNbMF0gKyBWWzBdLFxuICAgICAgdGhpcy5hbmNob3IuZWxlbWVudHNbMV0gKyBWWzFdLFxuICAgICAgdGhpcy5hbmNob3IuZWxlbWVudHNbMl0gKyAoVlsyXSB8fCAwKVxuICAgIF0sIHRoaXMubm9ybWFsKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBwbGFuZSBpcyBwYXJhbGxlbCB0byB0aGUgYXJndW1lbnQuIFdpbGwgcmV0dXJuIHRydWVcbiAgLy8gaWYgdGhlIHBsYW5lcyBhcmUgZXF1YWwsIG9yIGlmIHlvdSBnaXZlIGEgbGluZSBhbmQgaXQgbGllcyBpbiB0aGUgcGxhbmUuXG4gIGlzUGFyYWxsZWxUbzogZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHRoZXRhO1xuICAgIGlmIChvYmoubm9ybWFsKSB7XG4gICAgICAvLyBvYmogaXMgYSBwbGFuZVxuICAgICAgdGhldGEgPSB0aGlzLm5vcm1hbC5hbmdsZUZyb20ob2JqLm5vcm1hbCk7XG4gICAgICByZXR1cm4gKE1hdGguYWJzKHRoZXRhKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uIHx8IE1hdGguYWJzKE1hdGguUEkgLSB0aGV0YSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbik7XG4gICAgfSBlbHNlIGlmIChvYmouZGlyZWN0aW9uKSB7XG4gICAgICAvLyBvYmogaXMgYSBsaW5lXG4gICAgICByZXR1cm4gdGhpcy5ub3JtYWwuaXNQZXJwZW5kaWN1bGFyVG8ob2JqLmRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHJlY2VpdmVyIGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGFyZ3VtZW50XG4gIGlzUGVycGVuZGljdWxhclRvOiBmdW5jdGlvbihwbGFuZSkge1xuICAgIHZhciB0aGV0YSA9IHRoaXMubm9ybWFsLmFuZ2xlRnJvbShwbGFuZS5ub3JtYWwpO1xuICAgIHJldHVybiAoTWF0aC5hYnMoTWF0aC5QSS8yIC0gdGhldGEpIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHBsYW5lJ3MgZGlzdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0IChwb2ludCwgbGluZSBvciBwbGFuZSlcbiAgZGlzdGFuY2VGcm9tOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAodGhpcy5pbnRlcnNlY3RzKG9iaikgfHwgdGhpcy5jb250YWlucyhvYmopKSB7IHJldHVybiAwOyB9XG4gICAgaWYgKG9iai5hbmNob3IpIHtcbiAgICAgIC8vIG9iaiBpcyBhIHBsYW5lIG9yIGxpbmVcbiAgICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIEIgPSBvYmouYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoKEFbMF0gLSBCWzBdKSAqIE5bMF0gKyAoQVsxXSAtIEJbMV0pICogTlsxXSArIChBWzJdIC0gQlsyXSkgKiBOWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2JqIGlzIGEgcG9pbnRcbiAgICAgIHZhciBQID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcbiAgICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIE4gPSB0aGlzLm5vcm1hbC5lbGVtZW50cztcbiAgICAgIHJldHVybiBNYXRoLmFicygoQVswXSAtIFBbMF0pICogTlswXSArIChBWzFdIC0gUFsxXSkgKiBOWzFdICsgKEFbMl0gLSAoUFsyXSB8fCAwKSkgKiBOWzJdKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgcGxhbmUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50IG9yIGxpbmVcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsKSB7IHJldHVybiBudWxsOyB9XG4gICAgaWYgKG9iai5kaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybiAodGhpcy5jb250YWlucyhvYmouYW5jaG9yKSAmJiB0aGlzLmNvbnRhaW5zKG9iai5hbmNob3IuYWRkKG9iai5kaXJlY3Rpb24pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBQID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcbiAgICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIE4gPSB0aGlzLm5vcm1hbC5lbGVtZW50cztcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoTlswXSooQVswXSAtIFBbMF0pICsgTlsxXSooQVsxXSAtIFBbMV0pICsgTlsyXSooQVsyXSAtIChQWzJdIHx8IDApKSk7XG4gICAgICByZXR1cm4gKGRpZmYgPD0gU3lsdmVzdGVyLnByZWNpc2lvbik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHBsYW5lIGhhcyBhIHVuaXF1ZSBwb2ludC9saW5lIG9mIGludGVyc2VjdGlvbiB3aXRoIHRoZSBhcmd1bWVudFxuICBpbnRlcnNlY3RzOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAodHlwZW9mKG9iai5kaXJlY3Rpb24pID09ICd1bmRlZmluZWQnICYmIHR5cGVvZihvYmoubm9ybWFsKSA9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiAhdGhpcy5pc1BhcmFsbGVsVG8ob2JqKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSB1bmlxdWUgaW50ZXJzZWN0aW9uIHdpdGggdGhlIGFyZ3VtZW50LCBpZiBvbmUgZXhpc3RzLiBUaGUgcmVzdWx0XG4gIC8vIHdpbGwgYmUgYSB2ZWN0b3IgaWYgYSBsaW5lIGlzIHN1cHBsaWVkLCBhbmQgYSBsaW5lIGlmIGEgcGxhbmUgaXMgc3VwcGxpZWQuXG4gIGludGVyc2VjdGlvbldpdGg6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghdGhpcy5pbnRlcnNlY3RzKG9iaikpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBpZiAob2JqLmRpcmVjdGlvbikge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZVxuICAgICAgdmFyIEEgPSBvYmouYW5jaG9yLmVsZW1lbnRzLCBEID0gb2JqLmRpcmVjdGlvbi5lbGVtZW50cyxcbiAgICAgICAgICBQID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIE4gPSB0aGlzLm5vcm1hbC5lbGVtZW50cztcbiAgICAgIHZhciBtdWx0aXBsaWVyID0gKE5bMF0qKFBbMF0tQVswXSkgKyBOWzFdKihQWzFdLUFbMV0pICsgTlsyXSooUFsyXS1BWzJdKSkgLyAoTlswXSpEWzBdICsgTlsxXSpEWzFdICsgTlsyXSpEWzJdKTtcbiAgICAgIHJldHVybiBWZWN0b3IuY3JlYXRlKFtBWzBdICsgRFswXSptdWx0aXBsaWVyLCBBWzFdICsgRFsxXSptdWx0aXBsaWVyLCBBWzJdICsgRFsyXSptdWx0aXBsaWVyXSk7XG4gICAgfSBlbHNlIGlmIChvYmoubm9ybWFsKSB7XG4gICAgICAvLyBvYmogaXMgYSBwbGFuZVxuICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMubm9ybWFsLmNyb3NzKG9iai5ub3JtYWwpLnRvVW5pdFZlY3RvcigpO1xuICAgICAgLy8gVG8gZmluZCBhbiBhbmNob3IgcG9pbnQsIHdlIGZpbmQgb25lIGNvLW9yZGluYXRlIHRoYXQgaGFzIGEgdmFsdWVcbiAgICAgIC8vIG9mIHplcm8gc29tZXdoZXJlIG9uIHRoZSBpbnRlcnNlY3Rpb24sIGFuZCByZW1lbWJlciB3aGljaCBvbmUgd2UgcGlja2VkXG4gICAgICB2YXIgTiA9IHRoaXMubm9ybWFsLmVsZW1lbnRzLCBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsXG4gICAgICAgICAgTyA9IG9iai5ub3JtYWwuZWxlbWVudHMsIEIgPSBvYmouYW5jaG9yLmVsZW1lbnRzO1xuICAgICAgdmFyIHNvbHZlciA9IE1hdHJpeC5aZXJvKDIsMiksIGkgPSAwO1xuICAgICAgd2hpbGUgKHNvbHZlci5pc1Npbmd1bGFyKCkpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBzb2x2ZXIgPSBNYXRyaXguY3JlYXRlKFtcbiAgICAgICAgICBbIE5baSUzXSwgTlsoaSsxKSUzXSBdLFxuICAgICAgICAgIFsgT1tpJTNdLCBPWyhpKzEpJTNdICBdXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgLy8gVGhlbiB3ZSBzb2x2ZSB0aGUgc2ltdWx0YW5lb3VzIGVxdWF0aW9ucyBpbiB0aGUgcmVtYWluaW5nIGRpbWVuc2lvbnNcbiAgICAgIHZhciBpbnZlcnNlID0gc29sdmVyLmludmVyc2UoKS5lbGVtZW50cztcbiAgICAgIHZhciB4ID0gTlswXSpBWzBdICsgTlsxXSpBWzFdICsgTlsyXSpBWzJdO1xuICAgICAgdmFyIHkgPSBPWzBdKkJbMF0gKyBPWzFdKkJbMV0gKyBPWzJdKkJbMl07XG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gW1xuICAgICAgICBpbnZlcnNlWzBdWzBdICogeCArIGludmVyc2VbMF1bMV0gKiB5LFxuICAgICAgICBpbnZlcnNlWzFdWzBdICogeCArIGludmVyc2VbMV1bMV0gKiB5XG4gICAgICBdO1xuICAgICAgdmFyIGFuY2hvciA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gMzsgaisrKSB7XG4gICAgICAgIC8vIFRoaXMgZm9ybXVsYSBwaWNrcyB0aGUgcmlnaHQgZWxlbWVudCBmcm9tIGludGVyc2VjdGlvbiBieVxuICAgICAgICAvLyBjeWNsaW5nIGRlcGVuZGluZyBvbiB3aGljaCBlbGVtZW50IHdlIHNldCB0byB6ZXJvIGFib3ZlXG4gICAgICAgIGFuY2hvci5wdXNoKChpID09IGopID8gMCA6IGludGVyc2VjdGlvblsoaiArICg1IC0gaSklMyklM10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIExpbmUuY3JlYXRlKGFuY2hvciwgZGlyZWN0aW9uKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgcG9pbnQgaW4gdGhlIHBsYW5lIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIHBvaW50XG4gIHBvaW50Q2xvc2VzdFRvOiBmdW5jdGlvbihwb2ludCkge1xuICAgIHZhciBQID0gcG9pbnQuZWxlbWVudHMgfHwgcG9pbnQ7XG4gICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgTiA9IHRoaXMubm9ybWFsLmVsZW1lbnRzO1xuICAgIHZhciBkb3QgPSAoQVswXSAtIFBbMF0pICogTlswXSArIChBWzFdIC0gUFsxXSkgKiBOWzFdICsgKEFbMl0gLSAoUFsyXSB8fCAwKSkgKiBOWzJdO1xuICAgIHJldHVybiBWZWN0b3IuY3JlYXRlKFtQWzBdICsgTlswXSAqIGRvdCwgUFsxXSArIE5bMV0gKiBkb3QsIChQWzJdIHx8IDApICsgTlsyXSAqIGRvdF0pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBwbGFuZSwgcm90YXRlZCBieSB0IHJhZGlhbnMgYWJvdXQgdGhlIGdpdmVuIGxpbmVcbiAgLy8gU2VlIG5vdGVzIG9uIExpbmUjcm90YXRlLlxuICByb3RhdGU6IGZ1bmN0aW9uKHQsIGxpbmUpIHtcbiAgICB2YXIgUiA9IHQuZGV0ZXJtaW5hbnQgPyB0LmVsZW1lbnRzIDogTWF0cml4LlJvdGF0aW9uKHQsIGxpbmUuZGlyZWN0aW9uKS5lbGVtZW50cztcbiAgICB2YXIgQyA9IGxpbmUucG9pbnRDbG9zZXN0VG8odGhpcy5hbmNob3IpLmVsZW1lbnRzO1xuICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIE4gPSB0aGlzLm5vcm1hbC5lbGVtZW50cztcbiAgICB2YXIgQzEgPSBDWzBdLCBDMiA9IENbMV0sIEMzID0gQ1syXSwgQTEgPSBBWzBdLCBBMiA9IEFbMV0sIEEzID0gQVsyXTtcbiAgICB2YXIgeCA9IEExIC0gQzEsIHkgPSBBMiAtIEMyLCB6ID0gQTMgLSBDMztcbiAgICByZXR1cm4gUGxhbmUuY3JlYXRlKFtcbiAgICAgIEMxICsgUlswXVswXSAqIHggKyBSWzBdWzFdICogeSArIFJbMF1bMl0gKiB6LFxuICAgICAgQzIgKyBSWzFdWzBdICogeCArIFJbMV1bMV0gKiB5ICsgUlsxXVsyXSAqIHosXG4gICAgICBDMyArIFJbMl1bMF0gKiB4ICsgUlsyXVsxXSAqIHkgKyBSWzJdWzJdICogelxuICAgIF0sIFtcbiAgICAgIFJbMF1bMF0gKiBOWzBdICsgUlswXVsxXSAqIE5bMV0gKyBSWzBdWzJdICogTlsyXSxcbiAgICAgIFJbMV1bMF0gKiBOWzBdICsgUlsxXVsxXSAqIE5bMV0gKyBSWzFdWzJdICogTlsyXSxcbiAgICAgIFJbMl1bMF0gKiBOWzBdICsgUlsyXVsxXSAqIE5bMV0gKyBSWzJdWzJdICogTlsyXVxuICAgIF0pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHBsYW5lIGluIHRoZSBnaXZlbiBwb2ludCwgbGluZSBvciBwbGFuZS5cbiAgcmVmbGVjdGlvbkluOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLm5vcm1hbCkge1xuICAgICAgLy8gb2JqIGlzIGEgcGxhbmVcbiAgICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIE4gPSB0aGlzLm5vcm1hbC5lbGVtZW50cztcbiAgICAgIHZhciBBMSA9IEFbMF0sIEEyID0gQVsxXSwgQTMgPSBBWzJdLCBOMSA9IE5bMF0sIE4yID0gTlsxXSwgTjMgPSBOWzJdO1xuICAgICAgdmFyIG5ld0EgPSB0aGlzLmFuY2hvci5yZWZsZWN0aW9uSW4ob2JqKS5lbGVtZW50cztcbiAgICAgIC8vIEFkZCB0aGUgcGxhbmUncyBub3JtYWwgdG8gaXRzIGFuY2hvciwgdGhlbiBtaXJyb3IgdGhhdCBpbiB0aGUgb3RoZXIgcGxhbmVcbiAgICAgIHZhciBBTjEgPSBBMSArIE4xLCBBTjIgPSBBMiArIE4yLCBBTjMgPSBBMyArIE4zO1xuICAgICAgdmFyIFEgPSBvYmoucG9pbnRDbG9zZXN0VG8oW0FOMSwgQU4yLCBBTjNdKS5lbGVtZW50cztcbiAgICAgIHZhciBuZXdOID0gW1FbMF0gKyAoUVswXSAtIEFOMSkgLSBuZXdBWzBdLCBRWzFdICsgKFFbMV0gLSBBTjIpIC0gbmV3QVsxXSwgUVsyXSArIChRWzJdIC0gQU4zKSAtIG5ld0FbMl1dO1xuICAgICAgcmV0dXJuIFBsYW5lLmNyZWF0ZShuZXdBLCBuZXdOKTtcbiAgICB9IGVsc2UgaWYgKG9iai5kaXJlY3Rpb24pIHtcbiAgICAgIC8vIG9iaiBpcyBhIGxpbmVcbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZShNYXRoLlBJLCBvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvYmogaXMgYSBwb2ludFxuICAgICAgdmFyIFAgPSBvYmouZWxlbWVudHMgfHwgb2JqO1xuICAgICAgcmV0dXJuIFBsYW5lLmNyZWF0ZSh0aGlzLmFuY2hvci5yZWZsZWN0aW9uSW4oW1BbMF0sIFBbMV0sIChQWzJdIHx8IDApXSksIHRoaXMubm9ybWFsKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gU2V0cyB0aGUgYW5jaG9yIHBvaW50IGFuZCBub3JtYWwgdG8gdGhlIHBsYW5lLiBJZiB0aHJlZSBhcmd1bWVudHMgYXJlIHNwZWNpZmllZCxcbiAgLy8gdGhlIG5vcm1hbCBpcyBjYWxjdWxhdGVkIGJ5IGFzc3VtaW5nIHRoZSB0aHJlZSBwb2ludHMgc2hvdWxkIGxpZSBpbiB0aGUgc2FtZSBwbGFuZS5cbiAgLy8gSWYgb25seSB0d28gYXJlIHNlcGNpZmllZCwgdGhlIHNlY29uZCBpcyB0YWtlbiB0byBiZSB0aGUgbm9ybWFsLiBOb3JtYWwgdmVjdG9yIGlzXG4gIC8vIG5vcm1hbGlzZWQgYmVmb3JlIHN0b3JhZ2UuXG4gIHNldFZlY3RvcnM6IGZ1bmN0aW9uKGFuY2hvciwgdjEsIHYyKSB7XG4gICAgYW5jaG9yID0gVmVjdG9yLmNyZWF0ZShhbmNob3IpO1xuICAgIGFuY2hvciA9IGFuY2hvci50bzNEKCk7IGlmIChhbmNob3IgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2MSA9IFZlY3Rvci5jcmVhdGUodjEpO1xuICAgIHYxID0gdjEudG8zRCgpOyBpZiAodjEgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBpZiAodHlwZW9mKHYyKSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgdjIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2MiA9IFZlY3Rvci5jcmVhdGUodjIpO1xuICAgICAgdjIgPSB2Mi50bzNEKCk7IGlmICh2MiA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIH1cbiAgICB2YXIgQTEgPSBhbmNob3IuZWxlbWVudHNbMF0sIEEyID0gYW5jaG9yLmVsZW1lbnRzWzFdLCBBMyA9IGFuY2hvci5lbGVtZW50c1syXTtcbiAgICB2YXIgdjExID0gdjEuZWxlbWVudHNbMF0sIHYxMiA9IHYxLmVsZW1lbnRzWzFdLCB2MTMgPSB2MS5lbGVtZW50c1syXTtcbiAgICB2YXIgbm9ybWFsLCBtb2Q7XG4gICAgaWYgKHYyICE9PSBudWxsKSB7XG4gICAgICB2YXIgdjIxID0gdjIuZWxlbWVudHNbMF0sIHYyMiA9IHYyLmVsZW1lbnRzWzFdLCB2MjMgPSB2Mi5lbGVtZW50c1syXTtcbiAgICAgIG5vcm1hbCA9IFZlY3Rvci5jcmVhdGUoW1xuICAgICAgICAodjEyIC0gQTIpICogKHYyMyAtIEEzKSAtICh2MTMgLSBBMykgKiAodjIyIC0gQTIpLFxuICAgICAgICAodjEzIC0gQTMpICogKHYyMSAtIEExKSAtICh2MTEgLSBBMSkgKiAodjIzIC0gQTMpLFxuICAgICAgICAodjExIC0gQTEpICogKHYyMiAtIEEyKSAtICh2MTIgLSBBMikgKiAodjIxIC0gQTEpXG4gICAgICBdKTtcbiAgICAgIG1vZCA9IG5vcm1hbC5tb2R1bHVzKCk7XG4gICAgICBpZiAobW9kID09PSAwKSB7IHJldHVybiBudWxsOyB9XG4gICAgICBub3JtYWwgPSBWZWN0b3IuY3JlYXRlKFtub3JtYWwuZWxlbWVudHNbMF0gLyBtb2QsIG5vcm1hbC5lbGVtZW50c1sxXSAvIG1vZCwgbm9ybWFsLmVsZW1lbnRzWzJdIC8gbW9kXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZCA9IE1hdGguc3FydCh2MTEqdjExICsgdjEyKnYxMiArIHYxMyp2MTMpO1xuICAgICAgaWYgKG1vZCA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgbm9ybWFsID0gVmVjdG9yLmNyZWF0ZShbdjEuZWxlbWVudHNbMF0gLyBtb2QsIHYxLmVsZW1lbnRzWzFdIC8gbW9kLCB2MS5lbGVtZW50c1syXSAvIG1vZF0pO1xuICAgIH1cbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cblBsYW5lLmNyZWF0ZSA9IGZ1bmN0aW9uKGFuY2hvciwgdjEsIHYyKSB7XG4gIHZhciBQID0gbmV3IFBsYW5lKCk7XG4gIHJldHVybiBQLnNldFZlY3RvcnMoYW5jaG9yLCB2MSwgdjIpO1xufTtcblxuLy8gWC1ZLVogcGxhbmVzXG5QbGFuZS5YWSA9IFBsYW5lLmNyZWF0ZShWZWN0b3IuWmVybygzKSwgVmVjdG9yLmspO1xuUGxhbmUuWVogPSBQbGFuZS5jcmVhdGUoVmVjdG9yLlplcm8oMyksIFZlY3Rvci5pKTtcblBsYW5lLlpYID0gUGxhbmUuY3JlYXRlKFZlY3Rvci5aZXJvKDMpLCBWZWN0b3Iuaik7XG5QbGFuZS5ZWCA9IFBsYW5lLlhZOyBQbGFuZS5aWSA9IFBsYW5lLllaOyBQbGFuZS5YWiA9IFBsYW5lLlpYO1xuXG4vLyBSZXR1cm5zIHRoZSBwbGFuZSBjb250YWluaW5nIHRoZSBnaXZlbiBwb2ludHMgKGNhbiBiZSBhcnJheXMgYXNcbi8vIHdlbGwgYXMgdmVjdG9ycykuIElmIHRoZSBwb2ludHMgYXJlIG5vdCBjb3BsYW5hciwgcmV0dXJucyBudWxsLlxuUGxhbmUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cykge1xuICB2YXIgbnAgPSBwb2ludHMubGVuZ3RoLCBsaXN0ID0gW10sIGksIFAsIG4sIE4sIEEsIEIsIEMsIEQsIHRoZXRhLCBwcmV2TiwgdG90YWxOID0gVmVjdG9yLlplcm8oMyk7XG4gIGZvciAoaSA9IDA7IGkgPCBucDsgaSsrKSB7XG4gICAgUCA9IFZlY3Rvci5jcmVhdGUocG9pbnRzW2ldKS50bzNEKCk7XG4gICAgaWYgKFAgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBsaXN0LnB1c2goUCk7XG4gICAgbiA9IGxpc3QubGVuZ3RoO1xuICAgIGlmIChuID4gMikge1xuICAgICAgLy8gQ29tcHV0ZSBwbGFuZSBub3JtYWwgZm9yIHRoZSBsYXRlc3QgdGhyZWUgcG9pbnRzXG4gICAgICBBID0gbGlzdFtuLTFdLmVsZW1lbnRzOyBCID0gbGlzdFtuLTJdLmVsZW1lbnRzOyBDID0gbGlzdFtuLTNdLmVsZW1lbnRzO1xuICAgICAgTiA9IFZlY3Rvci5jcmVhdGUoW1xuICAgICAgICAoQVsxXSAtIEJbMV0pICogKENbMl0gLSBCWzJdKSAtIChBWzJdIC0gQlsyXSkgKiAoQ1sxXSAtIEJbMV0pLFxuICAgICAgICAoQVsyXSAtIEJbMl0pICogKENbMF0gLSBCWzBdKSAtIChBWzBdIC0gQlswXSkgKiAoQ1syXSAtIEJbMl0pLFxuICAgICAgICAoQVswXSAtIEJbMF0pICogKENbMV0gLSBCWzFdKSAtIChBWzFdIC0gQlsxXSkgKiAoQ1swXSAtIEJbMF0pXG4gICAgICBdKS50b1VuaXRWZWN0b3IoKTtcbiAgICAgIGlmIChuID4gMykge1xuICAgICAgICAvLyBJZiB0aGUgbGF0ZXN0IG5vcm1hbCBpcyBub3QgKGFudGkpcGFyYWxsZWwgdG8gdGhlIHByZXZpb3VzIG9uZSwgd2UndmUgc3RyYXllZCBvZmYgdGhlIHBsYW5lLlxuICAgICAgICAvLyBUaGlzIG1pZ2h0IGJlIGEgc2xpZ2h0bHkgbG9uZy13aW5kZWQgd2F5IG9mIGRvaW5nIHRoaW5ncywgYnV0IHdlIG5lZWQgdGhlIHN1bSBvZiBhbGwgdGhlIG5vcm1hbHNcbiAgICAgICAgLy8gdG8gZmluZCB3aGljaCB3YXkgdGhlIHBsYW5lIG5vcm1hbCBzaG91bGQgcG9pbnQgc28gdGhhdCB0aGUgcG9pbnRzIGZvcm0gYW4gYW50aWNsb2Nrd2lzZSBsaXN0LlxuICAgICAgICB0aGV0YSA9IE4uYW5nbGVGcm9tKHByZXZOKTtcbiAgICAgICAgaWYgKHRoZXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCEoTWF0aC5hYnModGhldGEpIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24gfHwgTWF0aC5hYnModGhldGEgLSBNYXRoLlBJKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b3RhbE4gPSB0b3RhbE4uYWRkKE4pO1xuICAgICAgcHJldk4gPSBOO1xuICAgIH1cbiAgfVxuICAvLyBXZSBuZWVkIHRvIGFkZCBpbiB0aGUgbm9ybWFscyBhdCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMsIHdoaWNoIHRoZSBhYm92ZSBtaXNzZXMgb3V0XG4gIEEgPSBsaXN0WzFdLmVsZW1lbnRzOyBCID0gbGlzdFswXS5lbGVtZW50czsgQyA9IGxpc3Rbbi0xXS5lbGVtZW50czsgRCA9IGxpc3Rbbi0yXS5lbGVtZW50cztcbiAgdG90YWxOID0gdG90YWxOLmFkZChWZWN0b3IuY3JlYXRlKFtcbiAgICAoQVsxXSAtIEJbMV0pICogKENbMl0gLSBCWzJdKSAtIChBWzJdIC0gQlsyXSkgKiAoQ1sxXSAtIEJbMV0pLFxuICAgIChBWzJdIC0gQlsyXSkgKiAoQ1swXSAtIEJbMF0pIC0gKEFbMF0gLSBCWzBdKSAqIChDWzJdIC0gQlsyXSksXG4gICAgKEFbMF0gLSBCWzBdKSAqIChDWzFdIC0gQlsxXSkgLSAoQVsxXSAtIEJbMV0pICogKENbMF0gLSBCWzBdKVxuICBdKS50b1VuaXRWZWN0b3IoKSkuYWRkKFZlY3Rvci5jcmVhdGUoW1xuICAgIChCWzFdIC0gQ1sxXSkgKiAoRFsyXSAtIENbMl0pIC0gKEJbMl0gLSBDWzJdKSAqIChEWzFdIC0gQ1sxXSksXG4gICAgKEJbMl0gLSBDWzJdKSAqIChEWzBdIC0gQ1swXSkgLSAoQlswXSAtIENbMF0pICogKERbMl0gLSBDWzJdKSxcbiAgICAoQlswXSAtIENbMF0pICogKERbMV0gLSBDWzFdKSAtIChCWzFdIC0gQ1sxXSkgKiAoRFswXSAtIENbMF0pXG4gIF0pLnRvVW5pdFZlY3RvcigpKTtcbiAgcmV0dXJuIFBsYW5lLmNyZWF0ZShsaXN0WzBdLCB0b3RhbE4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGFuZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sylvester/lib/node-sylvester/plane.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sylvester/lib/node-sylvester/sylvester.js":
/*!****************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/sylvester.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// This file is required in order for any other classes to work. Some Vector methods work with the\n// other Sylvester classes and are useless unless they are included. Other classes such as Line and\n// Plane will not function at all without Vector being loaded first.           \n\nMath.sign = function(x) {\n    return x < 0 ? -1: 1;\n}\n                                              \nvar Sylvester = {\n    precision: 1e-6\n};\n\nmodule.exports = Sylvester;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9zeWx2ZXN0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2l5YW1cXERvY3VtZW50c1xcQUktUG93ZXJlZC1DaGF0Ym90XFxub2RlX21vZHVsZXNcXHN5bHZlc3RlclxcbGliXFxub2RlLXN5bHZlc3Rlclxcc3lsdmVzdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWwsIEphbWVzIENvZ2xhblxuLy8gVGhpcyBmaWxlIGlzIHJlcXVpcmVkIGluIG9yZGVyIGZvciBhbnkgb3RoZXIgY2xhc3NlcyB0byB3b3JrLiBTb21lIFZlY3RvciBtZXRob2RzIHdvcmsgd2l0aCB0aGVcbi8vIG90aGVyIFN5bHZlc3RlciBjbGFzc2VzIGFuZCBhcmUgdXNlbGVzcyB1bmxlc3MgdGhleSBhcmUgaW5jbHVkZWQuIE90aGVyIGNsYXNzZXMgc3VjaCBhcyBMaW5lIGFuZFxuLy8gUGxhbmUgd2lsbCBub3QgZnVuY3Rpb24gYXQgYWxsIHdpdGhvdXQgVmVjdG9yIGJlaW5nIGxvYWRlZCBmaXJzdC4gICAgICAgICAgIFxuXG5NYXRoLnNpZ24gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggPCAwID8gLTE6IDE7XG59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG52YXIgU3lsdmVzdGVyID0ge1xuICAgIHByZWNpc2lvbjogMWUtNlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeWx2ZXN0ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sylvester/lib/node-sylvester/vector.js":
/*!*************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/vector.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// This file is required in order for any other classes to work. Some Vector methods work with the\n// other Sylvester classes and are useless unless they are included. Other classes such as Line and\n// Plane will not function at all without Vector being loaded first.\n\nvar Sylvester = __webpack_require__(/*! ./sylvester */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\"),\nMatrix = __webpack_require__(/*! ./matrix */ \"(rsc)/./node_modules/sylvester/lib/node-sylvester/matrix.js\");\n\nfunction Vector() {}\nVector.prototype = {\n\n    norm: function() {\n\tvar n = this.elements.length;\n\tvar sum = 0;\n\n\twhile (n--) {\n\t    sum += Math.pow(this.elements[n], 2);\n\t}\n\n\treturn Math.sqrt(sum);\n    },\n\n    // Returns element i of the vector\n    e: function(i) {\n      return (i < 1 || i > this.elements.length) ? null : this.elements[i - 1];\n    },\n\n    // Returns the number of rows/columns the vector has\n    dimensions: function() {\n      return {rows: 1, cols: this.elements.length};\n    },\n\n    // Returns the number of rows in the vector\n    rows: function() {\n      return 1;\n    },\n\n    // Returns the number of columns in the vector\n    cols: function() {\n      return this.elements.length;\n    },\n\n    // Returns the modulus ('length') of the vector\n    modulus: function() {\n      return Math.sqrt(this.dot(this));\n    },\n\n    // Returns true iff the vector is equal to the argument\n    eql: function(vector) {\n    \tvar n = this.elements.length;\n    \tvar V = vector.elements || vector;\n    \tif (n != V.length) { return false; }\n    \twhile (n--) {\n    \t    if (Math.abs(this.elements[n] - V[n]) > Sylvester.precision) { return false; }\n    \t}\n    \treturn true;\n    },\n\n    // Returns a copy of the vector\n    dup: function() {\n\t    return Vector.create(this.elements);\n    },\n\n    // Maps the vector to another vector according to the given function\n    map: function(fn) {\n\tvar elements = [];\n\tthis.each(function(x, i) {\n\t    elements.push(fn(x, i));\n\t});\n\treturn Vector.create(elements);\n    },\n\n    // Calls the iterator for each element of the vector in turn\n    each: function(fn) {\n\tvar n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    fn(this.elements[i], i + 1);\n\t}\n    },\n\n    // Returns a new vector created by normalizing the receiver\n    toUnitVector: function() {\n\tvar r = this.modulus();\n\tif (r === 0) { return this.dup(); }\n\treturn this.map(function(x) { return x / r; });\n    },\n\n    // Returns the angle between the vector and the argument (also a vector)\n    angleFrom: function(vector) {\n\tvar V = vector.elements || vector;\n\tvar n = this.elements.length, k = n, i;\n\tif (n != V.length) { return null; }\n\tvar dot = 0, mod1 = 0, mod2 = 0;\n\t// Work things out in parallel to save time\n\tthis.each(function(x, i) {\n\t    dot += x * V[i - 1];\n\t    mod1 += x * x;\n\t    mod2 += V[i - 1] * V[i - 1];\n\t});\n\tmod1 = Math.sqrt(mod1); mod2 = Math.sqrt(mod2);\n\tif (mod1 * mod2 === 0) { return null; }\n\tvar theta = dot / (mod1 * mod2);\n\tif (theta < -1) { theta = -1; }\n\tif (theta > 1) { theta = 1; }\n\treturn Math.acos(theta);\n    },\n\n    // Returns true iff the vector is parallel to the argument\n    isParallelTo: function(vector) {\n\tvar angle = this.angleFrom(vector);\n\treturn (angle === null) ? null : (angle <= Sylvester.precision);\n    },\n\n    // Returns true iff the vector is antiparallel to the argument\n    isAntiparallelTo: function(vector) {\n\tvar angle = this.angleFrom(vector);\n\treturn (angle === null) ? null : (Math.abs(angle - Math.PI) <= Sylvester.precision);\n    },\n\n    // Returns true iff the vector is perpendicular to the argument\n    isPerpendicularTo: function(vector) {\n\tvar dot = this.dot(vector);\n\treturn (dot === null) ? null : (Math.abs(dot) <= Sylvester.precision);\n    },\n\n    // Returns the result of adding the argument to the vector\n    add: function(value) {\n\tvar V = value.elements || value;\n\n\tif (this.elements.length != V.length) \n\t    return this.map(function(v) { return v + value });\n\telse\n\t    return this.map(function(x, i) { return x + V[i - 1]; });\n    },\n\n    // Returns the result of subtracting the argument from the vector\n    subtract: function(v) {\n\tif (typeof(v) == 'number')\n\t    return this.map(function(k) { return k - v; });\n\n\tvar V = v.elements || v;\n\tif (this.elements.length != V.length) { return null; }\n\treturn this.map(function(x, i) { return x - V[i - 1]; });\n    },\n\n    // Returns the result of multiplying the elements of the vector by the argument\n    multiply: function(k) {\n\treturn this.map(function(x) { return x * k; });\n    },\n\n    elementMultiply: function(v) {\n\treturn this.map(function(k, i) {\n\t    return v.e(i) * k;\n\t});\n    },\n\n    sum: function() {\n\tvar sum = 0;\n\tthis.map(function(x) { sum += x;});\n\treturn sum;\n    },\n\n    chomp: function(n) {\n\tvar elements = [];\n\n\tfor (var i = n; i < this.elements.length; i++) {\n\t    elements.push(this.elements[i]);\n\t}\n\n\treturn Vector.create(elements);\n    },\n\n    top: function(n) {\n\tvar elements = [];\n\n\tfor (var i = 0; i < n; i++) {\n\t    elements.push(this.elements[i]);\n\t}\n\n\treturn Vector.create(elements);\n    },\n\n    augment: function(elements) {\n\tvar newElements = this.elements;\n\n\tfor (var i = 0; i < elements.length; i++) {\n\t    newElements.push(elements[i]);\n\t}\n\n\treturn Vector.create(newElements);\n    },\n\n    x: function(k) { return this.multiply(k); },\n\n    log: function() {\n\treturn Vector.log(this);\n    },\n\n    elementDivide: function(vector) {\n\treturn this.map(function(v, i) {\n\t    return v / vector.e(i);\n\t});\n    },\n\n    product: function() {\n\tvar p = 1;\n\n\tthis.map(function(v) {\n\t    p *= v;\n\t});\n\n\treturn p;\n    },\n\n    // Returns the scalar product of the vector with the argument\n    // Both vectors must have equal dimensionality\n    dot: function(vector) {\n\tvar V = vector.elements || vector;\n\tvar i, product = 0, n = this.elements.length;\t\n\tif (n != V.length) { return null; }\n\twhile (n--) { product += this.elements[n] * V[n]; }\n\treturn product;\n    },\n\n    // Returns the vector product of the vector with the argument\n    // Both vectors must have dimensionality 3\n    cross: function(vector) {\n\tvar B = vector.elements || vector;\n\tif (this.elements.length != 3 || B.length != 3) { return null; }\n\tvar A = this.elements;\n\treturn Vector.create([\n\t    (A[1] * B[2]) - (A[2] * B[1]),\n\t    (A[2] * B[0]) - (A[0] * B[2]),\n\t    (A[0] * B[1]) - (A[1] * B[0])\n\t]);\n    },\n\n    // Returns the (absolute) largest element of the vector\n    max: function() {\n\tvar m = 0, i = this.elements.length;\n\twhile (i--) {\n\t    if (Math.abs(this.elements[i]) > Math.abs(m)) { m = this.elements[i]; }\n\t}\n\treturn m;\n    },\n\n\n    maxIndex: function() {\n\tvar m = 0, i = this.elements.length;\n\tvar maxIndex = -1;\n\n\twhile (i--) {\n\t    if (Math.abs(this.elements[i]) > Math.abs(m)) { \n\t\tm = this.elements[i]; \n\t\tmaxIndex = i + 1;\n\t    }\n\t}\n\n\treturn maxIndex;\n    },\n\n\n    // Returns the index of the first match found\n    indexOf: function(x) {\n\tvar index = null, n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    if (index === null && this.elements[i] == x) {\n\t\tindex = i + 1;\n\t    }\n\t}\n\treturn index;\n    },\n\n    // Returns a diagonal matrix with the vector's elements as its diagonal elements\n    toDiagonalMatrix: function() {\n\treturn Matrix.Diagonal(this.elements);\n    },\n\n    // Returns the result of rounding the elements of the vector\n    round: function() {\n\treturn this.map(function(x) { return Math.round(x); });\n    },\n\n    // Transpose a Vector, return a 1xn Matrix\n    transpose: function() {\n\tvar rows = this.elements.length;\n\tvar elements = [];\n\n\tfor (var i = 0; i < rows; i++) {\n\t    elements.push([this.elements[i]]);\n\t}\n\treturn Matrix.create(elements);\n    },\n\n    // Returns a copy of the vector with elements set to the given value if they\n    // differ from it by less than Sylvester.precision\n    snapTo: function(x) {\n\treturn this.map(function(y) {\n\t    return (Math.abs(y - x) <= Sylvester.precision) ? x : y;\n\t});\n    },\n\n    // Returns the vector's distance from the argument, when considered as a point in space\n    distanceFrom: function(obj) {\n\tif (obj.anchor || (obj.start && obj.end)) { return obj.distanceFrom(this); }\n\tvar V = obj.elements || obj;\n\tif (V.length != this.elements.length) { return null; }\n\tvar sum = 0, part;\n\tthis.each(function(x, i) {\n\t    part = x - V[i - 1];\n\t    sum += part * part;\n\t});\n\treturn Math.sqrt(sum);\n    },\n\n    // Returns true if the vector is point on the given line\n    liesOn: function(line) {\n\treturn line.contains(this);\n    },\n\n    // Return true iff the vector is a point in the given plane\n    liesIn: function(plane) {\n\treturn plane.contains(this);\n    },\n\n    // Rotates the vector about the given object. The object should be a\n    // point if the vector is 2D, and a line if it is 3D. Be careful with line directions!\n    rotate: function(t, obj) {\n\tvar V, R = null, x, y, z;\n\tif (t.determinant) { R = t.elements; }\n\tswitch (this.elements.length) {\n\tcase 2:\n            V = obj.elements || obj;\n            if (V.length != 2) { return null; }\n            if (!R) { R = Matrix.Rotation(t).elements; }\n            x = this.elements[0] - V[0];\n            y = this.elements[1] - V[1];\n            return Vector.create([\n\t\tV[0] + R[0][0] * x + R[0][1] * y,\n\t\tV[1] + R[1][0] * x + R[1][1] * y\n            ]);\n            break;\n\tcase 3:\n            if (!obj.direction) { return null; }\n            var C = obj.pointClosestTo(this).elements;\n            if (!R) { R = Matrix.Rotation(t, obj.direction).elements; }\n            x = this.elements[0] - C[0];\n            y = this.elements[1] - C[1];\n            z = this.elements[2] - C[2];\n            return Vector.create([\n\t\tC[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n\t\tC[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n\t\tC[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z\n            ]);\n            break;\n\tdefault:\n            return null;\n\t}\n    },\n\n    // Returns the result of reflecting the point in the given point, line or plane\n    reflectionIn: function(obj) {\n\tif (obj.anchor) {\n\t    // obj is a plane or line\n\t    var P = this.elements.slice();\n\t    var C = obj.pointClosestTo(P).elements;\n\t    return Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);\n\t} else {\n\t    // obj is a point\n\t    var Q = obj.elements || obj;\n\t    if (this.elements.length != Q.length) { return null; }\n\t    return this.map(function(x, i) { return Q[i - 1] + (Q[i - 1] - x); });\n\t}\n    },\n\n    // Utility to make sure vectors are 3D. If they are 2D, a zero z-component is added\n    to3D: function() {\n\tvar V = this.dup();\n\tswitch (V.elements.length) {\n\tcase 3: break;\n\tcase 2: V.elements.push(0); break;\n\tdefault: return null;\n\t}\n\treturn V;\n    },\n\n    // Returns a string representation of the vector\n    inspect: function() {\n\treturn '[' + this.elements.join(', ') + ']';\n    },\n\n    // Set vector's elements from an array\n    setElements: function(els) {\n\tthis.elements = (els.elements || els).slice();\n\treturn this;\n    }\n};\n\n// Constructor function\nVector.create = function(elements) {\n    var V = new Vector();\n    return V.setElements(elements);\n};\n\n// i, j, k unit vectors\nVector.i = Vector.create([1, 0, 0]);\nVector.j = Vector.create([0, 1, 0]);\nVector.k = Vector.create([0, 0, 1]);\n\n// Random vector of size n\nVector.Random = function(n) {\n    var elements = [];\n    while (n--) { elements.push(Math.random()); }\n    return Vector.create(elements);\n};\n\nVector.Fill = function(n, v) {\n    var elements = [];\n    while (n--) { elements.push(v); }\n    return Vector.create(elements);\n};\n\n// Vector filled with zeros\nVector.Zero = function(n) {\n    return Vector.Fill(n, 0);\n};\n\nVector.One = function(n) {\n    return Vector.Fill(n, 1);\n};\n\nVector.log = function(v) {\n    return v.map(function(x) {\n\treturn Math.log(x);\n    });\n};\n\nmodule.exports = Vector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci92ZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWE7QUFDckMsU0FBUyxtQkFBTyxDQUFDLDZFQUFVOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLCtCQUErQixlQUFlO0FBQzlDLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUI7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMs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QUFDQSxLQUFLO0FBQ0w7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2l5YW1cXERvY3VtZW50c1xcQUktUG93ZXJlZC1DaGF0Ym90XFxub2RlX21vZHVsZXNcXHN5bHZlc3RlclxcbGliXFxub2RlLXN5bHZlc3RlclxcdmVjdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWwsIEphbWVzIENvZ2xhblxuLy8gVGhpcyBmaWxlIGlzIHJlcXVpcmVkIGluIG9yZGVyIGZvciBhbnkgb3RoZXIgY2xhc3NlcyB0byB3b3JrLiBTb21lIFZlY3RvciBtZXRob2RzIHdvcmsgd2l0aCB0aGVcbi8vIG90aGVyIFN5bHZlc3RlciBjbGFzc2VzIGFuZCBhcmUgdXNlbGVzcyB1bmxlc3MgdGhleSBhcmUgaW5jbHVkZWQuIE90aGVyIGNsYXNzZXMgc3VjaCBhcyBMaW5lIGFuZFxuLy8gUGxhbmUgd2lsbCBub3QgZnVuY3Rpb24gYXQgYWxsIHdpdGhvdXQgVmVjdG9yIGJlaW5nIGxvYWRlZCBmaXJzdC5cblxudmFyIFN5bHZlc3RlciA9IHJlcXVpcmUoJy4vc3lsdmVzdGVyJyksXG5NYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG5mdW5jdGlvbiBWZWN0b3IoKSB7fVxuVmVjdG9yLnByb3RvdHlwZSA9IHtcblxuICAgIG5vcm06IGZ1bmN0aW9uKCkge1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHR2YXIgc3VtID0gMDtcblxuXHR3aGlsZSAobi0tKSB7XG5cdCAgICBzdW0gKz0gTWF0aC5wb3codGhpcy5lbGVtZW50c1tuXSwgMik7XG5cdH1cblxuXHRyZXR1cm4gTWF0aC5zcXJ0KHN1bSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZWxlbWVudCBpIG9mIHRoZSB2ZWN0b3JcbiAgICBlOiBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gKGkgPCAxIHx8IGkgPiB0aGlzLmVsZW1lbnRzLmxlbmd0aCkgPyBudWxsIDogdGhpcy5lbGVtZW50c1tpIC0gMV07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzL2NvbHVtbnMgdGhlIHZlY3RvciBoYXNcbiAgICBkaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7cm93czogMSwgY29sczogdGhpcy5lbGVtZW50cy5sZW5ndGh9O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdmVjdG9yXG4gICAgcm93czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHZlY3RvclxuICAgIGNvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBtb2R1bHVzICgnbGVuZ3RoJykgb2YgdGhlIHZlY3RvclxuICAgIG1vZHVsdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRvdCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHZlY3RvciBpcyBlcXVhbCB0byB0aGUgYXJndW1lbnRcbiAgICBlcWw6IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgIFx0dmFyIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICBcdHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcbiAgICBcdGlmIChuICE9IFYubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIFx0d2hpbGUgKG4tLSkge1xuICAgIFx0ICAgIGlmIChNYXRoLmFicyh0aGlzLmVsZW1lbnRzW25dIC0gVltuXSkgPiBTeWx2ZXN0ZXIucHJlY2lzaW9uKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIFx0fVxuICAgIFx0cmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSB2ZWN0b3JcbiAgICBkdXA6IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUodGhpcy5lbGVtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIE1hcHMgdGhlIHZlY3RvciB0byBhbm90aGVyIHZlY3RvciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAgbWFwOiBmdW5jdGlvbihmbikge1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblx0dGhpcy5lYWNoKGZ1bmN0aW9uKHgsIGkpIHtcblx0ICAgIGVsZW1lbnRzLnB1c2goZm4oeCwgaSkpO1xuXHR9KTtcblx0cmV0dXJuIFZlY3Rvci5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxscyB0aGUgaXRlcmF0b3IgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGluIHR1cm5cbiAgICBlYWNoOiBmdW5jdGlvbihmbikge1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgZm4odGhpcy5lbGVtZW50c1tpXSwgaSArIDEpO1xuXHR9XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBuZXcgdmVjdG9yIGNyZWF0ZWQgYnkgbm9ybWFsaXppbmcgdGhlIHJlY2VpdmVyXG4gICAgdG9Vbml0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0dmFyIHIgPSB0aGlzLm1vZHVsdXMoKTtcblx0aWYgKHIgPT09IDApIHsgcmV0dXJuIHRoaXMuZHVwKCk7IH1cblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggLyByOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgdmVjdG9yIGFuZCB0aGUgYXJndW1lbnQgKGFsc28gYSB2ZWN0b3IpXG4gICAgYW5nbGVGcm9tOiBmdW5jdGlvbih2ZWN0b3IpIHtcblx0dmFyIFYgPSB2ZWN0b3IuZWxlbWVudHMgfHwgdmVjdG9yO1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBrID0gbiwgaTtcblx0aWYgKG4gIT0gVi5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIGRvdCA9IDAsIG1vZDEgPSAwLCBtb2QyID0gMDtcblx0Ly8gV29yayB0aGluZ3Mgb3V0IGluIHBhcmFsbGVsIHRvIHNhdmUgdGltZVxuXHR0aGlzLmVhY2goZnVuY3Rpb24oeCwgaSkge1xuXHQgICAgZG90ICs9IHggKiBWW2kgLSAxXTtcblx0ICAgIG1vZDEgKz0geCAqIHg7XG5cdCAgICBtb2QyICs9IFZbaSAtIDFdICogVltpIC0gMV07XG5cdH0pO1xuXHRtb2QxID0gTWF0aC5zcXJ0KG1vZDEpOyBtb2QyID0gTWF0aC5zcXJ0KG1vZDIpO1xuXHRpZiAobW9kMSAqIG1vZDIgPT09IDApIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIHRoZXRhID0gZG90IC8gKG1vZDEgKiBtb2QyKTtcblx0aWYgKHRoZXRhIDwgLTEpIHsgdGhldGEgPSAtMTsgfVxuXHRpZiAodGhldGEgPiAxKSB7IHRoZXRhID0gMTsgfVxuXHRyZXR1cm4gTWF0aC5hY29zKHRoZXRhKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIHBhcmFsbGVsIHRvIHRoZSBhcmd1bWVudFxuICAgIGlzUGFyYWxsZWxUbzogZnVuY3Rpb24odmVjdG9yKSB7XG5cdHZhciBhbmdsZSA9IHRoaXMuYW5nbGVGcm9tKHZlY3Rvcik7XG5cdHJldHVybiAoYW5nbGUgPT09IG51bGwpID8gbnVsbCA6IChhbmdsZSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIGFudGlwYXJhbGxlbCB0byB0aGUgYXJndW1lbnRcbiAgICBpc0FudGlwYXJhbGxlbFRvOiBmdW5jdGlvbih2ZWN0b3IpIHtcblx0dmFyIGFuZ2xlID0gdGhpcy5hbmdsZUZyb20odmVjdG9yKTtcblx0cmV0dXJuIChhbmdsZSA9PT0gbnVsbCkgPyBudWxsIDogKE1hdGguYWJzKGFuZ2xlIC0gTWF0aC5QSSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbik7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHZlY3RvciBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBhcmd1bWVudFxuICAgIGlzUGVycGVuZGljdWxhclRvOiBmdW5jdGlvbih2ZWN0b3IpIHtcblx0dmFyIGRvdCA9IHRoaXMuZG90KHZlY3Rvcik7XG5cdHJldHVybiAoZG90ID09PSBudWxsKSA/IG51bGwgOiAoTWF0aC5hYnMoZG90KSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGluZyB0aGUgYXJndW1lbnQgdG8gdGhlIHZlY3RvclxuICAgIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcblx0dmFyIFYgPSB2YWx1ZS5lbGVtZW50cyB8fCB2YWx1ZTtcblxuXHRpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggIT0gVi5sZW5ndGgpIFxuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgKyB2YWx1ZSB9KTtcblx0ZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgsIGkpIHsgcmV0dXJuIHggKyBWW2kgLSAxXTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGluZyB0aGUgYXJndW1lbnQgZnJvbSB0aGUgdmVjdG9yXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uKHYpIHtcblx0aWYgKHR5cGVvZih2KSA9PSAnbnVtYmVyJylcblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihrKSB7IHJldHVybiBrIC0gdjsgfSk7XG5cblx0dmFyIFYgPSB2LmVsZW1lbnRzIHx8IHY7XG5cdGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPSBWLmxlbmd0aCkgeyByZXR1cm4gbnVsbDsgfVxuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCwgaSkgeyByZXR1cm4geCAtIFZbaSAtIDFdOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGx5aW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgdmVjdG9yIGJ5IHRoZSBhcmd1bWVudFxuICAgIG11bHRpcGx5OiBmdW5jdGlvbihrKSB7XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4ICogazsgfSk7XG4gICAgfSxcblxuICAgIGVsZW1lbnRNdWx0aXBseTogZnVuY3Rpb24odikge1xuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaywgaSkge1xuXHQgICAgcmV0dXJuIHYuZShpKSAqIGs7XG5cdH0pO1xuICAgIH0sXG5cbiAgICBzdW06IGZ1bmN0aW9uKCkge1xuXHR2YXIgc3VtID0gMDtcblx0dGhpcy5tYXAoZnVuY3Rpb24oeCkgeyBzdW0gKz0geDt9KTtcblx0cmV0dXJuIHN1bTtcbiAgICB9LFxuXG4gICAgY2hvbXA6IGZ1bmN0aW9uKG4pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0Zm9yICh2YXIgaSA9IG47IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBlbGVtZW50cy5wdXNoKHRoaXMuZWxlbWVudHNbaV0pO1xuXHR9XG5cblx0cmV0dXJuIFZlY3Rvci5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICB0b3A6IGZ1bmN0aW9uKG4pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGVsZW1lbnRzLnB1c2godGhpcy5lbGVtZW50c1tpXSk7XG5cdH1cblxuXHRyZXR1cm4gVmVjdG9yLmNyZWF0ZShlbGVtZW50cyk7XG4gICAgfSxcblxuICAgIGF1Z21lbnQ6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdHZhciBuZXdFbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50c1tpXSk7XG5cdH1cblxuXHRyZXR1cm4gVmVjdG9yLmNyZWF0ZShuZXdFbGVtZW50cyk7XG4gICAgfSxcblxuICAgIHg6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMubXVsdGlwbHkoayk7IH0sXG5cbiAgICBsb2c6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gVmVjdG9yLmxvZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgZWxlbWVudERpdmlkZTogZnVuY3Rpb24odmVjdG9yKSB7XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2LCBpKSB7XG5cdCAgICByZXR1cm4gdiAvIHZlY3Rvci5lKGkpO1xuXHR9KTtcbiAgICB9LFxuXG4gICAgcHJvZHVjdDogZnVuY3Rpb24oKSB7XG5cdHZhciBwID0gMTtcblxuXHR0aGlzLm1hcChmdW5jdGlvbih2KSB7XG5cdCAgICBwICo9IHY7XG5cdH0pO1xuXG5cdHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBzY2FsYXIgcHJvZHVjdCBvZiB0aGUgdmVjdG9yIHdpdGggdGhlIGFyZ3VtZW50XG4gICAgLy8gQm90aCB2ZWN0b3JzIG11c3QgaGF2ZSBlcXVhbCBkaW1lbnNpb25hbGl0eVxuICAgIGRvdDogZnVuY3Rpb24odmVjdG9yKSB7XG5cdHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3Rvcjtcblx0dmFyIGksIHByb2R1Y3QgPSAwLCBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHRcblx0aWYgKG4gIT0gVi5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0d2hpbGUgKG4tLSkgeyBwcm9kdWN0ICs9IHRoaXMuZWxlbWVudHNbbl0gKiBWW25dOyB9XG5cdHJldHVybiBwcm9kdWN0O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSB2ZWN0b3IgcHJvZHVjdCBvZiB0aGUgdmVjdG9yIHdpdGggdGhlIGFyZ3VtZW50XG4gICAgLy8gQm90aCB2ZWN0b3JzIG11c3QgaGF2ZSBkaW1lbnNpb25hbGl0eSAzXG4gICAgY3Jvc3M6IGZ1bmN0aW9uKHZlY3Rvcikge1xuXHR2YXIgQiA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XG5cdGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPSAzIHx8IEIubGVuZ3RoICE9IDMpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIEEgPSB0aGlzLmVsZW1lbnRzO1xuXHRyZXR1cm4gVmVjdG9yLmNyZWF0ZShbXG5cdCAgICAoQVsxXSAqIEJbMl0pIC0gKEFbMl0gKiBCWzFdKSxcblx0ICAgIChBWzJdICogQlswXSkgLSAoQVswXSAqIEJbMl0pLFxuXHQgICAgKEFbMF0gKiBCWzFdKSAtIChBWzFdICogQlswXSlcblx0XSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIChhYnNvbHV0ZSkgbGFyZ2VzdCBlbGVtZW50IG9mIHRoZSB2ZWN0b3JcbiAgICBtYXg6IGZ1bmN0aW9uKCkge1xuXHR2YXIgbSA9IDAsIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0d2hpbGUgKGktLSkge1xuXHQgICAgaWYgKE1hdGguYWJzKHRoaXMuZWxlbWVudHNbaV0pID4gTWF0aC5hYnMobSkpIHsgbSA9IHRoaXMuZWxlbWVudHNbaV07IH1cblx0fVxuXHRyZXR1cm4gbTtcbiAgICB9LFxuXG5cbiAgICBtYXhJbmRleDogZnVuY3Rpb24oKSB7XG5cdHZhciBtID0gMCwgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHR2YXIgbWF4SW5kZXggPSAtMTtcblxuXHR3aGlsZSAoaS0tKSB7XG5cdCAgICBpZiAoTWF0aC5hYnModGhpcy5lbGVtZW50c1tpXSkgPiBNYXRoLmFicyhtKSkgeyBcblx0XHRtID0gdGhpcy5lbGVtZW50c1tpXTsgXG5cdFx0bWF4SW5kZXggPSBpICsgMTtcblx0ICAgIH1cblx0fVxuXG5cdHJldHVybiBtYXhJbmRleDtcbiAgICB9LFxuXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgbWF0Y2ggZm91bmRcbiAgICBpbmRleE9mOiBmdW5jdGlvbih4KSB7XG5cdHZhciBpbmRleCA9IG51bGwsIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGlmIChpbmRleCA9PT0gbnVsbCAmJiB0aGlzLmVsZW1lbnRzW2ldID09IHgpIHtcblx0XHRpbmRleCA9IGkgKyAxO1xuXHQgICAgfVxuXHR9XG5cdHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIGRpYWdvbmFsIG1hdHJpeCB3aXRoIHRoZSB2ZWN0b3IncyBlbGVtZW50cyBhcyBpdHMgZGlhZ29uYWwgZWxlbWVudHNcbiAgICB0b0RpYWdvbmFsTWF0cml4OiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIE1hdHJpeC5EaWFnb25hbCh0aGlzLmVsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHJvdW5kaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgdmVjdG9yXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFRyYW5zcG9zZSBhIFZlY3RvciwgcmV0dXJuIGEgMXhuIE1hdHJpeFxuICAgIHRyYW5zcG9zZTogZnVuY3Rpb24oKSB7XG5cdHZhciByb3dzID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG5cdCAgICBlbGVtZW50cy5wdXNoKFt0aGlzLmVsZW1lbnRzW2ldXSk7XG5cdH1cblx0cmV0dXJuIE1hdHJpeC5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgdmVjdG9yIHdpdGggZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiB2YWx1ZSBpZiB0aGV5XG4gICAgLy8gZGlmZmVyIGZyb20gaXQgYnkgbGVzcyB0aGFuIFN5bHZlc3Rlci5wcmVjaXNpb25cbiAgICBzbmFwVG86IGZ1bmN0aW9uKHgpIHtcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHkpIHtcblx0ICAgIHJldHVybiAoTWF0aC5hYnMoeSAtIHgpIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pID8geCA6IHk7XG5cdH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSB2ZWN0b3IncyBkaXN0YW5jZSBmcm9tIHRoZSBhcmd1bWVudCwgd2hlbiBjb25zaWRlcmVkIGFzIGEgcG9pbnQgaW4gc3BhY2VcbiAgICBkaXN0YW5jZUZyb206IGZ1bmN0aW9uKG9iaikge1xuXHRpZiAob2JqLmFuY2hvciB8fCAob2JqLnN0YXJ0ICYmIG9iai5lbmQpKSB7IHJldHVybiBvYmouZGlzdGFuY2VGcm9tKHRoaXMpOyB9XG5cdHZhciBWID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcblx0aWYgKFYubGVuZ3RoICE9IHRoaXMuZWxlbWVudHMubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHZhciBzdW0gPSAwLCBwYXJ0O1xuXHR0aGlzLmVhY2goZnVuY3Rpb24oeCwgaSkge1xuXHQgICAgcGFydCA9IHggLSBWW2kgLSAxXTtcblx0ICAgIHN1bSArPSBwYXJ0ICogcGFydDtcblx0fSk7XG5cdHJldHVybiBNYXRoLnNxcnQoc3VtKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSB2ZWN0b3IgaXMgcG9pbnQgb24gdGhlIGdpdmVuIGxpbmVcbiAgICBsaWVzT246IGZ1bmN0aW9uKGxpbmUpIHtcblx0cmV0dXJuIGxpbmUuY29udGFpbnModGhpcyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIGEgcG9pbnQgaW4gdGhlIGdpdmVuIHBsYW5lXG4gICAgbGllc0luOiBmdW5jdGlvbihwbGFuZSkge1xuXHRyZXR1cm4gcGxhbmUuY29udGFpbnModGhpcyk7XG4gICAgfSxcblxuICAgIC8vIFJvdGF0ZXMgdGhlIHZlY3RvciBhYm91dCB0aGUgZ2l2ZW4gb2JqZWN0LiBUaGUgb2JqZWN0IHNob3VsZCBiZSBhXG4gICAgLy8gcG9pbnQgaWYgdGhlIHZlY3RvciBpcyAyRCwgYW5kIGEgbGluZSBpZiBpdCBpcyAzRC4gQmUgY2FyZWZ1bCB3aXRoIGxpbmUgZGlyZWN0aW9ucyFcbiAgICByb3RhdGU6IGZ1bmN0aW9uKHQsIG9iaikge1xuXHR2YXIgViwgUiA9IG51bGwsIHgsIHksIHo7XG5cdGlmICh0LmRldGVybWluYW50KSB7IFIgPSB0LmVsZW1lbnRzOyB9XG5cdHN3aXRjaCAodGhpcy5lbGVtZW50cy5sZW5ndGgpIHtcblx0Y2FzZSAyOlxuICAgICAgICAgICAgViA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICAgICAgICBpZiAoVi5sZW5ndGggIT0gMikgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKCFSKSB7IFIgPSBNYXRyaXguUm90YXRpb24odCkuZWxlbWVudHM7IH1cbiAgICAgICAgICAgIHggPSB0aGlzLmVsZW1lbnRzWzBdIC0gVlswXTtcbiAgICAgICAgICAgIHkgPSB0aGlzLmVsZW1lbnRzWzFdIC0gVlsxXTtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuY3JlYXRlKFtcblx0XHRWWzBdICsgUlswXVswXSAqIHggKyBSWzBdWzFdICogeSxcblx0XHRWWzFdICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcblx0Y2FzZSAzOlxuICAgICAgICAgICAgaWYgKCFvYmouZGlyZWN0aW9uKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICB2YXIgQyA9IG9iai5wb2ludENsb3Nlc3RUbyh0aGlzKS5lbGVtZW50cztcbiAgICAgICAgICAgIGlmICghUikgeyBSID0gTWF0cml4LlJvdGF0aW9uKHQsIG9iai5kaXJlY3Rpb24pLmVsZW1lbnRzOyB9XG4gICAgICAgICAgICB4ID0gdGhpcy5lbGVtZW50c1swXSAtIENbMF07XG4gICAgICAgICAgICB5ID0gdGhpcy5lbGVtZW50c1sxXSAtIENbMV07XG4gICAgICAgICAgICB6ID0gdGhpcy5lbGVtZW50c1syXSAtIENbMl07XG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbXG5cdFx0Q1swXSArIFJbMF1bMF0gKiB4ICsgUlswXVsxXSAqIHkgKyBSWzBdWzJdICogeixcblx0XHRDWzFdICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeSArIFJbMV1bMl0gKiB6LFxuXHRcdENbMl0gKyBSWzJdWzBdICogeCArIFJbMl1bMV0gKiB5ICsgUlsyXVsyXSAqIHpcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cdGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0fVxuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgcmVmbGVjdGluZyB0aGUgcG9pbnQgaW4gdGhlIGdpdmVuIHBvaW50LCBsaW5lIG9yIHBsYW5lXG4gICAgcmVmbGVjdGlvbkluOiBmdW5jdGlvbihvYmopIHtcblx0aWYgKG9iai5hbmNob3IpIHtcblx0ICAgIC8vIG9iaiBpcyBhIHBsYW5lIG9yIGxpbmVcblx0ICAgIHZhciBQID0gdGhpcy5lbGVtZW50cy5zbGljZSgpO1xuXHQgICAgdmFyIEMgPSBvYmoucG9pbnRDbG9zZXN0VG8oUCkuZWxlbWVudHM7XG5cdCAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbQ1swXSArIChDWzBdIC0gUFswXSksIENbMV0gKyAoQ1sxXSAtIFBbMV0pLCBDWzJdICsgKENbMl0gLSAoUFsyXSB8fCAwKSldKTtcblx0fSBlbHNlIHtcblx0ICAgIC8vIG9iaiBpcyBhIHBvaW50XG5cdCAgICB2YXIgUSA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG5cdCAgICBpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggIT0gUS5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4LCBpKSB7IHJldHVybiBRW2kgLSAxXSArIChRW2kgLSAxXSAtIHgpOyB9KTtcblx0fVxuICAgIH0sXG5cbiAgICAvLyBVdGlsaXR5IHRvIG1ha2Ugc3VyZSB2ZWN0b3JzIGFyZSAzRC4gSWYgdGhleSBhcmUgMkQsIGEgemVybyB6LWNvbXBvbmVudCBpcyBhZGRlZFxuICAgIHRvM0Q6IGZ1bmN0aW9uKCkge1xuXHR2YXIgViA9IHRoaXMuZHVwKCk7XG5cdHN3aXRjaCAoVi5lbGVtZW50cy5sZW5ndGgpIHtcblx0Y2FzZSAzOiBicmVhaztcblx0Y2FzZSAyOiBWLmVsZW1lbnRzLnB1c2goMCk7IGJyZWFrO1xuXHRkZWZhdWx0OiByZXR1cm4gbnVsbDtcblx0fVxuXHRyZXR1cm4gVjtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gICAgaW5zcGVjdDogZnVuY3Rpb24oKSB7XG5cdHJldHVybiAnWycgKyB0aGlzLmVsZW1lbnRzLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSxcblxuICAgIC8vIFNldCB2ZWN0b3IncyBlbGVtZW50cyBmcm9tIGFuIGFycmF5XG4gICAgc2V0RWxlbWVudHM6IGZ1bmN0aW9uKGVscykge1xuXHR0aGlzLmVsZW1lbnRzID0gKGVscy5lbGVtZW50cyB8fCBlbHMpLnNsaWNlKCk7XG5cdHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG5WZWN0b3IuY3JlYXRlID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICB2YXIgViA9IG5ldyBWZWN0b3IoKTtcbiAgICByZXR1cm4gVi5zZXRFbGVtZW50cyhlbGVtZW50cyk7XG59O1xuXG4vLyBpLCBqLCBrIHVuaXQgdmVjdG9yc1xuVmVjdG9yLmkgPSBWZWN0b3IuY3JlYXRlKFsxLCAwLCAwXSk7XG5WZWN0b3IuaiA9IFZlY3Rvci5jcmVhdGUoWzAsIDEsIDBdKTtcblZlY3Rvci5rID0gVmVjdG9yLmNyZWF0ZShbMCwgMCwgMV0pO1xuXG4vLyBSYW5kb20gdmVjdG9yIG9mIHNpemUgblxuVmVjdG9yLlJhbmRvbSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAobi0tKSB7IGVsZW1lbnRzLnB1c2goTWF0aC5yYW5kb20oKSk7IH1cbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShlbGVtZW50cyk7XG59O1xuXG5WZWN0b3IuRmlsbCA9IGZ1bmN0aW9uKG4sIHYpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAobi0tKSB7IGVsZW1lbnRzLnB1c2godik7IH1cbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShlbGVtZW50cyk7XG59O1xuXG4vLyBWZWN0b3IgZmlsbGVkIHdpdGggemVyb3NcblZlY3Rvci5aZXJvID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBWZWN0b3IuRmlsbChuLCAwKTtcbn07XG5cblZlY3Rvci5PbmUgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIFZlY3Rvci5GaWxsKG4sIDEpO1xufTtcblxuVmVjdG9yLmxvZyA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdi5tYXAoZnVuY3Rpb24oeCkge1xuXHRyZXR1cm4gTWF0aC5sb2coeCk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sylvester/lib/node-sylvester/vector.js\n");

/***/ })

};
;