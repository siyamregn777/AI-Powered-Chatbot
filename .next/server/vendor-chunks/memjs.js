/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/memjs";
exports.ids = ["vendor-chunks/memjs"];
exports.modules = {

/***/ "(rsc)/./node_modules/memjs/lib/memjs/header.js":
/*!************************************************!*\
  !*** ./node_modules/memjs/lib/memjs/header.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// # MemJS Memcache binary protocol header\n\n// fromBuffer converts a serialized header to a JS object.\nexports.fromBuffer = function(headerBuf) {\n  if (!headerBuf) {\n    return {};\n  }\n  return {\n    magic:           headerBuf.readUInt8(0),\n    opcode:          headerBuf.readUInt8(1),\n    keyLength:       headerBuf.readUInt16BE(2),\n    extrasLength:    headerBuf.readUInt8(4),\n    dataType:        headerBuf.readUInt8(5),\n    status:          headerBuf.readUInt16BE(6),\n    totalBodyLength: headerBuf.readUInt32BE(8),\n    opaque:          headerBuf.readUInt32BE(12),\n    cas:             headerBuf.slice(16, 24)\n  };\n};\n\n// toBuffer converts a JS memcache header object to a binary memcache header\nexports.toBuffer = function(header) {\n  var headerBuf = Buffer.alloc(24);\n  headerBuf.fill();\n  headerBuf.writeUInt8(header.magic, 0);\n  headerBuf.writeUInt8(header.opcode, 1);\n  headerBuf.writeUInt16BE(header.keyLength, 2);\n  headerBuf.writeUInt8(header.extrasLength, 4);\n  headerBuf.writeUInt8(header.dataType || 0, 5);\n  headerBuf.writeUInt16BE(header.status || 0, 6);\n  headerBuf.writeUInt32BE(header.totalBodyLength, 8);\n  headerBuf.writeUInt32BE(header.opaque || 0, 12);\n  if (header.cas) {\n    header.cas.copy(headerBuf, 16);\n  } else {\n    headerBuf.fill('\\x00', 16);\n  }\n  return headerBuf;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL2hlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNpeWFtXFxEb2N1bWVudHNcXEFJLVBvd2VyZWQtQ2hhdGJvdFxcbm9kZV9tb2R1bGVzXFxtZW1qc1xcbGliXFxtZW1qc1xcaGVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICMgTWVtSlMgTWVtY2FjaGUgYmluYXJ5IHByb3RvY29sIGhlYWRlclxuXG4vLyBmcm9tQnVmZmVyIGNvbnZlcnRzIGEgc2VyaWFsaXplZCBoZWFkZXIgdG8gYSBKUyBvYmplY3QuXG5leHBvcnRzLmZyb21CdWZmZXIgPSBmdW5jdGlvbihoZWFkZXJCdWYpIHtcbiAgaWYgKCFoZWFkZXJCdWYpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYWdpYzogICAgICAgICAgIGhlYWRlckJ1Zi5yZWFkVUludDgoMCksXG4gICAgb3Bjb2RlOiAgICAgICAgICBoZWFkZXJCdWYucmVhZFVJbnQ4KDEpLFxuICAgIGtleUxlbmd0aDogICAgICAgaGVhZGVyQnVmLnJlYWRVSW50MTZCRSgyKSxcbiAgICBleHRyYXNMZW5ndGg6ICAgIGhlYWRlckJ1Zi5yZWFkVUludDgoNCksXG4gICAgZGF0YVR5cGU6ICAgICAgICBoZWFkZXJCdWYucmVhZFVJbnQ4KDUpLFxuICAgIHN0YXR1czogICAgICAgICAgaGVhZGVyQnVmLnJlYWRVSW50MTZCRSg2KSxcbiAgICB0b3RhbEJvZHlMZW5ndGg6IGhlYWRlckJ1Zi5yZWFkVUludDMyQkUoOCksXG4gICAgb3BhcXVlOiAgICAgICAgICBoZWFkZXJCdWYucmVhZFVJbnQzMkJFKDEyKSxcbiAgICBjYXM6ICAgICAgICAgICAgIGhlYWRlckJ1Zi5zbGljZSgxNiwgMjQpXG4gIH07XG59O1xuXG4vLyB0b0J1ZmZlciBjb252ZXJ0cyBhIEpTIG1lbWNhY2hlIGhlYWRlciBvYmplY3QgdG8gYSBiaW5hcnkgbWVtY2FjaGUgaGVhZGVyXG5leHBvcnRzLnRvQnVmZmVyID0gZnVuY3Rpb24oaGVhZGVyKSB7XG4gIHZhciBoZWFkZXJCdWYgPSBCdWZmZXIuYWxsb2MoMjQpO1xuICBoZWFkZXJCdWYuZmlsbCgpO1xuICBoZWFkZXJCdWYud3JpdGVVSW50OChoZWFkZXIubWFnaWMsIDApO1xuICBoZWFkZXJCdWYud3JpdGVVSW50OChoZWFkZXIub3Bjb2RlLCAxKTtcbiAgaGVhZGVyQnVmLndyaXRlVUludDE2QkUoaGVhZGVyLmtleUxlbmd0aCwgMik7XG4gIGhlYWRlckJ1Zi53cml0ZVVJbnQ4KGhlYWRlci5leHRyYXNMZW5ndGgsIDQpO1xuICBoZWFkZXJCdWYud3JpdGVVSW50OChoZWFkZXIuZGF0YVR5cGUgfHwgMCwgNSk7XG4gIGhlYWRlckJ1Zi53cml0ZVVJbnQxNkJFKGhlYWRlci5zdGF0dXMgfHwgMCwgNik7XG4gIGhlYWRlckJ1Zi53cml0ZVVJbnQzMkJFKGhlYWRlci50b3RhbEJvZHlMZW5ndGgsIDgpO1xuICBoZWFkZXJCdWYud3JpdGVVSW50MzJCRShoZWFkZXIub3BhcXVlIHx8IDAsIDEyKTtcbiAgaWYgKGhlYWRlci5jYXMpIHtcbiAgICBoZWFkZXIuY2FzLmNvcHkoaGVhZGVyQnVmLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyQnVmLmZpbGwoJ1xceDAwJywgMTYpO1xuICB9XG4gIHJldHVybiBoZWFkZXJCdWY7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/memjs/lib/memjs/header.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/memjs/lib/memjs/memjs.js":
/*!***********************************************!*\
  !*** ./node_modules/memjs/lib/memjs/memjs.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// # MemJS Memcache Client\n\nvar errors = (__webpack_require__(/*! ./protocol */ \"(rsc)/./node_modules/memjs/lib/memjs/protocol.js\").errors);\nvar Server = (__webpack_require__(/*! ./server */ \"(rsc)/./node_modules/memjs/lib/memjs/server.js\").Server);\nvar noopSerializer = (__webpack_require__(/*! ./noop-serializer */ \"(rsc)/./node_modules/memjs/lib/memjs/noop-serializer.js\").noopSerializer);\nvar makeRequestBuffer = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\").makeRequestBuffer);\nvar hashCode = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\").hashCode);\nvar merge = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\").merge);\nvar makeExpiration = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\").makeExpiration);\nvar makeAmountInitialAndExpiration = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\").makeAmountInitialAndExpiration);\n\n// Client initializer takes a list of `Server`s and an `options` dictionary.\n// See `Client.create` for details.\nvar Client = function(servers, options) {\n  this.servers = servers;\n  this.seq = 0;\n  this.options = merge(options || {},\n    {failoverTime: 60, retries: 2, retry_delay: 0.2, expires: 0, logger: console});\n\n  this.serializer = this.options.serializer || noopSerializer;\n};\n\n// Creates a new client given an optional config string and optional hash of\n// options. The config string should be of the form:\n//\n//     \"[user:pass@]server1[:11211],[user:pass@]server2[:11211],...\"\n//\n// If the argument is not given, fallback on the `MEMCACHIER_SERVERS` environment\n// variable, `MEMCACHE_SERVERS` environment variable or `\"localhost:11211\"`.\n//\n// The options hash may contain the options:\n//\n// * `retries` - the number of times to retry an operation in lieu of failures\n// (default 2)\n// * `expires` - the default expiration in seconds to use (default 0 - never\n// expire). If `expires` is greater than 30 days (60 x 60 x 24 x 30), it is\n// treated as a UNIX time (number of seconds since January 1, 1970).\n// * `logger` - a logger object that responds to `log(string)` method calls.\n// * `failover` - whether to failover to next server. Defaults to false.\n// * `failoverTime` - how much to wait until retring a failed server. Default\n//                    is 60 seconds.\n//\n//   ~~~~\n//     log(msg1[, msg2[, msg3[...]]])\n//   ~~~~\n//\n//   Defaults to `console`.\n// * `serializer` - the object which will (de)serialize the data. It needs\n//   two public methods: serialize and deserialize. It defaults to the \n//   noopSerializer:\n//\n//   ~~~~\n//   var noopSerializer = {\n//     serialize: function (opcode, value, extras) {\n//       return { value: value, extras: extras };\n//     },\n//     deserialize: function (opcode, value, extras) {\n//       return { value: value, extras: extras };\n//     }\n//   };\n//   ~~~~\n//\n// Or options for the servers including:\n// * `username` and `password` for fallback SASL authentication credentials.\n// * `timeout` in seconds to determine failure for operations. Default is 0.5\n//             seconds.\n// * 'conntimeout' in seconds to connection failure. Default is twice the value\n//                 of `timeout`.\n// * `keepAlive` whether to enable keep-alive functionality. Defaults to false.\n// * `keepAliveDelay` in seconds to the initial delay before the first keepalive\n//                    probe is sent on an idle socket. Defaults is 30 seconds.\nClient.create = function(serversStr, options) {\n  serversStr = serversStr || process.env.MEMCACHIER_SERVERS ||\n                             process.env.MEMCACHE_SERVERS || 'localhost:11211';\n  var serverUris = serversStr.split(',');\n  var servers = serverUris.map(function(uri) {\n    var uriParts = uri.split('@');\n    var hostPort = uriParts[uriParts.length - 1].split(':');\n    var userPass = (uriParts[uriParts.length - 2] || '').split(':');\n    return new Server(hostPort[0], parseInt(hostPort[1] || 11211, 10), userPass[0], userPass[1], options);\n  });\n  return new Client(servers, options);\n};\n\n// An overridable method you can use for determing\n// server selection. Should return the server index\n// in the list of servers on Client#servers.\n// \n//   Example using node-hashring:\n//   ~~~~\n//   const memjs = require('memjs');\n//   const HashRing = require('node-hashring');\n//   const servers = ['localhost:11211', 'localhost:11212'];\n//   // build a map of server addresses to their index in the server list\n//   const serverMap = {};\n//   servers.forEach((server, index) => serverMap[server] = index);\n//   const client = memjs.Client.create(servers.join(','));\n//   // build the hashring\n//   const hashRing = new HashRing(servers);\n//   // override the getServer method\n//   client.getServer = (key) => serverMap[hashRing.findNode(key)];\n//   ~~~~\nClient.prototype.getServer = function(key) {\n  return hashCode(key) % this.servers.length;\n};\n\n// Chooses the server to talk to by hashing the given key.\nClient.prototype.server = function(key) {\n  // mechanisms\n  var total = this.servers.length;\n  var origIdx = total > 1 ? this.getServer(key) : 0;\n  var idx = origIdx;\n  var serv = this.servers[idx];\n  while (serv.wakeupAt &&\n      serv.wakeupAt > Date.now()) {\n    idx = (idx + 1) % total;\n    if (idx === origIdx) {\n      return null;\n    }\n    serv = this.servers[idx];\n  }\n  return serv;\n};\n\n// converts a call into a promise-returning one\nvar promisify = function(command) {\n  return new Promise(function(resolve, reject) {\n    command(function(err, result) {\n      err ? reject(err) : resolve(result);\n    });\n  });\n};\n\n// ## Memcache Commands\n//\n// All commands return their results through a callback passed as the last\n// required argument (some commands, like `Client#set`, take optional arguments\n// after the callback).\n//\n// The callback signature always follows:\n//\n//     callback(err, [arg1[, arg2[, arg3[...]]]])\n//\n// In case of an error the _err_ argument will be non-null and contain the\n// `Error`. A notable exception includes a `Client#get` on a key that doesn't\n// exist. In this case, _err_ will be null, as will the _value and _extras_\n// arguments.\n\n// GET\n//\n// Retrieves the value at the given key in memcache.\n//\n// The callback signature is:\n//\n//     callback(err, value, flags)\n//\n// _value_ and _flags_ are both `Buffer`s. If the key is not found, the\n// callback is invoked with null for both arguments and no error.\nClient.prototype.get = function(key, callback) {\n  var self = this;\n  if(callback === undefined) {\n    return promisify(function(callback) {\n      self.get(key, function(err, value, flags) {\n        callback(err, {value: value, flags: flags});\n      });\n    });\n  }\n  var logger = this.options.logger;\n  this.incrSeq();\n  var request = makeRequestBuffer(0, key, '', '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case  0:\n      if (callback) {\n        var deserialized = self.serializer.deserialize(response.header.opcode, response.val, response.extras);\n        callback(null, deserialized.value, deserialized.extras);\n      }\n      break;\n    case 1:\n      if (callback) { callback(null, null, null); }\n      break;\n    default:\n      var errorMessage = 'MemJS GET: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// SET\n//\n// Sets the given _key_ and _value_ in memcache.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.set = function(key, value, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    if (!options) options = {};\n    return promisify(function(callback) { self.set(key, value, options, function(err, success) { callback(err, success); }); });\n  }\n  var logger = this.options.logger;\n  var expires;\n  if (typeof options === 'function' || typeof callback === 'number') {\n    // OLD: function(key, value, callback, expires)\n    logger.log('MemJS SET: using deprecated call - arguments have changed');\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  logger = this.options.logger;\n  expires = options.expires;\n\n  // TODO: support flags, support version (CAS)\n  this.incrSeq();\n  var expiration = makeExpiration(expires || this.options.expires);\n  var extras = Buffer.concat([Buffer.from('00000000', 'hex'), expiration]);\n\n  var opcode = 1;\n  var serialized = this.serializer.serialize(opcode, value, extras);\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    default:\n      var errorMessage = 'MemJS SET: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// ADD\n//\n// Adds the given _key_ and _value_ to memcache. The operation only succeeds\n// if the key is not already set.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.add = function(key, value, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    if (!options) options = {};\n    return promisify(function(callback) { self.add(key, value, options, function(err, success) { callback(err, success); }); });\n  }\n  var logger = this.options.logger;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, value, callback, expires)\n    logger.log('MemJS ADD: using deprecated call - arguments have changed');\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  logger = this.options.logger;\n  expires = options.expires;\n\n  // TODO: support flags, support version (CAS)\n  this.incrSeq();\n  var expiration = makeExpiration(expires || this.options.expires);\n  var extras = Buffer.concat([Buffer.from('00000000', 'hex'), expiration]);\n\n  var opcode = 2;\n  var serialized = this.serializer.serialize(opcode, value, extras);\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 2:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS ADD: ' + errors[response.header.status];\n      logger.log(errorMessage, false);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// REPLACE\n//\n// Replaces the given _key_ and _value_ to memcache. The operation only succeeds\n// if the key is already present.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.replace = function(key, value, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    if (!options) options = {};\n    return promisify(function(callback) { self.replace(key, value, options, function(err, success) { callback(err, success); }); });\n  }\n  var logger = this.options.logger;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, value, callback, expires)\n    logger.log('MemJS REPLACE: using deprecated call - arguments have changed');\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  logger = this.options.logger;\n  expires = options.expires;\n\n  // TODO: support flags, support version (CAS)\n  this.incrSeq();\n  var expiration = makeExpiration(expires || this.options.expires);\n  var extras = Buffer.concat([Buffer.from('00000000', 'hex'), expiration]);\n\n  var opcode = 3;\n  var serialized = this.serializer.serialize(opcode, value, extras);\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS REPLACE: ' + errors[response.header.status];\n      logger.log(errorMessage, false);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// DELETE\n//\n// Deletes the given _key_ from memcache. The operation only succeeds\n// if the key is already present.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.delete = function(key, callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.delete(key, function(err, success) { callback(err, success); }); });\n  }\n  // TODO: Support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var request = makeRequestBuffer(4, key, '', '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case  0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS DELETE: ' + errors[response.header.status];\n      logger.log(errorMessage, false);\n      if (callback) { callback(new Error(errorMessage), null); }\n    }\n  });\n};\n\n// INCREMENT\n//\n// Increments the given _key_ in memcache.\n//\n// The options dictionary takes:\n// * _initial_: the value for the key if not already present, defaults to 0.\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success, value)\nClient.prototype.increment = function(key, amount, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    return promisify(function(callback) {\n      if (!options) options = {};\n      self.increment(key, amount, options, function(err, success, value) {\n        callback(err, {success: success, value: value});\n      });\n    });\n  }\n  var logger = this.options.logger;\n  var initial;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, amount, callback, expires, initial)\n    logger.log('MemJS INCREMENT: using deprecated call - arguments have changed');\n    initial = arguments[4];\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  logger = this.options.logger;\n  initial = options.initial;\n  expires = options.expires;\n\n  // TODO: support version (CAS)\n  this.incrSeq();\n  initial = initial || 0;\n  expires = expires || this.options.expires;\n  var extras = makeAmountInitialAndExpiration(amount, initial, expires);\n  var request = makeRequestBuffer(5, key, extras, '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      var bufInt = (response.val.readUInt32BE(0) << 8) + response.val.readUInt32BE(4);\n      if (callback) { callback(null, true, bufInt); }\n      break;\n    default:\n      var errorMessage = 'MemJS INCREMENT: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// DECREMENT\n//\n// Decrements the given _key_ in memcache.\n//\n// The options dictionary takes:\n// * _initial_: the value for the key if not already present, defaults to 0.\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success, value)\nClient.prototype.decrement = function(key, amount, options, callback) {\n  if(callback === undefined && typeof options !== 'function') {\n    var self = this;\n    return promisify(function(callback) {\n      self.decrement(key, amount, options, function(err, success, value) {\n        callback(err, {success: success, value: value});\n      });\n    });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  var initial;\n  var expires;\n  if (typeof options === 'function') {\n    // OLD: function(key, amount, callback, expires, initial)\n    logger.log('MemJS DECREMENT: using deprecated call - arguments have changed');\n    initial = arguments[4];\n    expires = callback;\n    callback = options;\n    options = {};\n  }\n\n  // TODO: support version (CAS)\n  logger = this.options.logger;\n  initial = options.initial;\n  expires = options.expires;\n\n  this.incrSeq();\n  initial = initial || 0;\n  expires = expires || this.options.expires;\n  var extras = makeAmountInitialAndExpiration(amount, initial, expires);\n  var request = makeRequestBuffer(6, key, extras, '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      var bufInt = (response.val.readUInt32BE(0) << 8) + response.val.readUInt32BE(4);\n      if (callback) { callback(null, true, bufInt); }\n      break;\n    default:\n      var errorMessage = 'MemJS DECREMENT: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null, null); }\n    }\n  });\n};\n\n// APPEND\n//\n// Append the given _value_ to the value associated with the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.append = function(key, value, callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.append(key, value, function(err, success) { callback(err, success); }); });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var opcode = 0x0E;\n  var serialized = this.serializer.serialize(opcode, value, '');\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS APPEND: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null); }\n    }\n  });\n};\n\n// PREPEND\n//\n// Prepend the given _value_ to the value associated with the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.prepend = function(key, value, callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.prepend(key, value, function(err, success) { callback(err, success); }); });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n\n  var opcode = 0x0E;\n  var serialized = this.serializer.serialize(opcode, value, '');\n  var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS PREPEND: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null); }\n    }\n  });\n};\n\n// TOUCH\n//\n// Touch sets an expiration value, given by _expires_, on the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.touch = function(key, expires, callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.touch(key, expires, function(err, success) { callback(err, success); }); });\n  }\n  // TODO: support version (CAS)\n  var logger = this.options.logger;\n  this.incrSeq();\n  var extras = makeExpiration(expires || this.options.expires);\n  var request = makeRequestBuffer(0x1C, key, extras, '', this.seq);\n  this.perform(key, request, this.seq, function(err, response) {\n    if (err) {\n      if (callback) { callback(err, null); }\n      return;\n    }\n    switch (response.header.status) {\n    case 0:\n      if (callback) { callback(null, true); }\n      break;\n    case 1:\n      if (callback) { callback(null, false); }\n      break;\n    default:\n      var errorMessage = 'MemJS TOUCH: ' + errors[response.header.status];\n      logger.log(errorMessage);\n      if (callback) { callback(new Error(errorMessage), null); }\n    }\n  });\n};\n\n// FLUSH\n//\n// Flushes the cache on each connected server. The callback signature is:\n//\n//     callback(lastErr, results)\n//\n// where _lastErr_ is the last error encountered (or null, in the common case\n// of no errors). _results_ is a dictionary mapping `\"hostname:port\"` to either\n// `true` (if the operation was successful), or an error.\nClient.prototype.flush = function(callback) {\n  if(callback === undefined) {\n    var self = this;\n    return promisify(function(callback) { self.flush(function(err, results) { callback(err, results); }); });\n  }\n  // TODO: support expiration\n  this.incrSeq();\n  var request = makeRequestBuffer(0x08, '', '', '', this.seq);\n  var count   = this.servers.length;\n  var result  = {};\n  var lastErr = null;\n  var i;\n\n  var handleFlush = function(seq, serv) {\n    serv.onResponse(seq, function(/* response */) {\n      count -= 1;\n      result[serv.host + ':' + serv.port] = true;\n      if (callback && count === 0) {\n        callback(lastErr, result);\n      }\n    });\n    serv.onError(seq, function(err) {\n      count -= 1;\n      lastErr = err;\n      result[serv.host + ':' + serv.port] = err;\n      if (callback && count === 0) {\n        callback(lastErr, result);\n      }\n    });\n    serv.write(request);\n  };\n\n  for (i = 0; i < this.servers.length; i++) {\n    handleFlush(this.seq, this.servers[i]);\n  }\n};\n\n// STATS_WITH_KEY\n//\n// Sends a memcache stats command with a key to each connected server. The\n// callback is invoked **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server, stats)\n//\n// _server_ is the `\"hostname:port\"` of the server, and _stats_ is a dictionary\n// mapping the stat name to the value of the statistic as a string.\nClient.prototype.statsWithKey = function(key, callback) {\n  var logger = this.options.logger;\n  this.incrSeq();\n  var request = makeRequestBuffer(0x10, key, '', '', this.seq);\n  var i;\n\n  var handleStats = function(seq, serv) {\n    var result = {};\n    var handle = function(response) {\n      // end of stat responses\n      if (response.header.totalBodyLength === 0) {\n        if (callback) { callback(null, serv.host + ':' + serv.port, result); }\n        return;\n      }\n      // process single stat line response\n      switch (response.header.status) {\n      case  0:\n        result[response.key.toString()] = response.val.toString();\n        break;\n      default:\n        var errorMessage = 'MemJS STATS (' + key + '): ' +\n          errors[response.header.status];\n        logger.log(errorMessage, false);\n        if (callback) {\n          callback(new Error(errorMessage), serv.host + ':' + serv.port, null);\n        }\n      }\n    };\n    handle.quiet = true;\n\n    serv.onResponse(seq, handle);\n    serv.onError(seq, function(err) {\n      if (callback) { callback(err, serv.host + ':' + serv.port, null); }\n    });\n    serv.write(request);\n  };\n\n  for (i = 0; i < this.servers.length; i++) {\n    handleStats(this.seq, this.servers[i]);\n  }\n};\n\n\n// STATS\n//\n// Fetches memcache stats from each connected server. The callback is invoked\n// **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server, stats)\n//\n// _server_ is the `\"hostname:port\"` of the server, and _stats_ is a\n// dictionary mapping the stat name to the value of the statistic as a string.\nClient.prototype.stats = function(callback) {\n  this.statsWithKey('', callback);\n};\n\n// RESET_STATS\n//\n// Reset the statistics each server is keeping back to zero. This doesn't clear\n// stats such as item count, but temporary stats such as total number of\n// connections over time.\n//\n// The callback is invoked **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server)\n//\n// _server_ is the `\"hostname:port\"` of the server.\nClient.prototype.resetStats = function(callback) {\n  this.statsWithKey('reset', callback);\n};\n\n// QUIT\n//\n// Closes the connection to each server, notifying them of this intention. Note\n// that quit can race against already outstanding requests when those requests\n// fail and are retried, leading to the quit command winning and closing the\n// connection before the retries complete.\nClient.prototype.quit = function() {\n  this.incrSeq();\n  // TODO: Nicer perhaps to do QUITQ (0x17) but need a new callback for when\n  // write is done.\n  var request = makeRequestBuffer(0x07, '', '', '', this.seq); // QUIT\n  var serv;\n  var i;\n\n  var handleQuit = function(seq, serv) {\n    serv.onResponse(seq, function(/* response */) {\n      serv.close();\n    });\n    serv.onError(seq, function(/* err */) {\n      serv.close();\n    });\n    serv.write(request);\n  };\n\n  for (i = 0; i < this.servers.length; i++) {\n    serv = this.servers[i];\n    handleQuit(this.seq, serv);\n  }\n};\n\n// CLOSE\n//\n// Closes (abruptly) connections to all the servers.\nClient.prototype.close = function() {\n  var i;\n  for (i = 0; i < this.servers.length; i++) {\n    this.servers[i].close();\n  }\n};\n\n// Perform a generic single response operation (get, set etc) on a server\n// serv: the server to perform the operation on\n// request: a buffer containing the request\n// seq: the sequence number of the operation. It is used to pin the callbacks\n//      to a specific operation and should never change during a `perform`.\n// callback: a callback invoked when a response is received or the request\n//           fails\n// retries: number of times to retry request on failure\nClient.prototype.perform = function(key, request, seq, callback, retries) {\n  var _this = this;\n  var serv = this.server(key);\n  if (!serv) {\n    if (callback) { callback(new Error('No servers available'), null); }\n    return;\n  }\n\n  retries = retries || this.options.retries;\n  var failover = this.options.failover;\n  var failoverTime = this.options.failoverTime;\n  var origRetries = this.options.retries;\n  var logger = this.options.logger;\n  var retry_delay = this.options.retry_delay;\n\n  var responseHandler = function(response) {\n    if (callback) { callback(null, response); }\n  };\n\n  var errorHandler = function(error) {\n    if (--retries > 0) {\n      // Wait for retry_delay\n      setTimeout(function() {\n        _this.perform(key, request, seq, callback, retries);\n      }, 1000 * retry_delay);\n    } else {\n      logger.log('MemJS: Server <' + serv.host + ':' + serv.port +\n                  '> failed after (' + origRetries +\n                  ') retries with error - ' + error.message);\n      if (failover) {\n        serv.wakeupAt = Date.now() + failoverTime * 1000;\n        _this.perform(key, request, seq, callback, origRetries);\n      } else {\n        if (callback) { callback(error, null); }\n      }\n    }\n  };\n\n  serv.onResponse(seq, responseHandler);\n  serv.onError(seq, errorHandler);\n  serv.write(request);\n};\n\n// Increment the seq value\nClient.prototype.incrSeq = function() {\n  this.seq++;\n\n  // Wrap `this.seq` to 32-bits since the field we fit it into is only 32-bits.\n  this.seq &= 0xffffffff;\n};\n\nexports.Client = Client;\nexports.Server = Server;\nexports.Utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\");\nexports.Header = __webpack_require__(/*! ./header */ \"(rsc)/./node_modules/memjs/lib/memjs/header.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL21lbWpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGFBQWEsa0dBQTRCO0FBQ3pDLGFBQWEsOEZBQTBCO0FBQ3ZDLHFCQUFxQix3SEFBMkM7QUFDaEUsd0JBQXdCLHVHQUFvQztBQUM1RCxlQUFlLDhGQUEyQjtBQUMxQyxZQUFZLDJGQUF3QjtBQUNwQyxxQkFBcUIsb0dBQWlDO0FBQ3RELHFDQUFxQyxvSEFBaUQ7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSyw0RUFBNEU7O0FBRWpGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixRQUFRO0FBQ1I7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVEQUF1RCx5QkFBeUIsSUFBSTtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdURBQXVELHlCQUF5QixJQUFJO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJEQUEyRCx5QkFBeUIsSUFBSTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBDQUEwQyx5QkFBeUIsSUFBSTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaURBQWlELHlCQUF5QixJQUFJO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFrRCx5QkFBeUIsSUFBSTtBQUN6SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQWtELHlCQUF5QixJQUFJO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0NBQW9DLHlCQUF5QixJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixLQUFLO0FBQ0w7QUFDQTs7QUFFQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxjQUFjO0FBQ2QsbUdBQWtDO0FBQ2xDLHNHQUFvQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzaXlhbVxcRG9jdW1lbnRzXFxBSS1Qb3dlcmVkLUNoYXRib3RcXG5vZGVfbW9kdWxlc1xcbWVtanNcXGxpYlxcbWVtanNcXG1lbWpzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICMgTWVtSlMgTWVtY2FjaGUgQ2xpZW50XG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL3Byb3RvY29sJykuZXJyb3JzO1xudmFyIFNlcnZlciA9IHJlcXVpcmUoJy4vc2VydmVyJykuU2VydmVyO1xudmFyIG5vb3BTZXJpYWxpemVyID0gcmVxdWlyZSgnLi9ub29wLXNlcmlhbGl6ZXInKS5ub29wU2VyaWFsaXplcjtcbnZhciBtYWtlUmVxdWVzdEJ1ZmZlciA9IHJlcXVpcmUoJy4vdXRpbHMnKS5tYWtlUmVxdWVzdEJ1ZmZlcjtcbnZhciBoYXNoQ29kZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5oYXNoQ29kZTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5tZXJnZTtcbnZhciBtYWtlRXhwaXJhdGlvbiA9IHJlcXVpcmUoJy4vdXRpbHMnKS5tYWtlRXhwaXJhdGlvbjtcbnZhciBtYWtlQW1vdW50SW5pdGlhbEFuZEV4cGlyYXRpb24gPSByZXF1aXJlKCcuL3V0aWxzJykubWFrZUFtb3VudEluaXRpYWxBbmRFeHBpcmF0aW9uO1xuXG4vLyBDbGllbnQgaW5pdGlhbGl6ZXIgdGFrZXMgYSBsaXN0IG9mIGBTZXJ2ZXJgcyBhbmQgYW4gYG9wdGlvbnNgIGRpY3Rpb25hcnkuXG4vLyBTZWUgYENsaWVudC5jcmVhdGVgIGZvciBkZXRhaWxzLlxudmFyIENsaWVudCA9IGZ1bmN0aW9uKHNlcnZlcnMsIG9wdGlvbnMpIHtcbiAgdGhpcy5zZXJ2ZXJzID0gc2VydmVycztcbiAgdGhpcy5zZXEgPSAwO1xuICB0aGlzLm9wdGlvbnMgPSBtZXJnZShvcHRpb25zIHx8IHt9LFxuICAgIHtmYWlsb3ZlclRpbWU6IDYwLCByZXRyaWVzOiAyLCByZXRyeV9kZWxheTogMC4yLCBleHBpcmVzOiAwLCBsb2dnZXI6IGNvbnNvbGV9KTtcblxuICB0aGlzLnNlcmlhbGl6ZXIgPSB0aGlzLm9wdGlvbnMuc2VyaWFsaXplciB8fCBub29wU2VyaWFsaXplcjtcbn07XG5cbi8vIENyZWF0ZXMgYSBuZXcgY2xpZW50IGdpdmVuIGFuIG9wdGlvbmFsIGNvbmZpZyBzdHJpbmcgYW5kIG9wdGlvbmFsIGhhc2ggb2Zcbi8vIG9wdGlvbnMuIFRoZSBjb25maWcgc3RyaW5nIHNob3VsZCBiZSBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAgXCJbdXNlcjpwYXNzQF1zZXJ2ZXIxWzoxMTIxMV0sW3VzZXI6cGFzc0Bdc2VydmVyMls6MTEyMTFdLC4uLlwiXG4vL1xuLy8gSWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgZmFsbGJhY2sgb24gdGhlIGBNRU1DQUNISUVSX1NFUlZFUlNgIGVudmlyb25tZW50XG4vLyB2YXJpYWJsZSwgYE1FTUNBQ0hFX1NFUlZFUlNgIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIGBcImxvY2FsaG9zdDoxMTIxMVwiYC5cbi8vXG4vLyBUaGUgb3B0aW9ucyBoYXNoIG1heSBjb250YWluIHRoZSBvcHRpb25zOlxuLy9cbi8vICogYHJldHJpZXNgIC0gdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBhbiBvcGVyYXRpb24gaW4gbGlldSBvZiBmYWlsdXJlc1xuLy8gKGRlZmF1bHQgMilcbi8vICogYGV4cGlyZXNgIC0gdGhlIGRlZmF1bHQgZXhwaXJhdGlvbiBpbiBzZWNvbmRzIHRvIHVzZSAoZGVmYXVsdCAwIC0gbmV2ZXJcbi8vIGV4cGlyZSkuIElmIGBleHBpcmVzYCBpcyBncmVhdGVyIHRoYW4gMzAgZGF5cyAoNjAgeCA2MCB4IDI0IHggMzApLCBpdCBpc1xuLy8gdHJlYXRlZCBhcyBhIFVOSVggdGltZSAobnVtYmVyIG9mIHNlY29uZHMgc2luY2UgSmFudWFyeSAxLCAxOTcwKS5cbi8vICogYGxvZ2dlcmAgLSBhIGxvZ2dlciBvYmplY3QgdGhhdCByZXNwb25kcyB0byBgbG9nKHN0cmluZylgIG1ldGhvZCBjYWxscy5cbi8vICogYGZhaWxvdmVyYCAtIHdoZXRoZXIgdG8gZmFpbG92ZXIgdG8gbmV4dCBzZXJ2ZXIuIERlZmF1bHRzIHRvIGZhbHNlLlxuLy8gKiBgZmFpbG92ZXJUaW1lYCAtIGhvdyBtdWNoIHRvIHdhaXQgdW50aWwgcmV0cmluZyBhIGZhaWxlZCBzZXJ2ZXIuIERlZmF1bHRcbi8vICAgICAgICAgICAgICAgICAgICBpcyA2MCBzZWNvbmRzLlxuLy9cbi8vICAgfn5+flxuLy8gICAgIGxvZyhtc2cxWywgbXNnMlssIG1zZzNbLi4uXV1dKVxuLy8gICB+fn5+XG4vL1xuLy8gICBEZWZhdWx0cyB0byBgY29uc29sZWAuXG4vLyAqIGBzZXJpYWxpemVyYCAtIHRoZSBvYmplY3Qgd2hpY2ggd2lsbCAoZGUpc2VyaWFsaXplIHRoZSBkYXRhLiBJdCBuZWVkc1xuLy8gICB0d28gcHVibGljIG1ldGhvZHM6IHNlcmlhbGl6ZSBhbmQgZGVzZXJpYWxpemUuIEl0IGRlZmF1bHRzIHRvIHRoZSBcbi8vICAgbm9vcFNlcmlhbGl6ZXI6XG4vL1xuLy8gICB+fn5+XG4vLyAgIHZhciBub29wU2VyaWFsaXplciA9IHtcbi8vICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIChvcGNvZGUsIHZhbHVlLCBleHRyYXMpIHtcbi8vICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZXh0cmFzOiBleHRyYXMgfTtcbi8vICAgICB9LFxuLy8gICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAob3Bjb2RlLCB2YWx1ZSwgZXh0cmFzKSB7XG4vLyAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGV4dHJhczogZXh0cmFzIH07XG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICB+fn5+XG4vL1xuLy8gT3Igb3B0aW9ucyBmb3IgdGhlIHNlcnZlcnMgaW5jbHVkaW5nOlxuLy8gKiBgdXNlcm5hbWVgIGFuZCBgcGFzc3dvcmRgIGZvciBmYWxsYmFjayBTQVNMIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzLlxuLy8gKiBgdGltZW91dGAgaW4gc2Vjb25kcyB0byBkZXRlcm1pbmUgZmFpbHVyZSBmb3Igb3BlcmF0aW9ucy4gRGVmYXVsdCBpcyAwLjVcbi8vICAgICAgICAgICAgIHNlY29uZHMuXG4vLyAqICdjb25udGltZW91dCcgaW4gc2Vjb25kcyB0byBjb25uZWN0aW9uIGZhaWx1cmUuIERlZmF1bHQgaXMgdHdpY2UgdGhlIHZhbHVlXG4vLyAgICAgICAgICAgICAgICAgb2YgYHRpbWVvdXRgLlxuLy8gKiBga2VlcEFsaXZlYCB3aGV0aGVyIHRvIGVuYWJsZSBrZWVwLWFsaXZlIGZ1bmN0aW9uYWxpdHkuIERlZmF1bHRzIHRvIGZhbHNlLlxuLy8gKiBga2VlcEFsaXZlRGVsYXlgIGluIHNlY29uZHMgdG8gdGhlIGluaXRpYWwgZGVsYXkgYmVmb3JlIHRoZSBmaXJzdCBrZWVwYWxpdmVcbi8vICAgICAgICAgICAgICAgICAgICBwcm9iZSBpcyBzZW50IG9uIGFuIGlkbGUgc29ja2V0LiBEZWZhdWx0cyBpcyAzMCBzZWNvbmRzLlxuQ2xpZW50LmNyZWF0ZSA9IGZ1bmN0aW9uKHNlcnZlcnNTdHIsIG9wdGlvbnMpIHtcbiAgc2VydmVyc1N0ciA9IHNlcnZlcnNTdHIgfHwgcHJvY2Vzcy5lbnYuTUVNQ0FDSElFUl9TRVJWRVJTIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk1FTUNBQ0hFX1NFUlZFUlMgfHwgJ2xvY2FsaG9zdDoxMTIxMSc7XG4gIHZhciBzZXJ2ZXJVcmlzID0gc2VydmVyc1N0ci5zcGxpdCgnLCcpO1xuICB2YXIgc2VydmVycyA9IHNlcnZlclVyaXMubWFwKGZ1bmN0aW9uKHVyaSkge1xuICAgIHZhciB1cmlQYXJ0cyA9IHVyaS5zcGxpdCgnQCcpO1xuICAgIHZhciBob3N0UG9ydCA9IHVyaVBhcnRzW3VyaVBhcnRzLmxlbmd0aCAtIDFdLnNwbGl0KCc6Jyk7XG4gICAgdmFyIHVzZXJQYXNzID0gKHVyaVBhcnRzW3VyaVBhcnRzLmxlbmd0aCAtIDJdIHx8ICcnKS5zcGxpdCgnOicpO1xuICAgIHJldHVybiBuZXcgU2VydmVyKGhvc3RQb3J0WzBdLCBwYXJzZUludChob3N0UG9ydFsxXSB8fCAxMTIxMSwgMTApLCB1c2VyUGFzc1swXSwgdXNlclBhc3NbMV0sIG9wdGlvbnMpO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBDbGllbnQoc2VydmVycywgb3B0aW9ucyk7XG59O1xuXG4vLyBBbiBvdmVycmlkYWJsZSBtZXRob2QgeW91IGNhbiB1c2UgZm9yIGRldGVybWluZ1xuLy8gc2VydmVyIHNlbGVjdGlvbi4gU2hvdWxkIHJldHVybiB0aGUgc2VydmVyIGluZGV4XG4vLyBpbiB0aGUgbGlzdCBvZiBzZXJ2ZXJzIG9uIENsaWVudCNzZXJ2ZXJzLlxuLy8gXG4vLyAgIEV4YW1wbGUgdXNpbmcgbm9kZS1oYXNocmluZzpcbi8vICAgfn5+flxuLy8gICBjb25zdCBtZW1qcyA9IHJlcXVpcmUoJ21lbWpzJyk7XG4vLyAgIGNvbnN0IEhhc2hSaW5nID0gcmVxdWlyZSgnbm9kZS1oYXNocmluZycpO1xuLy8gICBjb25zdCBzZXJ2ZXJzID0gWydsb2NhbGhvc3Q6MTEyMTEnLCAnbG9jYWxob3N0OjExMjEyJ107XG4vLyAgIC8vIGJ1aWxkIGEgbWFwIG9mIHNlcnZlciBhZGRyZXNzZXMgdG8gdGhlaXIgaW5kZXggaW4gdGhlIHNlcnZlciBsaXN0XG4vLyAgIGNvbnN0IHNlcnZlck1hcCA9IHt9O1xuLy8gICBzZXJ2ZXJzLmZvckVhY2goKHNlcnZlciwgaW5kZXgpID0+IHNlcnZlck1hcFtzZXJ2ZXJdID0gaW5kZXgpO1xuLy8gICBjb25zdCBjbGllbnQgPSBtZW1qcy5DbGllbnQuY3JlYXRlKHNlcnZlcnMuam9pbignLCcpKTtcbi8vICAgLy8gYnVpbGQgdGhlIGhhc2hyaW5nXG4vLyAgIGNvbnN0IGhhc2hSaW5nID0gbmV3IEhhc2hSaW5nKHNlcnZlcnMpO1xuLy8gICAvLyBvdmVycmlkZSB0aGUgZ2V0U2VydmVyIG1ldGhvZFxuLy8gICBjbGllbnQuZ2V0U2VydmVyID0gKGtleSkgPT4gc2VydmVyTWFwW2hhc2hSaW5nLmZpbmROb2RlKGtleSldO1xuLy8gICB+fn5+XG5DbGllbnQucHJvdG90eXBlLmdldFNlcnZlciA9IGZ1bmN0aW9uKGtleSkge1xuICByZXR1cm4gaGFzaENvZGUoa2V5KSAlIHRoaXMuc2VydmVycy5sZW5ndGg7XG59O1xuXG4vLyBDaG9vc2VzIHRoZSBzZXJ2ZXIgdG8gdGFsayB0byBieSBoYXNoaW5nIHRoZSBnaXZlbiBrZXkuXG5DbGllbnQucHJvdG90eXBlLnNlcnZlciA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBtZWNoYW5pc21zXG4gIHZhciB0b3RhbCA9IHRoaXMuc2VydmVycy5sZW5ndGg7XG4gIHZhciBvcmlnSWR4ID0gdG90YWwgPiAxID8gdGhpcy5nZXRTZXJ2ZXIoa2V5KSA6IDA7XG4gIHZhciBpZHggPSBvcmlnSWR4O1xuICB2YXIgc2VydiA9IHRoaXMuc2VydmVyc1tpZHhdO1xuICB3aGlsZSAoc2Vydi53YWtldXBBdCAmJlxuICAgICAgc2Vydi53YWtldXBBdCA+IERhdGUubm93KCkpIHtcbiAgICBpZHggPSAoaWR4ICsgMSkgJSB0b3RhbDtcbiAgICBpZiAoaWR4ID09PSBvcmlnSWR4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VydiA9IHRoaXMuc2VydmVyc1tpZHhdO1xuICB9XG4gIHJldHVybiBzZXJ2O1xufTtcblxuLy8gY29udmVydHMgYSBjYWxsIGludG8gYSBwcm9taXNlLXJldHVybmluZyBvbmVcbnZhciBwcm9taXNpZnkgPSBmdW5jdGlvbihjb21tYW5kKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjb21tYW5kKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzdWx0KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vLyAjIyBNZW1jYWNoZSBDb21tYW5kc1xuLy9cbi8vIEFsbCBjb21tYW5kcyByZXR1cm4gdGhlaXIgcmVzdWx0cyB0aHJvdWdoIGEgY2FsbGJhY2sgcGFzc2VkIGFzIHRoZSBsYXN0XG4vLyByZXF1aXJlZCBhcmd1bWVudCAoc29tZSBjb21tYW5kcywgbGlrZSBgQ2xpZW50I3NldGAsIHRha2Ugb3B0aW9uYWwgYXJndW1lbnRzXG4vLyBhZnRlciB0aGUgY2FsbGJhY2spLlxuLy9cbi8vIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgYWx3YXlzIGZvbGxvd3M6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgW2FyZzFbLCBhcmcyWywgYXJnM1suLi5dXV1dKVxuLy9cbi8vIEluIGNhc2Ugb2YgYW4gZXJyb3IgdGhlIF9lcnJfIGFyZ3VtZW50IHdpbGwgYmUgbm9uLW51bGwgYW5kIGNvbnRhaW4gdGhlXG4vLyBgRXJyb3JgLiBBIG5vdGFibGUgZXhjZXB0aW9uIGluY2x1ZGVzIGEgYENsaWVudCNnZXRgIG9uIGEga2V5IHRoYXQgZG9lc24ndFxuLy8gZXhpc3QuIEluIHRoaXMgY2FzZSwgX2Vycl8gd2lsbCBiZSBudWxsLCBhcyB3aWxsIHRoZSBfdmFsdWUgYW5kIF9leHRyYXNfXG4vLyBhcmd1bWVudHMuXG5cbi8vIEdFVFxuLy9cbi8vIFJldHJpZXZlcyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGtleSBpbiBtZW1jYWNoZS5cbi8vXG4vLyBUaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuLy9cbi8vICAgICBjYWxsYmFjayhlcnIsIHZhbHVlLCBmbGFncylcbi8vXG4vLyBfdmFsdWVfIGFuZCBfZmxhZ3NfIGFyZSBib3RoIGBCdWZmZXJgcy4gSWYgdGhlIGtleSBpcyBub3QgZm91bmQsIHRoZVxuLy8gY2FsbGJhY2sgaXMgaW52b2tlZCB3aXRoIG51bGwgZm9yIGJvdGggYXJndW1lbnRzIGFuZCBubyBlcnJvci5cbkNsaWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvbWlzaWZ5KGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBzZWxmLmdldChrZXksIGZ1bmN0aW9uKGVyciwgdmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwge3ZhbHVlOiB2YWx1ZSwgZmxhZ3M6IGZsYWdzfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB2YXIgbG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlcjtcbiAgdGhpcy5pbmNyU2VxKCk7XG4gIHZhciByZXF1ZXN0ID0gbWFrZVJlcXVlc3RCdWZmZXIoMCwga2V5LCAnJywgJycsIHRoaXMuc2VxKTtcbiAgdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgdGhpcy5zZXEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBudWxsLCBudWxsKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICBjYXNlICAwOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZXNlcmlhbGl6ZWQgPSBzZWxmLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVzcG9uc2UuaGVhZGVyLm9wY29kZSwgcmVzcG9uc2UudmFsLCByZXNwb25zZS5leHRyYXMpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBkZXNlcmlhbGl6ZWQudmFsdWUsIGRlc2VyaWFsaXplZC5leHRyYXMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIG51bGwsIG51bGwpOyB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9ICdNZW1KUyBHRVQ6ICcgKyBlcnJvcnNbcmVzcG9uc2UuaGVhZGVyLnN0YXR1c107XG4gICAgICBsb2dnZXIubG9nKGVycm9yTWVzc2FnZSk7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobmV3IEVycm9yKGVycm9yTWVzc2FnZSksIG51bGwsIG51bGwpOyB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFNFVFxuLy9cbi8vIFNldHMgdGhlIGdpdmVuIF9rZXlfIGFuZCBfdmFsdWVfIGluIG1lbWNhY2hlLlxuLy9cbi8vIFRoZSBvcHRpb25zIGRpY3Rpb25hcnkgdGFrZXM6XG4vLyAqIF9leHBpcmVzXzogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGV4cGlyYXRpb24gKHNlZSBgQ2xpZW50LmNyZWF0ZWApIGZvciB0aGlzXG4vLyAgICAgICAgICAgICAgcGFydGljdWxhciBrZXktdmFsdWUgcGFpci5cbi8vXG4vLyBUaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuLy9cbi8vICAgICBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpXG5DbGllbnQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgcmV0dXJuIHByb21pc2lmeShmdW5jdGlvbihjYWxsYmFjaykgeyBzZWxmLnNldChrZXksIHZhbHVlLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIHN1Y2Nlc3MpIHsgY2FsbGJhY2soZXJyLCBzdWNjZXNzKTsgfSk7IH0pO1xuICB9XG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB2YXIgZXhwaXJlcztcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBPTEQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGNhbGxiYWNrLCBleHBpcmVzKVxuICAgIGxvZ2dlci5sb2coJ01lbUpTIFNFVDogdXNpbmcgZGVwcmVjYXRlZCBjYWxsIC0gYXJndW1lbnRzIGhhdmUgY2hhbmdlZCcpO1xuICAgIGV4cGlyZXMgPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgbG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlcjtcbiAgZXhwaXJlcyA9IG9wdGlvbnMuZXhwaXJlcztcblxuICAvLyBUT0RPOiBzdXBwb3J0IGZsYWdzLCBzdXBwb3J0IHZlcnNpb24gKENBUylcbiAgdGhpcy5pbmNyU2VxKCk7XG4gIHZhciBleHBpcmF0aW9uID0gbWFrZUV4cGlyYXRpb24oZXhwaXJlcyB8fCB0aGlzLm9wdGlvbnMuZXhwaXJlcyk7XG4gIHZhciBleHRyYXMgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnMDAwMDAwMDAnLCAnaGV4JyksIGV4cGlyYXRpb25dKTtcblxuICB2YXIgb3Bjb2RlID0gMTtcbiAgdmFyIHNlcmlhbGl6ZWQgPSB0aGlzLnNlcmlhbGl6ZXIuc2VyaWFsaXplKG9wY29kZSwgdmFsdWUsIGV4dHJhcyk7XG4gIHZhciByZXF1ZXN0ID0gbWFrZVJlcXVlc3RCdWZmZXIob3Bjb2RlLCBrZXksIHNlcmlhbGl6ZWQuZXh0cmFzLCBzZXJpYWxpemVkLnZhbHVlLCB0aGlzLnNlcSk7XG4gIHRoaXMucGVyZm9ybShrZXksIHJlcXVlc3QsIHRoaXMuc2VxLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGVyciwgbnVsbCk7IH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChyZXNwb25zZS5oZWFkZXIuc3RhdHVzKSB7XG4gICAgY2FzZSAwOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIHRydWUpOyB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9ICdNZW1KUyBTRVQ6ICcgKyBlcnJvcnNbcmVzcG9uc2UuaGVhZGVyLnN0YXR1c107XG4gICAgICBsb2dnZXIubG9nKGVycm9yTWVzc2FnZSk7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobmV3IEVycm9yKGVycm9yTWVzc2FnZSksIG51bGwsIG51bGwpOyB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIEFERFxuLy9cbi8vIEFkZHMgdGhlIGdpdmVuIF9rZXlfIGFuZCBfdmFsdWVfIHRvIG1lbWNhY2hlLiBUaGUgb3BlcmF0aW9uIG9ubHkgc3VjY2VlZHNcbi8vIGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0LlxuLy9cbi8vIFRoZSBvcHRpb25zIGRpY3Rpb25hcnkgdGFrZXM6XG4vLyAqIF9leHBpcmVzXzogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGV4cGlyYXRpb24gKHNlZSBgQ2xpZW50LmNyZWF0ZWApIGZvciB0aGlzXG4vLyAgICAgICAgICAgICAgcGFydGljdWxhciBrZXktdmFsdWUgcGFpci5cbi8vXG4vLyBUaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuLy9cbi8vICAgICBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpXG5DbGllbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgcmV0dXJuIHByb21pc2lmeShmdW5jdGlvbihjYWxsYmFjaykgeyBzZWxmLmFkZChrZXksIHZhbHVlLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIHN1Y2Nlc3MpIHsgY2FsbGJhY2soZXJyLCBzdWNjZXNzKTsgfSk7IH0pO1xuICB9XG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB2YXIgZXhwaXJlcztcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gT0xEOiBmdW5jdGlvbihrZXksIHZhbHVlLCBjYWxsYmFjaywgZXhwaXJlcylcbiAgICBsb2dnZXIubG9nKCdNZW1KUyBBREQ6IHVzaW5nIGRlcHJlY2F0ZWQgY2FsbCAtIGFyZ3VtZW50cyBoYXZlIGNoYW5nZWQnKTtcbiAgICBleHBpcmVzID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIGV4cGlyZXMgPSBvcHRpb25zLmV4cGlyZXM7XG5cbiAgLy8gVE9ETzogc3VwcG9ydCBmbGFncywgc3VwcG9ydCB2ZXJzaW9uIChDQVMpXG4gIHRoaXMuaW5jclNlcSgpO1xuICB2YXIgZXhwaXJhdGlvbiA9IG1ha2VFeHBpcmF0aW9uKGV4cGlyZXMgfHwgdGhpcy5vcHRpb25zLmV4cGlyZXMpO1xuICB2YXIgZXh0cmFzID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oJzAwMDAwMDAwJywgJ2hleCcpLCBleHBpcmF0aW9uXSk7XG5cbiAgdmFyIG9wY29kZSA9IDI7XG4gIHZhciBzZXJpYWxpemVkID0gdGhpcy5zZXJpYWxpemVyLnNlcmlhbGl6ZShvcGNvZGUsIHZhbHVlLCBleHRyYXMpO1xuICB2YXIgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0QnVmZmVyKG9wY29kZSwga2V5LCBzZXJpYWxpemVkLmV4dHJhcywgc2VyaWFsaXplZC52YWx1ZSwgdGhpcy5zZXEpO1xuICB0aGlzLnBlcmZvcm0oa2V5LCByZXF1ZXN0LCB0aGlzLnNlcSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIG51bGwsIG51bGwpOyB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cykge1xuICAgIGNhc2UgMDpcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCB0cnVlKTsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIGZhbHNlKTsgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnTWVtSlMgQUREOiAnICsgZXJyb3JzW3Jlc3BvbnNlLmhlYWRlci5zdGF0dXNdO1xuICAgICAgbG9nZ2VyLmxvZyhlcnJvck1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgbnVsbCwgbnVsbCk7IH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gUkVQTEFDRVxuLy9cbi8vIFJlcGxhY2VzIHRoZSBnaXZlbiBfa2V5XyBhbmQgX3ZhbHVlXyB0byBtZW1jYWNoZS4gVGhlIG9wZXJhdGlvbiBvbmx5IHN1Y2NlZWRzXG4vLyBpZiB0aGUga2V5IGlzIGFscmVhZHkgcHJlc2VudC5cbi8vXG4vLyBUaGUgb3B0aW9ucyBkaWN0aW9uYXJ5IHRha2VzOlxuLy8gKiBfZXhwaXJlc186IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBleHBpcmF0aW9uIChzZWUgYENsaWVudC5jcmVhdGVgKSBmb3IgdGhpc1xuLy8gICAgICAgICAgICAgIHBhcnRpY3VsYXIga2V5LXZhbHVlIHBhaXIuXG4vL1xuLy8gVGhlIGNhbGxiYWNrIHNpZ25hdHVyZSBpczpcbi8vXG4vLyAgICAgY2FsbGJhY2soZXJyLCBzdWNjZXNzKVxuQ2xpZW50LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICByZXR1cm4gcHJvbWlzaWZ5KGZ1bmN0aW9uKGNhbGxiYWNrKSB7IHNlbGYucmVwbGFjZShrZXksIHZhbHVlLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIHN1Y2Nlc3MpIHsgY2FsbGJhY2soZXJyLCBzdWNjZXNzKTsgfSk7IH0pO1xuICB9XG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB2YXIgZXhwaXJlcztcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gT0xEOiBmdW5jdGlvbihrZXksIHZhbHVlLCBjYWxsYmFjaywgZXhwaXJlcylcbiAgICBsb2dnZXIubG9nKCdNZW1KUyBSRVBMQUNFOiB1c2luZyBkZXByZWNhdGVkIGNhbGwgLSBhcmd1bWVudHMgaGF2ZSBjaGFuZ2VkJyk7XG4gICAgZXhwaXJlcyA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICBleHBpcmVzID0gb3B0aW9ucy5leHBpcmVzO1xuXG4gIC8vIFRPRE86IHN1cHBvcnQgZmxhZ3MsIHN1cHBvcnQgdmVyc2lvbiAoQ0FTKVxuICB0aGlzLmluY3JTZXEoKTtcbiAgdmFyIGV4cGlyYXRpb24gPSBtYWtlRXhwaXJhdGlvbihleHBpcmVzIHx8IHRoaXMub3B0aW9ucy5leHBpcmVzKTtcbiAgdmFyIGV4dHJhcyA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCcwMDAwMDAwMCcsICdoZXgnKSwgZXhwaXJhdGlvbl0pO1xuXG4gIHZhciBvcGNvZGUgPSAzO1xuICB2YXIgc2VyaWFsaXplZCA9IHRoaXMuc2VyaWFsaXplci5zZXJpYWxpemUob3Bjb2RlLCB2YWx1ZSwgZXh0cmFzKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcihvcGNvZGUsIGtleSwgc2VyaWFsaXplZC5leHRyYXMsIHNlcmlhbGl6ZWQudmFsdWUsIHRoaXMuc2VxKTtcbiAgdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgdGhpcy5zZXEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBudWxsLCBudWxsKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICBjYXNlIDA6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCBmYWxzZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIFJFUExBQ0U6ICcgKyBlcnJvcnNbcmVzcG9uc2UuaGVhZGVyLnN0YXR1c107XG4gICAgICBsb2dnZXIubG9nKGVycm9yTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCBudWxsLCBudWxsKTsgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBERUxFVEVcbi8vXG4vLyBEZWxldGVzIHRoZSBnaXZlbiBfa2V5XyBmcm9tIG1lbWNhY2hlLiBUaGUgb3BlcmF0aW9uIG9ubHkgc3VjY2VlZHNcbi8vIGlmIHRoZSBrZXkgaXMgYWxyZWFkeSBwcmVzZW50LlxuLy9cbi8vIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgc3VjY2VzcylcbkNsaWVudC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICBpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBwcm9taXNpZnkoZnVuY3Rpb24oY2FsbGJhY2spIHsgc2VsZi5kZWxldGUoa2V5LCBmdW5jdGlvbihlcnIsIHN1Y2Nlc3MpIHsgY2FsbGJhY2soZXJyLCBzdWNjZXNzKTsgfSk7IH0pO1xuICB9XG4gIC8vIFRPRE86IFN1cHBvcnQgdmVyc2lvbiAoQ0FTKVxuICB2YXIgbG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlcjtcbiAgdGhpcy5pbmNyU2VxKCk7XG4gIHZhciByZXF1ZXN0ID0gbWFrZVJlcXVlc3RCdWZmZXIoNCwga2V5LCAnJywgJycsIHRoaXMuc2VxKTtcbiAgdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgdGhpcy5zZXEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBudWxsLCBudWxsKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICBjYXNlICAwOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIHRydWUpOyB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgZmFsc2UpOyB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9ICdNZW1KUyBERUxFVEU6ICcgKyBlcnJvcnNbcmVzcG9uc2UuaGVhZGVyLnN0YXR1c107XG4gICAgICBsb2dnZXIubG9nKGVycm9yTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCBudWxsKTsgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBJTkNSRU1FTlRcbi8vXG4vLyBJbmNyZW1lbnRzIHRoZSBnaXZlbiBfa2V5XyBpbiBtZW1jYWNoZS5cbi8vXG4vLyBUaGUgb3B0aW9ucyBkaWN0aW9uYXJ5IHRha2VzOlxuLy8gKiBfaW5pdGlhbF86IHRoZSB2YWx1ZSBmb3IgdGhlIGtleSBpZiBub3QgYWxyZWFkeSBwcmVzZW50LCBkZWZhdWx0cyB0byAwLlxuLy8gKiBfZXhwaXJlc186IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBleHBpcmF0aW9uIChzZWUgYENsaWVudC5jcmVhdGVgKSBmb3IgdGhpc1xuLy8gICAgICAgICAgICAgIHBhcnRpY3VsYXIga2V5LXZhbHVlIHBhaXIuXG4vL1xuLy8gVGhlIGNhbGxiYWNrIHNpZ25hdHVyZSBpczpcbi8vXG4vLyAgICAgY2FsbGJhY2soZXJyLCBzdWNjZXNzLCB2YWx1ZSlcbkNsaWVudC5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24oa2V5LCBhbW91bnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHByb21pc2lmeShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgICBzZWxmLmluY3JlbWVudChrZXksIGFtb3VudCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBzdWNjZXNzLCB2YWx1ZSkge1xuICAgICAgICBjYWxsYmFjayhlcnIsIHtzdWNjZXNzOiBzdWNjZXNzLCB2YWx1ZTogdmFsdWV9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB2YXIgaW5pdGlhbDtcbiAgdmFyIGV4cGlyZXM7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIE9MRDogZnVuY3Rpb24oa2V5LCBhbW91bnQsIGNhbGxiYWNrLCBleHBpcmVzLCBpbml0aWFsKVxuICAgIGxvZ2dlci5sb2coJ01lbUpTIElOQ1JFTUVOVDogdXNpbmcgZGVwcmVjYXRlZCBjYWxsIC0gYXJndW1lbnRzIGhhdmUgY2hhbmdlZCcpO1xuICAgIGluaXRpYWwgPSBhcmd1bWVudHNbNF07XG4gICAgZXhwaXJlcyA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICBpbml0aWFsID0gb3B0aW9ucy5pbml0aWFsO1xuICBleHBpcmVzID0gb3B0aW9ucy5leHBpcmVzO1xuXG4gIC8vIFRPRE86IHN1cHBvcnQgdmVyc2lvbiAoQ0FTKVxuICB0aGlzLmluY3JTZXEoKTtcbiAgaW5pdGlhbCA9IGluaXRpYWwgfHwgMDtcbiAgZXhwaXJlcyA9IGV4cGlyZXMgfHwgdGhpcy5vcHRpb25zLmV4cGlyZXM7XG4gIHZhciBleHRyYXMgPSBtYWtlQW1vdW50SW5pdGlhbEFuZEV4cGlyYXRpb24oYW1vdW50LCBpbml0aWFsLCBleHBpcmVzKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcig1LCBrZXksIGV4dHJhcywgJycsIHRoaXMuc2VxKTtcbiAgdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgdGhpcy5zZXEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBudWxsKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICBjYXNlIDA6XG4gICAgICB2YXIgYnVmSW50ID0gKHJlc3BvbnNlLnZhbC5yZWFkVUludDMyQkUoMCkgPDwgOCkgKyByZXNwb25zZS52YWwucmVhZFVJbnQzMkJFKDQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIHRydWUsIGJ1ZkludCk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIElOQ1JFTUVOVDogJyArIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgIGxvZ2dlci5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgbnVsbCwgbnVsbCk7IH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gREVDUkVNRU5UXG4vL1xuLy8gRGVjcmVtZW50cyB0aGUgZ2l2ZW4gX2tleV8gaW4gbWVtY2FjaGUuXG4vL1xuLy8gVGhlIG9wdGlvbnMgZGljdGlvbmFyeSB0YWtlczpcbi8vICogX2luaXRpYWxfOiB0aGUgdmFsdWUgZm9yIHRoZSBrZXkgaWYgbm90IGFscmVhZHkgcHJlc2VudCwgZGVmYXVsdHMgdG8gMC5cbi8vICogX2V4cGlyZXNfOiBvdmVycmlkZXMgdGhlIGRlZmF1bHQgZXhwaXJhdGlvbiAoc2VlIGBDbGllbnQuY3JlYXRlYCkgZm9yIHRoaXNcbi8vICAgICAgICAgICAgICBwYXJ0aWN1bGFyIGtleS12YWx1ZSBwYWlyLlxuLy9cbi8vIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgc3VjY2VzcywgdmFsdWUpXG5DbGllbnQucHJvdG90eXBlLmRlY3JlbWVudCA9IGZ1bmN0aW9uKGtleSwgYW1vdW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBwcm9taXNpZnkoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHNlbGYuZGVjcmVtZW50KGtleSwgYW1vdW50LCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIHN1Y2Nlc3MsIHZhbHVlKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwge3N1Y2Nlc3M6IHN1Y2Nlc3MsIHZhbHVlOiB2YWx1ZX0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gVE9ETzogc3VwcG9ydCB2ZXJzaW9uIChDQVMpXG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB2YXIgaW5pdGlhbDtcbiAgdmFyIGV4cGlyZXM7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIE9MRDogZnVuY3Rpb24oa2V5LCBhbW91bnQsIGNhbGxiYWNrLCBleHBpcmVzLCBpbml0aWFsKVxuICAgIGxvZ2dlci5sb2coJ01lbUpTIERFQ1JFTUVOVDogdXNpbmcgZGVwcmVjYXRlZCBjYWxsIC0gYXJndW1lbnRzIGhhdmUgY2hhbmdlZCcpO1xuICAgIGluaXRpYWwgPSBhcmd1bWVudHNbNF07XG4gICAgZXhwaXJlcyA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICAvLyBUT0RPOiBzdXBwb3J0IHZlcnNpb24gKENBUylcbiAgbG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlcjtcbiAgaW5pdGlhbCA9IG9wdGlvbnMuaW5pdGlhbDtcbiAgZXhwaXJlcyA9IG9wdGlvbnMuZXhwaXJlcztcblxuICB0aGlzLmluY3JTZXEoKTtcbiAgaW5pdGlhbCA9IGluaXRpYWwgfHwgMDtcbiAgZXhwaXJlcyA9IGV4cGlyZXMgfHwgdGhpcy5vcHRpb25zLmV4cGlyZXM7XG4gIHZhciBleHRyYXMgPSBtYWtlQW1vdW50SW5pdGlhbEFuZEV4cGlyYXRpb24oYW1vdW50LCBpbml0aWFsLCBleHBpcmVzKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcig2LCBrZXksIGV4dHJhcywgJycsIHRoaXMuc2VxKTtcbiAgdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgdGhpcy5zZXEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBudWxsKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICBjYXNlIDA6XG4gICAgICB2YXIgYnVmSW50ID0gKHJlc3BvbnNlLnZhbC5yZWFkVUludDMyQkUoMCkgPDwgOCkgKyByZXNwb25zZS52YWwucmVhZFVJbnQzMkJFKDQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIHRydWUsIGJ1ZkludCk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIERFQ1JFTUVOVDogJyArIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgIGxvZ2dlci5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgbnVsbCwgbnVsbCk7IH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gQVBQRU5EXG4vL1xuLy8gQXBwZW5kIHRoZSBnaXZlbiBfdmFsdWVfIHRvIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIF9rZXlfIGluXG4vLyBtZW1jYWNoZS4gVGhlIG9wZXJhdGlvbiBvbmx5IHN1Y2NlZWRzIGlmIHRoZSBrZXkgaXMgYWxyZWFkeSBwcmVzZW50LiBUaGVcbi8vIGNhbGxiYWNrIHNpZ25hdHVyZSBpczpcbi8vXG4vLyAgICAgY2FsbGJhY2soZXJyLCBzdWNjZXNzKVxuQ2xpZW50LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICBpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBwcm9taXNpZnkoZnVuY3Rpb24oY2FsbGJhY2spIHsgc2VsZi5hcHBlbmQoa2V5LCB2YWx1ZSwgZnVuY3Rpb24oZXJyLCBzdWNjZXNzKSB7IGNhbGxiYWNrKGVyciwgc3VjY2Vzcyk7IH0pOyB9KTtcbiAgfVxuICAvLyBUT0RPOiBzdXBwb3J0IHZlcnNpb24gKENBUylcbiAgdmFyIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIHRoaXMuaW5jclNlcSgpO1xuICB2YXIgb3Bjb2RlID0gMHgwRTtcbiAgdmFyIHNlcmlhbGl6ZWQgPSB0aGlzLnNlcmlhbGl6ZXIuc2VyaWFsaXplKG9wY29kZSwgdmFsdWUsICcnKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcihvcGNvZGUsIGtleSwgc2VyaWFsaXplZC5leHRyYXMsIHNlcmlhbGl6ZWQudmFsdWUsIHRoaXMuc2VxKTtcbiAgdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgdGhpcy5zZXEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBudWxsKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICBjYXNlIDA6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCBmYWxzZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIEFQUEVORDogJyArIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgIGxvZ2dlci5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgbnVsbCk7IH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gUFJFUEVORFxuLy9cbi8vIFByZXBlbmQgdGhlIGdpdmVuIF92YWx1ZV8gdG8gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gX2tleV8gaW5cbi8vIG1lbWNhY2hlLiBUaGUgb3BlcmF0aW9uIG9ubHkgc3VjY2VlZHMgaWYgdGhlIGtleSBpcyBhbHJlYWR5IHByZXNlbnQuIFRoZVxuLy8gY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuLy9cbi8vICAgICBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpXG5DbGllbnQucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICBpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBwcm9taXNpZnkoZnVuY3Rpb24oY2FsbGJhY2spIHsgc2VsZi5wcmVwZW5kKGtleSwgdmFsdWUsIGZ1bmN0aW9uKGVyciwgc3VjY2VzcykgeyBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpOyB9KTsgfSk7XG4gIH1cbiAgLy8gVE9ETzogc3VwcG9ydCB2ZXJzaW9uIChDQVMpXG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB0aGlzLmluY3JTZXEoKTtcblxuICB2YXIgb3Bjb2RlID0gMHgwRTtcbiAgdmFyIHNlcmlhbGl6ZWQgPSB0aGlzLnNlcmlhbGl6ZXIuc2VyaWFsaXplKG9wY29kZSwgdmFsdWUsICcnKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcihvcGNvZGUsIGtleSwgc2VyaWFsaXplZC5leHRyYXMsIHNlcmlhbGl6ZWQudmFsdWUsIHRoaXMuc2VxKTtcbiAgdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgdGhpcy5zZXEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBudWxsKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICBjYXNlIDA6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCBmYWxzZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIFBSRVBFTkQ6ICcgKyBlcnJvcnNbcmVzcG9uc2UuaGVhZGVyLnN0YXR1c107XG4gICAgICBsb2dnZXIubG9nKGVycm9yTWVzc2FnZSk7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobmV3IEVycm9yKGVycm9yTWVzc2FnZSksIG51bGwpOyB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFRPVUNIXG4vL1xuLy8gVG91Y2ggc2V0cyBhbiBleHBpcmF0aW9uIHZhbHVlLCBnaXZlbiBieSBfZXhwaXJlc18sIG9uIHRoZSBnaXZlbiBfa2V5XyBpblxuLy8gbWVtY2FjaGUuIFRoZSBvcGVyYXRpb24gb25seSBzdWNjZWVkcyBpZiB0aGUga2V5IGlzIGFscmVhZHkgcHJlc2VudC4gVGhlXG4vLyBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgc3VjY2VzcylcbkNsaWVudC5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbihrZXksIGV4cGlyZXMsIGNhbGxiYWNrKSB7XG4gIGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHByb21pc2lmeShmdW5jdGlvbihjYWxsYmFjaykgeyBzZWxmLnRvdWNoKGtleSwgZXhwaXJlcywgZnVuY3Rpb24oZXJyLCBzdWNjZXNzKSB7IGNhbGxiYWNrKGVyciwgc3VjY2Vzcyk7IH0pOyB9KTtcbiAgfVxuICAvLyBUT0RPOiBzdXBwb3J0IHZlcnNpb24gKENBUylcbiAgdmFyIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIHRoaXMuaW5jclNlcSgpO1xuICB2YXIgZXh0cmFzID0gbWFrZUV4cGlyYXRpb24oZXhwaXJlcyB8fCB0aGlzLm9wdGlvbnMuZXhwaXJlcyk7XG4gIHZhciByZXF1ZXN0ID0gbWFrZVJlcXVlc3RCdWZmZXIoMHgxQywga2V5LCBleHRyYXMsICcnLCB0aGlzLnNlcSk7XG4gIHRoaXMucGVyZm9ybShrZXksIHJlcXVlc3QsIHRoaXMuc2VxLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGVyciwgbnVsbCk7IH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChyZXNwb25zZS5oZWFkZXIuc3RhdHVzKSB7XG4gICAgY2FzZSAwOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIHRydWUpOyB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgZmFsc2UpOyB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9ICdNZW1KUyBUT1VDSDogJyArIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgIGxvZ2dlci5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgbnVsbCk7IH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gRkxVU0hcbi8vXG4vLyBGbHVzaGVzIHRoZSBjYWNoZSBvbiBlYWNoIGNvbm5lY3RlZCBzZXJ2ZXIuIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGxhc3RFcnIsIHJlc3VsdHMpXG4vL1xuLy8gd2hlcmUgX2xhc3RFcnJfIGlzIHRoZSBsYXN0IGVycm9yIGVuY291bnRlcmVkIChvciBudWxsLCBpbiB0aGUgY29tbW9uIGNhc2Vcbi8vIG9mIG5vIGVycm9ycykuIF9yZXN1bHRzXyBpcyBhIGRpY3Rpb25hcnkgbWFwcGluZyBgXCJob3N0bmFtZTpwb3J0XCJgIHRvIGVpdGhlclxuLy8gYHRydWVgIChpZiB0aGUgb3BlcmF0aW9uIHdhcyBzdWNjZXNzZnVsKSwgb3IgYW4gZXJyb3IuXG5DbGllbnQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gcHJvbWlzaWZ5KGZ1bmN0aW9uKGNhbGxiYWNrKSB7IHNlbGYuZmx1c2goZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7IGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7IH0pOyB9KTtcbiAgfVxuICAvLyBUT0RPOiBzdXBwb3J0IGV4cGlyYXRpb25cbiAgdGhpcy5pbmNyU2VxKCk7XG4gIHZhciByZXF1ZXN0ID0gbWFrZVJlcXVlc3RCdWZmZXIoMHgwOCwgJycsICcnLCAnJywgdGhpcy5zZXEpO1xuICB2YXIgY291bnQgICA9IHRoaXMuc2VydmVycy5sZW5ndGg7XG4gIHZhciByZXN1bHQgID0ge307XG4gIHZhciBsYXN0RXJyID0gbnVsbDtcbiAgdmFyIGk7XG5cbiAgdmFyIGhhbmRsZUZsdXNoID0gZnVuY3Rpb24oc2VxLCBzZXJ2KSB7XG4gICAgc2Vydi5vblJlc3BvbnNlKHNlcSwgZnVuY3Rpb24oLyogcmVzcG9uc2UgKi8pIHtcbiAgICAgIGNvdW50IC09IDE7XG4gICAgICByZXN1bHRbc2Vydi5ob3N0ICsgJzonICsgc2Vydi5wb3J0XSA9IHRydWU7XG4gICAgICBpZiAoY2FsbGJhY2sgJiYgY291bnQgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2sobGFzdEVyciwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXJ2Lm9uRXJyb3Ioc2VxLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGNvdW50IC09IDE7XG4gICAgICBsYXN0RXJyID0gZXJyO1xuICAgICAgcmVzdWx0W3NlcnYuaG9zdCArICc6JyArIHNlcnYucG9ydF0gPSBlcnI7XG4gICAgICBpZiAoY2FsbGJhY2sgJiYgY291bnQgPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2sobGFzdEVyciwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXJ2LndyaXRlKHJlcXVlc3QpO1xuICB9O1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBoYW5kbGVGbHVzaCh0aGlzLnNlcSwgdGhpcy5zZXJ2ZXJzW2ldKTtcbiAgfVxufTtcblxuLy8gU1RBVFNfV0lUSF9LRVlcbi8vXG4vLyBTZW5kcyBhIG1lbWNhY2hlIHN0YXRzIGNvbW1hbmQgd2l0aCBhIGtleSB0byBlYWNoIGNvbm5lY3RlZCBzZXJ2ZXIuIFRoZVxuLy8gY2FsbGJhY2sgaXMgaW52b2tlZCAqKk9OQ0UgUEVSIFNFUlZFUioqIGFuZCBoYXMgdGhlIHNpZ25hdHVyZTpcbi8vXG4vLyAgICAgY2FsbGJhY2soZXJyLCBzZXJ2ZXIsIHN0YXRzKVxuLy9cbi8vIF9zZXJ2ZXJfIGlzIHRoZSBgXCJob3N0bmFtZTpwb3J0XCJgIG9mIHRoZSBzZXJ2ZXIsIGFuZCBfc3RhdHNfIGlzIGEgZGljdGlvbmFyeVxuLy8gbWFwcGluZyB0aGUgc3RhdCBuYW1lIHRvIHRoZSB2YWx1ZSBvZiB0aGUgc3RhdGlzdGljIGFzIGEgc3RyaW5nLlxuQ2xpZW50LnByb3RvdHlwZS5zdGF0c1dpdGhLZXkgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB0aGlzLmluY3JTZXEoKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcigweDEwLCBrZXksICcnLCAnJywgdGhpcy5zZXEpO1xuICB2YXIgaTtcblxuICB2YXIgaGFuZGxlU3RhdHMgPSBmdW5jdGlvbihzZXEsIHNlcnYpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGhhbmRsZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAvLyBlbmQgb2Ygc3RhdCByZXNwb25zZXNcbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXIudG90YWxCb2R5TGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCBzZXJ2Lmhvc3QgKyAnOicgKyBzZXJ2LnBvcnQsIHJlc3VsdCk7IH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gcHJvY2VzcyBzaW5nbGUgc3RhdCBsaW5lIHJlc3BvbnNlXG4gICAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICAgIGNhc2UgIDA6XG4gICAgICAgIHJlc3VsdFtyZXNwb25zZS5rZXkudG9TdHJpbmcoKV0gPSByZXNwb25zZS52YWwudG9TdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIFNUQVRTICgnICsga2V5ICsgJyk6ICcgK1xuICAgICAgICAgIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgICAgbG9nZ2VyLmxvZyhlcnJvck1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGVycm9yTWVzc2FnZSksIHNlcnYuaG9zdCArICc6JyArIHNlcnYucG9ydCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZS5xdWlldCA9IHRydWU7XG5cbiAgICBzZXJ2Lm9uUmVzcG9uc2Uoc2VxLCBoYW5kbGUpO1xuICAgIHNlcnYub25FcnJvcihzZXEsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGVyciwgc2Vydi5ob3N0ICsgJzonICsgc2Vydi5wb3J0LCBudWxsKTsgfVxuICAgIH0pO1xuICAgIHNlcnYud3JpdGUocmVxdWVzdCk7XG4gIH07XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgIGhhbmRsZVN0YXRzKHRoaXMuc2VxLCB0aGlzLnNlcnZlcnNbaV0pO1xuICB9XG59O1xuXG5cbi8vIFNUQVRTXG4vL1xuLy8gRmV0Y2hlcyBtZW1jYWNoZSBzdGF0cyBmcm9tIGVhY2ggY29ubmVjdGVkIHNlcnZlci4gVGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbi8vICoqT05DRSBQRVIgU0VSVkVSKiogYW5kIGhhcyB0aGUgc2lnbmF0dXJlOlxuLy9cbi8vICAgICBjYWxsYmFjayhlcnIsIHNlcnZlciwgc3RhdHMpXG4vL1xuLy8gX3NlcnZlcl8gaXMgdGhlIGBcImhvc3RuYW1lOnBvcnRcImAgb2YgdGhlIHNlcnZlciwgYW5kIF9zdGF0c18gaXMgYVxuLy8gZGljdGlvbmFyeSBtYXBwaW5nIHRoZSBzdGF0IG5hbWUgdG8gdGhlIHZhbHVlIG9mIHRoZSBzdGF0aXN0aWMgYXMgYSBzdHJpbmcuXG5DbGllbnQucHJvdG90eXBlLnN0YXRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5zdGF0c1dpdGhLZXkoJycsIGNhbGxiYWNrKTtcbn07XG5cbi8vIFJFU0VUX1NUQVRTXG4vL1xuLy8gUmVzZXQgdGhlIHN0YXRpc3RpY3MgZWFjaCBzZXJ2ZXIgaXMga2VlcGluZyBiYWNrIHRvIHplcm8uIFRoaXMgZG9lc24ndCBjbGVhclxuLy8gc3RhdHMgc3VjaCBhcyBpdGVtIGNvdW50LCBidXQgdGVtcG9yYXJ5IHN0YXRzIHN1Y2ggYXMgdG90YWwgbnVtYmVyIG9mXG4vLyBjb25uZWN0aW9ucyBvdmVyIHRpbWUuXG4vL1xuLy8gVGhlIGNhbGxiYWNrIGlzIGludm9rZWQgKipPTkNFIFBFUiBTRVJWRVIqKiBhbmQgaGFzIHRoZSBzaWduYXR1cmU6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgc2VydmVyKVxuLy9cbi8vIF9zZXJ2ZXJfIGlzIHRoZSBgXCJob3N0bmFtZTpwb3J0XCJgIG9mIHRoZSBzZXJ2ZXIuXG5DbGllbnQucHJvdG90eXBlLnJlc2V0U3RhdHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLnN0YXRzV2l0aEtleSgncmVzZXQnLCBjYWxsYmFjayk7XG59O1xuXG4vLyBRVUlUXG4vL1xuLy8gQ2xvc2VzIHRoZSBjb25uZWN0aW9uIHRvIGVhY2ggc2VydmVyLCBub3RpZnlpbmcgdGhlbSBvZiB0aGlzIGludGVudGlvbi4gTm90ZVxuLy8gdGhhdCBxdWl0IGNhbiByYWNlIGFnYWluc3QgYWxyZWFkeSBvdXRzdGFuZGluZyByZXF1ZXN0cyB3aGVuIHRob3NlIHJlcXVlc3RzXG4vLyBmYWlsIGFuZCBhcmUgcmV0cmllZCwgbGVhZGluZyB0byB0aGUgcXVpdCBjb21tYW5kIHdpbm5pbmcgYW5kIGNsb3NpbmcgdGhlXG4vLyBjb25uZWN0aW9uIGJlZm9yZSB0aGUgcmV0cmllcyBjb21wbGV0ZS5cbkNsaWVudC5wcm90b3R5cGUucXVpdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluY3JTZXEoKTtcbiAgLy8gVE9ETzogTmljZXIgcGVyaGFwcyB0byBkbyBRVUlUUSAoMHgxNykgYnV0IG5lZWQgYSBuZXcgY2FsbGJhY2sgZm9yIHdoZW5cbiAgLy8gd3JpdGUgaXMgZG9uZS5cbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcigweDA3LCAnJywgJycsICcnLCB0aGlzLnNlcSk7IC8vIFFVSVRcbiAgdmFyIHNlcnY7XG4gIHZhciBpO1xuXG4gIHZhciBoYW5kbGVRdWl0ID0gZnVuY3Rpb24oc2VxLCBzZXJ2KSB7XG4gICAgc2Vydi5vblJlc3BvbnNlKHNlcSwgZnVuY3Rpb24oLyogcmVzcG9uc2UgKi8pIHtcbiAgICAgIHNlcnYuY2xvc2UoKTtcbiAgICB9KTtcbiAgICBzZXJ2Lm9uRXJyb3Ioc2VxLCBmdW5jdGlvbigvKiBlcnIgKi8pIHtcbiAgICAgIHNlcnYuY2xvc2UoKTtcbiAgICB9KTtcbiAgICBzZXJ2LndyaXRlKHJlcXVlc3QpO1xuICB9O1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzZXJ2ID0gdGhpcy5zZXJ2ZXJzW2ldO1xuICAgIGhhbmRsZVF1aXQodGhpcy5zZXEsIHNlcnYpO1xuICB9XG59O1xuXG4vLyBDTE9TRVxuLy9cbi8vIENsb3NlcyAoYWJydXB0bHkpIGNvbm5lY3Rpb25zIHRvIGFsbCB0aGUgc2VydmVycy5cbkNsaWVudC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnNlcnZlcnNbaV0uY2xvc2UoKTtcbiAgfVxufTtcblxuLy8gUGVyZm9ybSBhIGdlbmVyaWMgc2luZ2xlIHJlc3BvbnNlIG9wZXJhdGlvbiAoZ2V0LCBzZXQgZXRjKSBvbiBhIHNlcnZlclxuLy8gc2VydjogdGhlIHNlcnZlciB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24gb25cbi8vIHJlcXVlc3Q6IGEgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIHJlcXVlc3Rcbi8vIHNlcTogdGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgb3BlcmF0aW9uLiBJdCBpcyB1c2VkIHRvIHBpbiB0aGUgY2FsbGJhY2tzXG4vLyAgICAgIHRvIGEgc3BlY2lmaWMgb3BlcmF0aW9uIGFuZCBzaG91bGQgbmV2ZXIgY2hhbmdlIGR1cmluZyBhIGBwZXJmb3JtYC5cbi8vIGNhbGxiYWNrOiBhIGNhbGxiYWNrIGludm9rZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJlY2VpdmVkIG9yIHRoZSByZXF1ZXN0XG4vLyAgICAgICAgICAgZmFpbHNcbi8vIHJldHJpZXM6IG51bWJlciBvZiB0aW1lcyB0byByZXRyeSByZXF1ZXN0IG9uIGZhaWx1cmVcbkNsaWVudC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGtleSwgcmVxdWVzdCwgc2VxLCBjYWxsYmFjaywgcmV0cmllcykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgc2VydiA9IHRoaXMuc2VydmVyKGtleSk7XG4gIGlmICghc2Vydikge1xuICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIHNlcnZlcnMgYXZhaWxhYmxlJyksIG51bGwpOyB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0cmllcyA9IHJldHJpZXMgfHwgdGhpcy5vcHRpb25zLnJldHJpZXM7XG4gIHZhciBmYWlsb3ZlciA9IHRoaXMub3B0aW9ucy5mYWlsb3ZlcjtcbiAgdmFyIGZhaWxvdmVyVGltZSA9IHRoaXMub3B0aW9ucy5mYWlsb3ZlclRpbWU7XG4gIHZhciBvcmlnUmV0cmllcyA9IHRoaXMub3B0aW9ucy5yZXRyaWVzO1xuICB2YXIgbG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlcjtcbiAgdmFyIHJldHJ5X2RlbGF5ID0gdGhpcy5vcHRpb25zLnJldHJ5X2RlbGF5O1xuXG4gIHZhciByZXNwb25zZUhhbmRsZXIgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7IH1cbiAgfTtcblxuICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBpZiAoLS1yZXRyaWVzID4gMCkge1xuICAgICAgLy8gV2FpdCBmb3IgcmV0cnlfZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLnBlcmZvcm0oa2V5LCByZXF1ZXN0LCBzZXEsIGNhbGxiYWNrLCByZXRyaWVzKTtcbiAgICAgIH0sIDEwMDAgKiByZXRyeV9kZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5sb2coJ01lbUpTOiBTZXJ2ZXIgPCcgKyBzZXJ2Lmhvc3QgKyAnOicgKyBzZXJ2LnBvcnQgK1xuICAgICAgICAgICAgICAgICAgJz4gZmFpbGVkIGFmdGVyICgnICsgb3JpZ1JldHJpZXMgK1xuICAgICAgICAgICAgICAgICAgJykgcmV0cmllcyB3aXRoIGVycm9yIC0gJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgaWYgKGZhaWxvdmVyKSB7XG4gICAgICAgIHNlcnYud2FrZXVwQXQgPSBEYXRlLm5vdygpICsgZmFpbG92ZXJUaW1lICogMTAwMDtcbiAgICAgICAgX3RoaXMucGVyZm9ybShrZXksIHJlcXVlc3QsIHNlcSwgY2FsbGJhY2ssIG9yaWdSZXRyaWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnJvciwgbnVsbCk7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgc2Vydi5vblJlc3BvbnNlKHNlcSwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgc2Vydi5vbkVycm9yKHNlcSwgZXJyb3JIYW5kbGVyKTtcbiAgc2Vydi53cml0ZShyZXF1ZXN0KTtcbn07XG5cbi8vIEluY3JlbWVudCB0aGUgc2VxIHZhbHVlXG5DbGllbnQucHJvdG90eXBlLmluY3JTZXEgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXErKztcblxuICAvLyBXcmFwIGB0aGlzLnNlcWAgdG8gMzItYml0cyBzaW5jZSB0aGUgZmllbGQgd2UgZml0IGl0IGludG8gaXMgb25seSAzMi1iaXRzLlxuICB0aGlzLnNlcSAmPSAweGZmZmZmZmZmO1xufTtcblxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbmV4cG9ydHMuVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5leHBvcnRzLkhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyJyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/memjs/lib/memjs/memjs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/memjs/lib/memjs/noop-serializer.js":
/*!*********************************************************!*\
  !*** ./node_modules/memjs/lib/memjs/noop-serializer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var noopSerializer = {\n  serialize: function (opcode, value, extras) {\n    return { value: value, extras: extras };\n  },\n  deserialize: function (opcode, value, extras) {\n    return { value: value, extras: extras };\n  }\n};\n\nexports.noopSerializer = noopSerializer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL25vb3Atc2VyaWFsaXplci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLHNCQUFzQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzaXlhbVxcRG9jdW1lbnRzXFxBSS1Qb3dlcmVkLUNoYXRib3RcXG5vZGVfbW9kdWxlc1xcbWVtanNcXGxpYlxcbWVtanNcXG5vb3Atc2VyaWFsaXplci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbm9vcFNlcmlhbGl6ZXIgPSB7XG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24gKG9wY29kZSwgdmFsdWUsIGV4dHJhcykge1xuICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZXh0cmFzOiBleHRyYXMgfTtcbiAgfSxcbiAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChvcGNvZGUsIHZhbHVlLCBleHRyYXMpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGV4dHJhczogZXh0cmFzIH07XG4gIH1cbn07XG5cbmV4cG9ydHMubm9vcFNlcmlhbGl6ZXIgPSBub29wU2VyaWFsaXplcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/memjs/lib/memjs/noop-serializer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/memjs/lib/memjs/protocol.js":
/*!**************************************************!*\
  !*** ./node_modules/memjs/lib/memjs/protocol.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// # MemJS Memcache binary protocol errors\n\nexports.errors = {};\nexports.errors[0] = 'No error';\nexports.errors[1] = 'Key not found';\nexports.errors[2] = 'Key exists';\nexports.errors[3] = 'Value too large';\nexports.errors[4] = 'Invalid arguments';\nexports.errors[5] = 'Item not stored';\nexports.errors[6] = 'Incr/Decr on non-numeric value';\nexports.errors[7] = 'The vbucket belongs to another server';\nexports.errors[8] = 'Authentication error';\nexports.errors[9] = 'Authentication continue';\nexports.errors[129] = 'Unknown command';\nexports.errors[130] = 'Out of memory';\nexports.errors[131] = 'Not supported';\nexports.errors[132] = 'Internal error';\nexports.errors[133] = 'Busy';\nexports.errors[134] = 'Temporary failure';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL3Byb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGNBQWM7QUFDZCxpQkFBc0I7QUFDdEIsaUJBQXNCO0FBQ3RCLGlCQUFzQjtBQUN0QixpQkFBc0I7QUFDdEIsaUJBQXNCO0FBQ3RCLGlCQUFzQjtBQUN0QixpQkFBc0I7QUFDdEIsaUJBQXNCO0FBQ3RCLGlCQUFzQjtBQUN0QixpQkFBc0I7QUFDdEIsbUJBQXNCO0FBQ3RCLG1CQUFzQjtBQUN0QixtQkFBc0I7QUFDdEIsbUJBQXNCO0FBQ3RCLG1CQUFzQjtBQUN0QixtQkFBc0IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2l5YW1cXERvY3VtZW50c1xcQUktUG93ZXJlZC1DaGF0Ym90XFxub2RlX21vZHVsZXNcXG1lbWpzXFxsaWJcXG1lbWpzXFxwcm90b2NvbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAjIE1lbUpTIE1lbWNhY2hlIGJpbmFyeSBwcm90b2NvbCBlcnJvcnNcblxuZXhwb3J0cy5lcnJvcnMgPSB7fTtcbmV4cG9ydHMuZXJyb3JzWzB4MDAwMF0gPSAnTm8gZXJyb3InO1xuZXhwb3J0cy5lcnJvcnNbMHgwMDAxXSA9ICdLZXkgbm90IGZvdW5kJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwMl0gPSAnS2V5IGV4aXN0cyc7XG5leHBvcnRzLmVycm9yc1sweDAwMDNdID0gJ1ZhbHVlIHRvbyBsYXJnZSc7XG5leHBvcnRzLmVycm9yc1sweDAwMDRdID0gJ0ludmFsaWQgYXJndW1lbnRzJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwNV0gPSAnSXRlbSBub3Qgc3RvcmVkJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwNl0gPSAnSW5jci9EZWNyIG9uIG5vbi1udW1lcmljIHZhbHVlJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwN10gPSAnVGhlIHZidWNrZXQgYmVsb25ncyB0byBhbm90aGVyIHNlcnZlcic7XG5leHBvcnRzLmVycm9yc1sweDAwMDhdID0gJ0F1dGhlbnRpY2F0aW9uIGVycm9yJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwOV0gPSAnQXV0aGVudGljYXRpb24gY29udGludWUnO1xuZXhwb3J0cy5lcnJvcnNbMHgwMDgxXSA9ICdVbmtub3duIGNvbW1hbmQnO1xuZXhwb3J0cy5lcnJvcnNbMHgwMDgyXSA9ICdPdXQgb2YgbWVtb3J5JztcbmV4cG9ydHMuZXJyb3JzWzB4MDA4M10gPSAnTm90IHN1cHBvcnRlZCc7XG5leHBvcnRzLmVycm9yc1sweDAwODRdID0gJ0ludGVybmFsIGVycm9yJztcbmV4cG9ydHMuZXJyb3JzWzB4MDA4NV0gPSAnQnVzeSc7XG5leHBvcnRzLmVycm9yc1sweDAwODZdID0gJ1RlbXBvcmFyeSBmYWlsdXJlJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/memjs/lib/memjs/protocol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/memjs/lib/memjs/server.js":
/*!************************************************!*\
  !*** ./node_modules/memjs/lib/memjs/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var net = __webpack_require__(/*! net */ \"net\");\nvar events = __webpack_require__(/*! events */ \"events\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar makeRequestBuffer = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\").makeRequestBuffer);\nvar parseMessage = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\").parseMessage);\nvar merge = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\").merge);\nvar timestamp = (__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/memjs/lib/memjs/utils.js\").timestamp);\n\nvar Server = function(host, port, username, password, options) {\n  events.EventEmitter.call(this);\n  this.responseBuffer = Buffer.from([]);\n  this.host = host;\n  this.port = port;\n  this.connected = false;\n  this.timeoutSet = false;\n  this.connectCallbacks = [];\n  this.responseCallbacks = {};\n  this.requestTimeouts = [];\n  this.errorCallbacks = {};\n  this.options = merge(options || {}, {timeout: 0.5, keepAlive: false, keepAliveDelay: 30});\n  if (this.options.conntimeout === undefined || this.options.conntimeout === null) {\n    this.options.conntimeout = 2 * this.options.timeout;\n  }\n  this.username = username || this.options.username || process.env.MEMCACHIER_USERNAME || process.env.MEMCACHE_USERNAME;\n  this.password = password || this.options.password || process.env.MEMCACHIER_PASSWORD || process.env.MEMCACHE_PASSWORD;\n  return this;\n};\n\nutil.inherits(Server, events.EventEmitter);\n\nServer.prototype.onConnect = function(func) {\n  this.connectCallbacks.push(func);\n};\n\nServer.prototype.onResponse = function(seq, func) {\n  this.responseCallbacks[seq] = func;\n};\n\nServer.prototype.respond = function(response) {\n  var callback = this.responseCallbacks[response.header.opaque];\n  if (!callback) {\n    // in case of authentication, no callback is registered\n    return;\n  }\n  callback(response);\n  if (!callback.quiet || response.header.totalBodyLength === 0) {\n    delete(this.responseCallbacks[response.header.opaque]);\n    this.requestTimeouts.shift();\n    delete(this.errorCallbacks[response.header.opaque]);\n  }\n};\n\nServer.prototype.onError = function(seq, func) {\n  this.errorCallbacks[seq] = func;\n};\n\nServer.prototype.error = function(err) {\n  var errcalls = this.errorCallbacks;\n  this.connectCallbacks = [];\n  this.responseCallbacks = {};\n  this.requestTimeouts = [];\n  this.errorCallbacks = {};\n  this.timeoutSet = false;\n  if (this._socket) {\n    this._socket.destroy();\n    delete(this._socket);\n  }\n  var k;\n  for (k in errcalls) {\n    if (errcalls.hasOwnProperty(k)) {\n      errcalls[k](err);\n    }\n  }\n};\n\nServer.prototype.listSasl = function() {\n  var buf = makeRequestBuffer(0x20, '', '', '');\n  this.writeSASL(buf);\n};\n\nServer.prototype.saslAuth = function() {\n  var authStr = '\\x00' + this.username + '\\x00' + this.password;\n  var buf = makeRequestBuffer(0x21, 'PLAIN', '', authStr);\n  this.writeSASL(buf);\n};\n\nServer.prototype.appendToBuffer = function(dataBuf) {\n  var old = this.responseBuffer;\n  this.responseBuffer = Buffer.alloc(old.length + dataBuf.length);\n  old.copy(this.responseBuffer, 0);\n  dataBuf.copy(this.responseBuffer, old.length);\n  return this.responseBuffer;\n};\n\nServer.prototype.responseHandler = function(dataBuf) {\n  var response = parseMessage(this.appendToBuffer(dataBuf));\n  var respLength;\n  while (response) {\n    if (response.header.opcode === 0x20) {\n      this.saslAuth();\n    } else if (response.header.status === 0x20) {\n      this.error('Memcached server authentication failed!');\n    } else if (response.header.opcode === 0x21) {\n      this.emit('authenticated');\n    } else {\n      this.respond(response);\n    }\n    respLength = response.header.totalBodyLength + 24;\n    this.responseBuffer = this.responseBuffer.slice(respLength);\n    response = parseMessage(this.responseBuffer);\n  }\n};\n\nServer.prototype.sock = function(sasl, go) {\n  var self = this;\n\n  if (!self._socket) {\n    // CASE 1: completely new socket\n    self.connected = false;\n    self._socket = net.connect(this.port, this.host, function() {\n\n      // SASL authentication handler\n      self.once('authenticated', function() {\n        if (self._socket) {\n          self.connected = true;\n          // cancel connection timeout\n          self._socket.setTimeout(0);\n          self.timeoutSet = false;\n          // run actual request(s)\n          go(self._socket);\n          self.connectCallbacks.forEach(function(cb) {\n            cb(self._socket);\n          });\n          self.connectCallbacks = [];\n        }\n      });\n\n      // setup response handler\n      this.on('data', function(dataBuf) {\n        self.responseHandler(dataBuf);\n      });\n\n      // kick of SASL if needed\n      if (self.username && self.password) {\n        self.listSasl();\n      } else {\n        self.emit('authenticated');\n      }\n    });\n\n    // setup error handler\n    self._socket.on('error', function(error) {\n      self.error(error);\n    });\n\n    self._socket.on('close', function() {\n      self.connected = false;\n      if (self.timeoutSet) {\n        self._socket.setTimeout(0);\n        self.timeoutSet = false;\n      }\n      self._socket = undefined;\n    });\n\n    // setup connection timeout handler\n    self.timeoutSet = true;\n    self._socket.setTimeout(self.options.conntimeout * 1000, function() {\n      self.timeoutSet = false;\n      if (!self.connected) {\n        this.end();\n        self._socket = undefined;\n        self.error(new Error('socket timed out connecting to server.'));\n      }\n    });\n\n    // use TCP keep-alive\n    self._socket.setKeepAlive(self.options.keepAlive, self.options.keepAliveDelay * 1000);\n\n  } else if (!self.connected && !sasl) {\n    // CASE 2: socket exists, but still connecting / authenticating\n    self.onConnect(go);\n\n  } else {\n    // CASE 3: socket exists and connected / ready to use\n    go(self._socket);\n  }\n};\n\n// We handle tracking timeouts with an array of deadlines (requestTimeouts), as\n// node doesn't like us setting up lots of timers, and using just one is more\n// efficient anyway.\nvar timeoutHandler = function(server, sock) {\n  if (server.requestTimeouts.length === 0) {\n    // nothing active\n    server.timeoutSet = false;\n    return;\n  }\n\n  // some requests outstanding, check if any have timed-out\n  var now = timestamp();\n  var soonestTimeout = server.requestTimeouts[0];\n\n  if (soonestTimeout <= now) {\n    // timeout occurred!\n    sock.end();\n    server.connected = false;\n    server._socket = undefined;\n    server.timeoutSet = false;\n    server.error(new Error('socket timed out waiting on response.'));\n  } else {\n    // no timeout! Setup next one.\n    var deadline = soonestTimeout - now;\n    sock.setTimeout(deadline, function() {\n      timeoutHandler(server, sock);\n    });\n  }\n};\n\nServer.prototype.write = function(blob) {\n  var self = this;\n  var deadline = Math.round(self.options.timeout * 1000);\n  this.sock(false, function(s) {\n    s.write(blob);\n    self.requestTimeouts.push(timestamp() + deadline);\n    if (!self.timeoutSet) {\n      self.timeoutSet = true;\n      s.setTimeout(deadline, function() {\n        timeoutHandler(self, this);\n      });\n    }\n  });\n};\n\nServer.prototype.writeSASL = function(blob) {\n  this.sock(true, function(s) {\n    s.write(blob);\n  });\n};\n\nServer.prototype.close = function() {\n  if (this._socket) { this._socket.end(); }\n};\n\nServer.prototype.toString = function() {\n  return '<Server ' + this.host + ':' + this.port + '>';\n};\n\nexports.Server = Server;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL3NlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsZ0JBQUs7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6Qix3QkFBd0IsdUdBQW9DO0FBQzVELG1CQUFtQixrR0FBK0I7QUFDbEQsWUFBWSwyRkFBd0I7QUFDcEMsZ0JBQWdCLCtGQUE0Qjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxHQUFHLG1EQUFtRDtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzaXlhbVxcRG9jdW1lbnRzXFxBSS1Qb3dlcmVkLUNoYXRib3RcXG5vZGVfbW9kdWxlc1xcbWVtanNcXGxpYlxcbWVtanNcXHNlcnZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBtYWtlUmVxdWVzdEJ1ZmZlciA9IHJlcXVpcmUoJy4vdXRpbHMnKS5tYWtlUmVxdWVzdEJ1ZmZlcjtcbnZhciBwYXJzZU1lc3NhZ2UgPSByZXF1aXJlKCcuL3V0aWxzJykucGFyc2VNZXNzYWdlO1xudmFyIG1lcmdlID0gcmVxdWlyZSgnLi91dGlscycpLm1lcmdlO1xudmFyIHRpbWVzdGFtcCA9IHJlcXVpcmUoJy4vdXRpbHMnKS50aW1lc3RhbXA7XG5cbnZhciBTZXJ2ZXIgPSBmdW5jdGlvbihob3N0LCBwb3J0LCB1c2VybmFtZSwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgZXZlbnRzLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLnJlc3BvbnNlQnVmZmVyID0gQnVmZmVyLmZyb20oW10pO1xuICB0aGlzLmhvc3QgPSBob3N0O1xuICB0aGlzLnBvcnQgPSBwb3J0O1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLnRpbWVvdXRTZXQgPSBmYWxzZTtcbiAgdGhpcy5jb25uZWN0Q2FsbGJhY2tzID0gW107XG4gIHRoaXMucmVzcG9uc2VDYWxsYmFja3MgPSB7fTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dHMgPSBbXTtcbiAgdGhpcy5lcnJvckNhbGxiYWNrcyA9IHt9O1xuICB0aGlzLm9wdGlvbnMgPSBtZXJnZShvcHRpb25zIHx8IHt9LCB7dGltZW91dDogMC41LCBrZWVwQWxpdmU6IGZhbHNlLCBrZWVwQWxpdmVEZWxheTogMzB9KTtcbiAgaWYgKHRoaXMub3B0aW9ucy5jb25udGltZW91dCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub3B0aW9ucy5jb25udGltZW91dCA9PT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy5jb25udGltZW91dCA9IDIgKiB0aGlzLm9wdGlvbnMudGltZW91dDtcbiAgfVxuICB0aGlzLnVzZXJuYW1lID0gdXNlcm5hbWUgfHwgdGhpcy5vcHRpb25zLnVzZXJuYW1lIHx8IHByb2Nlc3MuZW52Lk1FTUNBQ0hJRVJfVVNFUk5BTUUgfHwgcHJvY2Vzcy5lbnYuTUVNQ0FDSEVfVVNFUk5BTUU7XG4gIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZCB8fCB0aGlzLm9wdGlvbnMucGFzc3dvcmQgfHwgcHJvY2Vzcy5lbnYuTUVNQ0FDSElFUl9QQVNTV09SRCB8fCBwcm9jZXNzLmVudi5NRU1DQUNIRV9QQVNTV09SRDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG51dGlsLmluaGVyaXRzKFNlcnZlciwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cblNlcnZlci5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24oZnVuYykge1xuICB0aGlzLmNvbm5lY3RDYWxsYmFja3MucHVzaChmdW5jKTtcbn07XG5cblNlcnZlci5wcm90b3R5cGUub25SZXNwb25zZSA9IGZ1bmN0aW9uKHNlcSwgZnVuYykge1xuICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW3NlcV0gPSBmdW5jO1xufTtcblxuU2VydmVyLnByb3RvdHlwZS5yZXNwb25kID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgdmFyIGNhbGxiYWNrID0gdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tyZXNwb25zZS5oZWFkZXIub3BhcXVlXTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIC8vIGluIGNhc2Ugb2YgYXV0aGVudGljYXRpb24sIG5vIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWRcbiAgICByZXR1cm47XG4gIH1cbiAgY2FsbGJhY2socmVzcG9uc2UpO1xuICBpZiAoIWNhbGxiYWNrLnF1aWV0IHx8IHJlc3BvbnNlLmhlYWRlci50b3RhbEJvZHlMZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUodGhpcy5yZXNwb25zZUNhbGxiYWNrc1tyZXNwb25zZS5oZWFkZXIub3BhcXVlXSk7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dHMuc2hpZnQoKTtcbiAgICBkZWxldGUodGhpcy5lcnJvckNhbGxiYWNrc1tyZXNwb25zZS5oZWFkZXIub3BhcXVlXSk7XG4gIH1cbn07XG5cblNlcnZlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uKHNlcSwgZnVuYykge1xuICB0aGlzLmVycm9yQ2FsbGJhY2tzW3NlcV0gPSBmdW5jO1xufTtcblxuU2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICB2YXIgZXJyY2FsbHMgPSB0aGlzLmVycm9yQ2FsbGJhY2tzO1xuICB0aGlzLmNvbm5lY3RDYWxsYmFja3MgPSBbXTtcbiAgdGhpcy5yZXNwb25zZUNhbGxiYWNrcyA9IHt9O1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0cyA9IFtdO1xuICB0aGlzLmVycm9yQ2FsbGJhY2tzID0ge307XG4gIHRoaXMudGltZW91dFNldCA9IGZhbHNlO1xuICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICBkZWxldGUodGhpcy5fc29ja2V0KTtcbiAgfVxuICB2YXIgaztcbiAgZm9yIChrIGluIGVycmNhbGxzKSB7XG4gICAgaWYgKGVycmNhbGxzLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICBlcnJjYWxsc1trXShlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuU2VydmVyLnByb3RvdHlwZS5saXN0U2FzbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVmID0gbWFrZVJlcXVlc3RCdWZmZXIoMHgyMCwgJycsICcnLCAnJyk7XG4gIHRoaXMud3JpdGVTQVNMKGJ1Zik7XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLnNhc2xBdXRoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoU3RyID0gJ1xceDAwJyArIHRoaXMudXNlcm5hbWUgKyAnXFx4MDAnICsgdGhpcy5wYXNzd29yZDtcbiAgdmFyIGJ1ZiA9IG1ha2VSZXF1ZXN0QnVmZmVyKDB4MjEsICdQTEFJTicsICcnLCBhdXRoU3RyKTtcbiAgdGhpcy53cml0ZVNBU0woYnVmKTtcbn07XG5cblNlcnZlci5wcm90b3R5cGUuYXBwZW5kVG9CdWZmZXIgPSBmdW5jdGlvbihkYXRhQnVmKSB7XG4gIHZhciBvbGQgPSB0aGlzLnJlc3BvbnNlQnVmZmVyO1xuICB0aGlzLnJlc3BvbnNlQnVmZmVyID0gQnVmZmVyLmFsbG9jKG9sZC5sZW5ndGggKyBkYXRhQnVmLmxlbmd0aCk7XG4gIG9sZC5jb3B5KHRoaXMucmVzcG9uc2VCdWZmZXIsIDApO1xuICBkYXRhQnVmLmNvcHkodGhpcy5yZXNwb25zZUJ1ZmZlciwgb2xkLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzLnJlc3BvbnNlQnVmZmVyO1xufTtcblxuU2VydmVyLnByb3RvdHlwZS5yZXNwb25zZUhhbmRsZXIgPSBmdW5jdGlvbihkYXRhQnVmKSB7XG4gIHZhciByZXNwb25zZSA9IHBhcnNlTWVzc2FnZSh0aGlzLmFwcGVuZFRvQnVmZmVyKGRhdGFCdWYpKTtcbiAgdmFyIHJlc3BMZW5ndGg7XG4gIHdoaWxlIChyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5oZWFkZXIub3Bjb2RlID09PSAweDIwKSB7XG4gICAgICB0aGlzLnNhc2xBdXRoKCk7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5oZWFkZXIuc3RhdHVzID09PSAweDIwKSB7XG4gICAgICB0aGlzLmVycm9yKCdNZW1jYWNoZWQgc2VydmVyIGF1dGhlbnRpY2F0aW9uIGZhaWxlZCEnKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmhlYWRlci5vcGNvZGUgPT09IDB4MjEpIHtcbiAgICAgIHRoaXMuZW1pdCgnYXV0aGVudGljYXRlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3BvbmQocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXNwTGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVyLnRvdGFsQm9keUxlbmd0aCArIDI0O1xuICAgIHRoaXMucmVzcG9uc2VCdWZmZXIgPSB0aGlzLnJlc3BvbnNlQnVmZmVyLnNsaWNlKHJlc3BMZW5ndGgpO1xuICAgIHJlc3BvbnNlID0gcGFyc2VNZXNzYWdlKHRoaXMucmVzcG9uc2VCdWZmZXIpO1xuICB9XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLnNvY2sgPSBmdW5jdGlvbihzYXNsLCBnbykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFzZWxmLl9zb2NrZXQpIHtcbiAgICAvLyBDQVNFIDE6IGNvbXBsZXRlbHkgbmV3IHNvY2tldFxuICAgIHNlbGYuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgc2VsZi5fc29ja2V0ID0gbmV0LmNvbm5lY3QodGhpcy5wb3J0LCB0aGlzLmhvc3QsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAvLyBTQVNMIGF1dGhlbnRpY2F0aW9uIGhhbmRsZXJcbiAgICAgIHNlbGYub25jZSgnYXV0aGVudGljYXRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2VsZi5fc29ja2V0KSB7XG4gICAgICAgICAgc2VsZi5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIGNhbmNlbCBjb25uZWN0aW9uIHRpbWVvdXRcbiAgICAgICAgICBzZWxmLl9zb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICAgICAgICBzZWxmLnRpbWVvdXRTZXQgPSBmYWxzZTtcbiAgICAgICAgICAvLyBydW4gYWN0dWFsIHJlcXVlc3QocylcbiAgICAgICAgICBnbyhzZWxmLl9zb2NrZXQpO1xuICAgICAgICAgIHNlbGYuY29ubmVjdENhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBjYihzZWxmLl9zb2NrZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuY29ubmVjdENhbGxiYWNrcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gc2V0dXAgcmVzcG9uc2UgaGFuZGxlclxuICAgICAgdGhpcy5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGFCdWYpIHtcbiAgICAgICAgc2VsZi5yZXNwb25zZUhhbmRsZXIoZGF0YUJ1Zik7XG4gICAgICB9KTtcblxuICAgICAgLy8ga2ljayBvZiBTQVNMIGlmIG5lZWRlZFxuICAgICAgaWYgKHNlbGYudXNlcm5hbWUgJiYgc2VsZi5wYXNzd29yZCkge1xuICAgICAgICBzZWxmLmxpc3RTYXNsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2F1dGhlbnRpY2F0ZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHNldHVwIGVycm9yIGhhbmRsZXJcbiAgICBzZWxmLl9zb2NrZXQub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHNlbGYuZXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgc2VsZi5fc29ja2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChzZWxmLnRpbWVvdXRTZXQpIHtcbiAgICAgICAgc2VsZi5fc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgICAgIHNlbGYudGltZW91dFNldCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc2VsZi5fc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0dXAgY29ubmVjdGlvbiB0aW1lb3V0IGhhbmRsZXJcbiAgICBzZWxmLnRpbWVvdXRTZXQgPSB0cnVlO1xuICAgIHNlbGYuX3NvY2tldC5zZXRUaW1lb3V0KHNlbGYub3B0aW9ucy5jb25udGltZW91dCAqIDEwMDAsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi50aW1lb3V0U2V0ID0gZmFsc2U7XG4gICAgICBpZiAoIXNlbGYuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgIHNlbGYuX3NvY2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZi5lcnJvcihuZXcgRXJyb3IoJ3NvY2tldCB0aW1lZCBvdXQgY29ubmVjdGluZyB0byBzZXJ2ZXIuJykpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gdXNlIFRDUCBrZWVwLWFsaXZlXG4gICAgc2VsZi5fc29ja2V0LnNldEtlZXBBbGl2ZShzZWxmLm9wdGlvbnMua2VlcEFsaXZlLCBzZWxmLm9wdGlvbnMua2VlcEFsaXZlRGVsYXkgKiAxMDAwKTtcblxuICB9IGVsc2UgaWYgKCFzZWxmLmNvbm5lY3RlZCAmJiAhc2FzbCkge1xuICAgIC8vIENBU0UgMjogc29ja2V0IGV4aXN0cywgYnV0IHN0aWxsIGNvbm5lY3RpbmcgLyBhdXRoZW50aWNhdGluZ1xuICAgIHNlbGYub25Db25uZWN0KGdvKTtcblxuICB9IGVsc2Uge1xuICAgIC8vIENBU0UgMzogc29ja2V0IGV4aXN0cyBhbmQgY29ubmVjdGVkIC8gcmVhZHkgdG8gdXNlXG4gICAgZ28oc2VsZi5fc29ja2V0KTtcbiAgfVxufTtcblxuLy8gV2UgaGFuZGxlIHRyYWNraW5nIHRpbWVvdXRzIHdpdGggYW4gYXJyYXkgb2YgZGVhZGxpbmVzIChyZXF1ZXN0VGltZW91dHMpLCBhc1xuLy8gbm9kZSBkb2Vzbid0IGxpa2UgdXMgc2V0dGluZyB1cCBsb3RzIG9mIHRpbWVycywgYW5kIHVzaW5nIGp1c3Qgb25lIGlzIG1vcmVcbi8vIGVmZmljaWVudCBhbnl3YXkuXG52YXIgdGltZW91dEhhbmRsZXIgPSBmdW5jdGlvbihzZXJ2ZXIsIHNvY2spIHtcbiAgaWYgKHNlcnZlci5yZXF1ZXN0VGltZW91dHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gbm90aGluZyBhY3RpdmVcbiAgICBzZXJ2ZXIudGltZW91dFNldCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNvbWUgcmVxdWVzdHMgb3V0c3RhbmRpbmcsIGNoZWNrIGlmIGFueSBoYXZlIHRpbWVkLW91dFxuICB2YXIgbm93ID0gdGltZXN0YW1wKCk7XG4gIHZhciBzb29uZXN0VGltZW91dCA9IHNlcnZlci5yZXF1ZXN0VGltZW91dHNbMF07XG5cbiAgaWYgKHNvb25lc3RUaW1lb3V0IDw9IG5vdykge1xuICAgIC8vIHRpbWVvdXQgb2NjdXJyZWQhXG4gICAgc29jay5lbmQoKTtcbiAgICBzZXJ2ZXIuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgc2VydmVyLl9zb2NrZXQgPSB1bmRlZmluZWQ7XG4gICAgc2VydmVyLnRpbWVvdXRTZXQgPSBmYWxzZTtcbiAgICBzZXJ2ZXIuZXJyb3IobmV3IEVycm9yKCdzb2NrZXQgdGltZWQgb3V0IHdhaXRpbmcgb24gcmVzcG9uc2UuJykpO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vIHRpbWVvdXQhIFNldHVwIG5leHQgb25lLlxuICAgIHZhciBkZWFkbGluZSA9IHNvb25lc3RUaW1lb3V0IC0gbm93O1xuICAgIHNvY2suc2V0VGltZW91dChkZWFkbGluZSwgZnVuY3Rpb24oKSB7XG4gICAgICB0aW1lb3V0SGFuZGxlcihzZXJ2ZXIsIHNvY2spO1xuICAgIH0pO1xuICB9XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYmxvYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkZWFkbGluZSA9IE1hdGgucm91bmQoc2VsZi5vcHRpb25zLnRpbWVvdXQgKiAxMDAwKTtcbiAgdGhpcy5zb2NrKGZhbHNlLCBmdW5jdGlvbihzKSB7XG4gICAgcy53cml0ZShibG9iKTtcbiAgICBzZWxmLnJlcXVlc3RUaW1lb3V0cy5wdXNoKHRpbWVzdGFtcCgpICsgZGVhZGxpbmUpO1xuICAgIGlmICghc2VsZi50aW1lb3V0U2V0KSB7XG4gICAgICBzZWxmLnRpbWVvdXRTZXQgPSB0cnVlO1xuICAgICAgcy5zZXRUaW1lb3V0KGRlYWRsaW5lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGltZW91dEhhbmRsZXIoc2VsZiwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuU2VydmVyLnByb3RvdHlwZS53cml0ZVNBU0wgPSBmdW5jdGlvbihibG9iKSB7XG4gIHRoaXMuc29jayh0cnVlLCBmdW5jdGlvbihzKSB7XG4gICAgcy53cml0ZShibG9iKTtcbiAgfSk7XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zb2NrZXQpIHsgdGhpcy5fc29ja2V0LmVuZCgpOyB9XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnPFNlcnZlciAnICsgdGhpcy5ob3N0ICsgJzonICsgdGhpcy5wb3J0ICsgJz4nO1xufTtcblxuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/memjs/lib/memjs/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/memjs/lib/memjs/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/memjs/lib/memjs/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// # MemJS utility functions\n\nvar header = __webpack_require__(/*! ./header */ \"(rsc)/./node_modules/memjs/lib/memjs/header.js\");\n\nvar bufferify = function(val) {\n  return Buffer.isBuffer(val) ? val : Buffer.from(val);\n};\n\nexports.makeRequestBuffer = function(opcode, key, extras, value, opaque) {\n  key = bufferify(key);\n  extras = bufferify(extras);\n  value = bufferify(value);\n  var buf = Buffer.alloc(24 + key.length + extras.length + value.length);\n  buf.fill();\n  var requestHeader = {\n    magic: 0x80,\n    opcode: opcode,\n    keyLength: key.length,\n    extrasLength: extras.length,\n    totalBodyLength: key.length + value.length + extras.length,\n    opaque: opaque\n  };\n  header.toBuffer(requestHeader).copy(buf);\n  extras.copy(buf, 24);\n  key.copy(buf, 24 + extras.length);\n  value.copy(buf, 24 + extras.length + key.length);\n  return buf;\n};\n\nexports.makeAmountInitialAndExpiration = function(amount, amountIfEmpty, expiration) {\n  var buf = Buffer.alloc(20);\n  buf.writeUInt32BE(0, 0);\n  buf.writeUInt32BE(amount, 4);\n  buf.writeUInt32BE(0, 8);\n  buf.writeUInt32BE(amountIfEmpty, 12);\n  buf.writeUInt32BE(expiration, 16);\n  return buf;\n};\n\nexports.makeExpiration = function(expiration) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32BE(expiration, 0);\n  return buf;\n};\n\nexports.hashCode = function(str) {\n  var ret, i, len;\n  for(ret = 0, i = 0, len = str.length; i < len; i++) {\n    ret = (31 * ret + str.charCodeAt(i)) << 0;\n  }\n  return Math.abs(ret);\n};\n\nexports.parseMessage = function(dataBuf) {\n  if (dataBuf.length < 24) {\n    return false;\n  }\n  var responseHeader = header.fromBuffer(dataBuf);\n  if (dataBuf.length < responseHeader.totalBodyLength + 24 ||\n      responseHeader.totalBodyLength <\n        responseHeader.keyLength + responseHeader.extrasLength) {\n    return false;\n  }\n\n  var pointer = 24;\n  var extras = dataBuf.slice(pointer, pointer + responseHeader.extrasLength);\n  pointer += responseHeader.extrasLength;\n  var key = dataBuf.slice(pointer, pointer + responseHeader.keyLength);\n  pointer += responseHeader.keyLength;\n  var val = dataBuf.slice(pointer, 24 + responseHeader.totalBodyLength);\n\n  return {header: responseHeader, key: key, extras: extras, val: val};\n};\n\nexports.merge = function(original, deflt) {\n  var attr, originalValue;\n  for (attr in deflt) {\n    if (deflt.hasOwnProperty(attr)) {\n      originalValue = original[attr];\n\n      if (originalValue === undefined || originalValue === null) {\n        original[attr] = deflt[attr];\n      }\n    }\n  }\n  return original;\n};\n\n// timestamp provides a monotonic timestamp with millisecond accuracy, useful\n// for timers.\nexports.timestamp = function() {\n  var times = process.hrtime();\n  return (times[0] * 1000) + Math.round((times[1] / 1000000));\n};\n\nif(!Buffer.concat) {\n  Buffer.concat = function(list, length) {\n    if (!Array.isArray(list)) {\n      throw new Error('Usage: Buffer.concat(list, [length])');\n    }\n\n    if (list.length === 0) {\n      return Buffer.alloc(0);\n    }\n    if (list.length === 1) {\n      return list[0];\n    }\n\n    var i, buf;\n\n    if (typeof length !== 'number') {\n      length = 0;\n      for (i = 0; i < list.length; i++) {\n        buf = list[i];\n        length += buf.length;\n      }\n    }\n\n    var buffer = Buffer.alloc(length);\n    var pos = 0;\n    for (i = 0; i < list.length; i++) {\n      buf = list[i];\n      buf.copy(buffer, pos);\n      pos += buf.length;\n    }\n    return buffer;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxnRUFBVTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzaXlhbVxcRG9jdW1lbnRzXFxBSS1Qb3dlcmVkLUNoYXRib3RcXG5vZGVfbW9kdWxlc1xcbWVtanNcXGxpYlxcbWVtanNcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICMgTWVtSlMgdXRpbGl0eSBmdW5jdGlvbnNcblxudmFyIGhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyJyk7XG5cbnZhciBidWZmZXJpZnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWwpID8gdmFsIDogQnVmZmVyLmZyb20odmFsKTtcbn07XG5cbmV4cG9ydHMubWFrZVJlcXVlc3RCdWZmZXIgPSBmdW5jdGlvbihvcGNvZGUsIGtleSwgZXh0cmFzLCB2YWx1ZSwgb3BhcXVlKSB7XG4gIGtleSA9IGJ1ZmZlcmlmeShrZXkpO1xuICBleHRyYXMgPSBidWZmZXJpZnkoZXh0cmFzKTtcbiAgdmFsdWUgPSBidWZmZXJpZnkodmFsdWUpO1xuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKDI0ICsga2V5Lmxlbmd0aCArIGV4dHJhcy5sZW5ndGggKyB2YWx1ZS5sZW5ndGgpO1xuICBidWYuZmlsbCgpO1xuICB2YXIgcmVxdWVzdEhlYWRlciA9IHtcbiAgICBtYWdpYzogMHg4MCxcbiAgICBvcGNvZGU6IG9wY29kZSxcbiAgICBrZXlMZW5ndGg6IGtleS5sZW5ndGgsXG4gICAgZXh0cmFzTGVuZ3RoOiBleHRyYXMubGVuZ3RoLFxuICAgIHRvdGFsQm9keUxlbmd0aDoga2V5Lmxlbmd0aCArIHZhbHVlLmxlbmd0aCArIGV4dHJhcy5sZW5ndGgsXG4gICAgb3BhcXVlOiBvcGFxdWVcbiAgfTtcbiAgaGVhZGVyLnRvQnVmZmVyKHJlcXVlc3RIZWFkZXIpLmNvcHkoYnVmKTtcbiAgZXh0cmFzLmNvcHkoYnVmLCAyNCk7XG4gIGtleS5jb3B5KGJ1ZiwgMjQgKyBleHRyYXMubGVuZ3RoKTtcbiAgdmFsdWUuY29weShidWYsIDI0ICsgZXh0cmFzLmxlbmd0aCArIGtleS5sZW5ndGgpO1xuICByZXR1cm4gYnVmO1xufTtcblxuZXhwb3J0cy5tYWtlQW1vdW50SW5pdGlhbEFuZEV4cGlyYXRpb24gPSBmdW5jdGlvbihhbW91bnQsIGFtb3VudElmRW1wdHksIGV4cGlyYXRpb24pIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygyMCk7XG4gIGJ1Zi53cml0ZVVJbnQzMkJFKDAsIDApO1xuICBidWYud3JpdGVVSW50MzJCRShhbW91bnQsIDQpO1xuICBidWYud3JpdGVVSW50MzJCRSgwLCA4KTtcbiAgYnVmLndyaXRlVUludDMyQkUoYW1vdW50SWZFbXB0eSwgMTIpO1xuICBidWYud3JpdGVVSW50MzJCRShleHBpcmF0aW9uLCAxNik7XG4gIHJldHVybiBidWY7XG59O1xuXG5leHBvcnRzLm1ha2VFeHBpcmF0aW9uID0gZnVuY3Rpb24oZXhwaXJhdGlvbikge1xuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKDQpO1xuICBidWYud3JpdGVVSW50MzJCRShleHBpcmF0aW9uLCAwKTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbmV4cG9ydHMuaGFzaENvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHJldCwgaSwgbGVuO1xuICBmb3IocmV0ID0gMCwgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJldCA9ICgzMSAqIHJldCArIHN0ci5jaGFyQ29kZUF0KGkpKSA8PCAwO1xuICB9XG4gIHJldHVybiBNYXRoLmFicyhyZXQpO1xufTtcblxuZXhwb3J0cy5wYXJzZU1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhQnVmKSB7XG4gIGlmIChkYXRhQnVmLmxlbmd0aCA8IDI0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciByZXNwb25zZUhlYWRlciA9IGhlYWRlci5mcm9tQnVmZmVyKGRhdGFCdWYpO1xuICBpZiAoZGF0YUJ1Zi5sZW5ndGggPCByZXNwb25zZUhlYWRlci50b3RhbEJvZHlMZW5ndGggKyAyNCB8fFxuICAgICAgcmVzcG9uc2VIZWFkZXIudG90YWxCb2R5TGVuZ3RoIDxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIua2V5TGVuZ3RoICsgcmVzcG9uc2VIZWFkZXIuZXh0cmFzTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHBvaW50ZXIgPSAyNDtcbiAgdmFyIGV4dHJhcyA9IGRhdGFCdWYuc2xpY2UocG9pbnRlciwgcG9pbnRlciArIHJlc3BvbnNlSGVhZGVyLmV4dHJhc0xlbmd0aCk7XG4gIHBvaW50ZXIgKz0gcmVzcG9uc2VIZWFkZXIuZXh0cmFzTGVuZ3RoO1xuICB2YXIga2V5ID0gZGF0YUJ1Zi5zbGljZShwb2ludGVyLCBwb2ludGVyICsgcmVzcG9uc2VIZWFkZXIua2V5TGVuZ3RoKTtcbiAgcG9pbnRlciArPSByZXNwb25zZUhlYWRlci5rZXlMZW5ndGg7XG4gIHZhciB2YWwgPSBkYXRhQnVmLnNsaWNlKHBvaW50ZXIsIDI0ICsgcmVzcG9uc2VIZWFkZXIudG90YWxCb2R5TGVuZ3RoKTtcblxuICByZXR1cm4ge2hlYWRlcjogcmVzcG9uc2VIZWFkZXIsIGtleToga2V5LCBleHRyYXM6IGV4dHJhcywgdmFsOiB2YWx9O1xufTtcblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBkZWZsdCkge1xuICB2YXIgYXR0ciwgb3JpZ2luYWxWYWx1ZTtcbiAgZm9yIChhdHRyIGluIGRlZmx0KSB7XG4gICAgaWYgKGRlZmx0Lmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICBvcmlnaW5hbFZhbHVlID0gb3JpZ2luYWxbYXR0cl07XG5cbiAgICAgIGlmIChvcmlnaW5hbFZhbHVlID09PSB1bmRlZmluZWQgfHwgb3JpZ2luYWxWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBvcmlnaW5hbFthdHRyXSA9IGRlZmx0W2F0dHJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3JpZ2luYWw7XG59O1xuXG4vLyB0aW1lc3RhbXAgcHJvdmlkZXMgYSBtb25vdG9uaWMgdGltZXN0YW1wIHdpdGggbWlsbGlzZWNvbmQgYWNjdXJhY3ksIHVzZWZ1bFxuLy8gZm9yIHRpbWVycy5cbmV4cG9ydHMudGltZXN0YW1wID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aW1lcyA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gIHJldHVybiAodGltZXNbMF0gKiAxMDAwKSArIE1hdGgucm91bmQoKHRpbWVzWzFdIC8gMTAwMDAwMCkpO1xufTtcblxuaWYoIUJ1ZmZlci5jb25jYXQpIHtcbiAgQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uKGxpc3QsIGxlbmd0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbbGVuZ3RoXSknKTtcbiAgICB9XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgfVxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGxpc3RbMF07XG4gICAgfVxuXG4gICAgdmFyIGksIGJ1ZjtcblxuICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZiA9IGxpc3RbaV07XG4gICAgICAgIGxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgICB2YXIgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgYnVmID0gbGlzdFtpXTtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/memjs/lib/memjs/utils.js\n");

/***/ })

};
;